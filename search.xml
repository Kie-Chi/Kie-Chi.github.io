<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>计算机网络--概述</title>
    <url>/2024/10/04/CN_u1/</url>
    <content><![CDATA[<h1 id="计算机网络–概述"><a href="#计算机网络–概述" class="headerlink" title="计算机网络–概述"></a>计算机网络–概述</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>国庆好无聊啊，小熊饼干接待完朋友、过完生日之后实在是没有什么事了，但是又不想更新<code>Python</code>，所以他决定开始学习计网</li>
<li>本栏目仅仅是笔者自学内容，与北京航空航天大学的计网无关，我不是我没有</li>
</ul>
<h2 id="什么是计网"><a href="#什么是计网" class="headerlink" title="什么是计网"></a>什么是计网</h2><ul>
<li>硬件<ul>
<li><strong>主机</strong>,又称<strong>端系统</strong>可以简单理解我们日常使用的电脑、服务器、手机、各类智能嵌入式系统等，他们处于计算机网络的边缘，所以称为端系统</li>
<li><strong>通信链路</strong>，像网线、电缆、光纤等物理连接设备，例如可以将两台电脑使用网卡连接，就组成了一个简单的计算机网络</li>
<li><strong>通信设备</strong>，端系统向计算机网络核心传递信息的中转站，例如集线器、交换机、路由器，通过他们我们可以将若干简单的计算机网络组成复杂的计算机网络</li>
</ul>
</li>
<li>软件<ul>
<li>可以是在主机运行的应用程序，例如微信、QQ、网盘等，方便用户使用，实现资源共享的程序</li>
<li>可以是在通信设备中的控制程序，用以控制通信设备传输信息</li>
</ul>
</li>
<li>协议<ul>
<li>规定计算机网络中的通信规则，利用这种规则封装传递的信息或者解构信息</li>
</ul>
</li>
<li>$Attention$<ul>
<li>使用集线器可以简单连接某几台设备，缺点是可能导致发送信息之间的冲突</li>
<li>使用交换机则不会出现信息冲突，不过交换机一般用于构建较小的计算机网络</li>
<li>使用路由器可以构建计算机网络核心，即各种通路</li>
</ul>
</li>
</ul>
<p>举一个快递的例子(似乎所有教材都会有一个快递的例子)：快递相当于传递的信息；各个快递终点站、快递驿站相当于端系统；公路、高速、立交桥相当于各种通信链路；快递中转站及仓库可以理解为通信设备；快递公司的运行规则和交通规则相当于协议</p>
<hr>
<h2 id="计网的功能"><a href="#计网的功能" class="headerlink" title="计网的功能"></a>计网的功能</h2><ul>
<li>数据通信<ul>
<li>实现计算机（端系统）之间的数据传输，是最基本、最重要的功能</li>
</ul>
</li>
<li>资源共享<ul>
<li>请求服务器处理、网盘、分享视频、应用商店等</li>
</ul>
</li>
<li>分布式处理<ul>
<li>将某个复杂任务分配给网络中多台计算机处理，提高任务处理效率</li>
</ul>
</li>
<li>提高可靠性<ul>
<li>网络中各台计算机互为替代，数据冗余备份等操作</li>
</ul>
</li>
<li>复杂均衡<ul>
<li>网络中多台计算机共同分担繁杂工作，如游戏服务器</li>
</ul>
</li>
</ul>
<hr>
<h2 id="计网通信"><a href="#计网通信" class="headerlink" title="计网通信"></a>计网通信</h2><h3 id="计网通信方式"><a href="#计网通信方式" class="headerlink" title="计网通信方式"></a>计网通信方式</h3><ul>
<li>因为在计算机之前已经有电话与发报机等可以传递信息的工具，那么计算机通信方式是否可以参考“前辈”的经验呢？答案是肯定的</li>
</ul>
<h4 id="电路交换技术"><a href="#电路交换技术" class="headerlink" title="电路交换技术"></a>电路交换技术</h4><ul>
<li>曾经的固定电话是通过电话线连接到电路交换器上的，在指定通信方与被通信方之后通过人工或者机器的方式连接实际物理电路，传递消息<ul>
<li>建立连接（尝试占用资源）</li>
<li>通信（持续占用通信资源）</li>
<li>断开连接（归还占用资源）<br><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CN_u1_1.png" alt="电路交换示意图"></li>
</ul>
</li>
<li>优缺点分析<ul>
<li>优点<ul>
<li>建立了专用的物理电路，两个用户始终占用线路资源，数据传输速度快</li>
</ul>
</li>
<li>缺点<ul>
<li>建立&#x2F;释放连接需要额外的时间开销，等待通信时间可能过长</li>
<li>线路被通信双方占用，利用率差</li>
<li>线路的分配灵活性差（线路单一）</li>
<li>不支持差错控制，无法更改或者发现通信的错误</li>
</ul>
</li>
</ul>
</li>
<li>由于电路交换技术适合少频次大量数据的场景，一般的计算机通信常常是高频次少量数据的传递，所以计算机通信方式不适合<strong>直接沿用</strong>电路交换技术（为什么是直接沿用呢？）</li>
</ul>
<h4 id="报文交换技术"><a href="#报文交换技术" class="headerlink" title="报文交换技术"></a>报文交换技术</h4><ul>
<li>发报机通过线路连接到报文转发机上，通过对信息头部加入地址信息，由转发机自动向目的地转发，而不需要实际地接线<br><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CN_u1_2.png" alt="报文交换示意图"></li>
<li>优缺点分析<ul>
<li>优点<ul>
<li>不用占用通信双方中地资源，利用率高</li>
<li>无需建立连接，线路可以灵活分配</li>
<li>交换节点时可以“差错控制”</li>
</ul>
</li>
<li>缺点<ul>
<li>报文长度不定，报文交换机地存储空间难以规定大小</li>
<li>长报文存储转发的时间开销大，缓存开销大</li>
<li>长报文的纠错困难，重发的代价大</li>
</ul>
</li>
</ul>
</li>
<li>由于对长报文的传输支持困难，所以计算机通信方式也没有沿用报文交换技术，而是在报文交换技术的基础上改进而成的分组交换技术</li>
</ul>
<h4 id="分组交换技术"><a href="#分组交换技术" class="headerlink" title="分组交换技术"></a>分组交换技术</h4><ul>
<li>将长报文分为若干段，称为分组(Packet)然后我们的传递最小单位由报文变成分组<br><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CN_u1_3.png" alt="分组交换示意图"></li>
<li>优缺点分析<ul>
<li>优点<ul>
<li>同报文交换技术</li>
<li>存储转发的时间开销小，缓存开销小</li>
<li>不易出错，且重传的代价小</li>
</ul>
</li>
<li>缺点<ul>
<li>控制信息占比增加</li>
<li>存储转发时延依旧存在</li>
<li>发送的各个分组存在顺序问题，可能导致混乱</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="虚电路交换技术"><a href="#虚电路交换技术" class="headerlink" title="虚电路交换技术"></a>虚电路交换技术</h4><ul>
<li>对于分组交换技术可能出现的顺序问题，虚电路技术提供了一种方式解决（沿用了电路交换技术的策略）<ul>
<li>建立连接（没有实际电路，仅作规划路径使用）</li>
<li>通信（分组按照顺序以构建好的路线传递，通信双方不用占用线路）</li>
<li>释放连接<br><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CN_u1_4.png" alt="虚电路交换示意图"></li>
</ul>
</li>
<li>优缺点分析<ul>
<li>优点<ul>
<li>同分组交换技术优点</li>
</ul>
</li>
<li>缺点<ul>
<li>同分组交换技术缺点</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><ul>
<li>对于上述电路交换技术、报文交换技术、分组交换技术进行性能的分析<br><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CN_u1_5.png" alt="时序图"><br><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CN_u1_6.png" alt="性能分析对比图"></li>
</ul>
<hr>
<h2 id="计网分类"><a href="#计网分类" class="headerlink" title="计网分类"></a>计网分类</h2><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><ul>
<li>广域网(Wide Area Network)<ul>
<li>范围大，跨省、跨国、跨洲</li>
</ul>
</li>
<li>城域网(Metropolitan Area Network)<ul>
<li>范围较大，一个或几个相邻的城市</li>
<li>通信技术采用“以太网技术”，常并入局域网范畴讨论</li>
</ul>
</li>
<li>局域网(Local Area Network)<ul>
<li>范围稍小，学校&#x2F;企业&#x2F;家庭等</li>
<li>通信技术采用“以太网技术”</li>
</ul>
</li>
<li>个域网(Personal Area Network)<ul>
<li>范围小，家庭&#x2F;个人</li>
<li>常使用无线技术将个人设备连接起来的网络，因此也被称为无线个域网(WPAN)</li>
</ul>
</li>
</ul>
<h3 id="传输技术"><a href="#传输技术" class="headerlink" title="传输技术"></a>传输技术</h3><ul>
<li>广播式网络<ul>
<li>计算机发送数据分组时，广播范围内的所有计算机都会收到该分组，通过检查分组地址决定是否接受分组</li>
</ul>
</li>
<li>点对点网络<ul>
<li>精确地发向某个计算机</li>
</ul>
</li>
</ul>
<h3 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h3><ul>
<li>总线形结构<ul>
<li>数据采取广播式技术，存在“总线争用”的现象</li>
<li>集线器连接的设备</li>
</ul>
</li>
<li>环形结构<ul>
<li>数据广播式传播但是，可以通过“令牌”指定当前发送数据的计算机，即拿到“令牌”者可以控制总线的数据，从而解决“总线争用的问题”</li>
<li>令牌环网</li>
</ul>
</li>
<li>星形结构<ul>
<li>由中央设备实现各个设备的“点对点”传输，不存在“总线争用”的现象</li>
<li>以太网交换机连接的设备</li>
</ul>
</li>
<li>网状结构<ul>
<li>数据通过各个中间节点逐一存储转发，实现数据“点对点”的传输</li>
<li>由众多路由器构建的广域网</li>
</ul>
</li>
</ul>
<h3 id="使用者"><a href="#使用者" class="headerlink" title="使用者"></a>使用者</h3><ul>
<li>公用网<ul>
<li>公开的网络，只要向<code>ISP</code>付钱即可</li>
</ul>
</li>
<li>专用网<ul>
<li>内部使用网络，例如，国家总局、银行等的内网</li>
</ul>
</li>
</ul>
<hr>
<h2 id="计网性能指标"><a href="#计网性能指标" class="headerlink" title="计网性能指标"></a>计网性能指标</h2><ul>
<li>信道<ul>
<li>即信息传输的通道，一般而言我们所说的<strong>通信线路</strong>往往对应着一个发送信道和一个接收信道</li>
</ul>
</li>
<li>速度相关<ul>
<li>速率，连接在网络的节点的数据沿着信道传输的速率，也称作<strong>数据传输速率</strong>，单位一般为(<code>bps</code> <code>Kbps</code> <code>Mbps</code>)，这里的<code>K</code>是 $10^3$，与计算机组成不同</li>
<li>带宽<ul>
<li>含义一，表示一个信道所能传输数据的最大速率，即<strong>最高数据率</strong>，可以有上行带宽和下行带宽</li>
<li>含义二，表示某个信道允许通过的信号频带范围，单位是<code>Hz</code>，两个含义其实有某些关系哦</li>
<li>节点间通信的最高速率由带宽和节点性能共同限制</li>
</ul>
</li>
<li>吞吐量<ul>
<li>单位时间通过某个网络的实际数量，所以要计算上行和下行速率</li>
</ul>
</li>
</ul>
</li>
<li>时延相关<ul>
<li>各种时延<ul>
<li>发送时延(传输时延)<ul>
<li>将数据全部传入信道的时间($ \frac{M_{数据大小}} {V_{数据传输速率}} $)</li>
</ul>
</li>
<li>传播时延<ul>
<li>数据在信道上传输的时间($ \frac{L_{信道长度}} {V_{信号传播速率}} $)</li>
</ul>
</li>
<li>处理时延<ul>
<li>路由器处理数据的时间(分析首部、查找存储转发表)</li>
</ul>
</li>
<li>排队时延<ul>
<li>数据入队和出队花费的时间<br><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CN_u1_7.jpg" alt="加油站时延示意图"></li>
</ul>
</li>
</ul>
</li>
<li>时延带宽积<ul>
<li>$ X_{时延带宽积} &#x3D; T_{传播时延} \times M_{带宽} $</li>
</ul>
</li>
<li>往返时延(Round-Trip Time)<ul>
<li>从发送方<strong>发送完数据</strong>，到发送方<strong>收到来自接收方的确认</strong>总共经历的时间</li>
<li>例如，游戏时延即“手机-服务器”的往返时延<code>RTT</code></li>
</ul>
</li>
</ul>
</li>
<li>信道利用率<ul>
<li>$ \frac{T_{有数据通过}} {T_{有数据通过} + T_{没有数据通过}} $</li>
<li>信道利用率不能太低，会浪费资源</li>
<li>信道利用率不能太高，容易导致网络拥塞</li>
</ul>
</li>
</ul>
<hr>
<h2 id="计网分层"><a href="#计网分层" class="headerlink" title="计网分层"></a>计网分层</h2><ul>
<li>就如快递链一样，计算机网络中实现传递数据也是需要实现许许多多的功能，例如封装数据、校验数据、解析数据等等各种复杂的功能</li>
<li>这里给出一些完整功能，可以先尝试理解<ul>
<li>差错控制：确保数据在传输过程中不会出错</li>
<li>流量控制：发送端发送数据的速率必须比接收端的接收速率小，来得及接收</li>
<li>分段与重装：发送端将要发送的数据分解为更小的单位，并且在接收端将其还原</li>
<li>复用与分用：发送端几个高层会话共同使用一条低层的连接，然后在接收端进行分用</li>
<li>连接建立与释放：交换数据前先建立一条逻辑连接，数据传输结束后释放</li>
</ul>
</li>
<li>采取分层的策略可以将问题分为各种小问题，以局部实现的策略实现</li>
</ul>
<h3 id="常见分层结构"><a href="#常见分层结构" class="headerlink" title="常见分层结构"></a>常见分层结构</h3><ul>
<li><code>OSI</code>模型<ul>
<li>考虑的功能更加全面，会出现统一功能出现在多个层面</li>
<li>法律上的标准</li>
</ul>
<ol>
<li>物理层</li>
<li>数据链路层</li>
<li>网络层</li>
<li>传输层</li>
<li>会话层</li>
<li>表示层</li>
<li>应用层</li>
</ol>
</li>
<li><code>TCP/IP</code>模型<ul>
<li>结构更加简单，同一功能只会出现在某一个层面</li>
<li>事实上的标准</li>
</ul>
<ol>
<li>网络接口层</li>
<li>网络层</li>
<li>传输层</li>
<li>应用层</li>
</ol>
</li>
<li>教学模型<ol>
<li>物理层</li>
<li>数据链路层</li>
<li>网络层</li>
<li>传输层</li>
<li>应用层<br><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CN_u1_8.png" alt="各模型示意图"></li>
</ol>
</li>
<li><strong>实体</strong><ul>
<li>同处于某一层的活动元素(硬件与软件)被称为第<code>n</code>层的实体，不同节点上的同一层被称为<strong>对等层</strong>，同一层的对应实体被称为<strong>对等实体</strong></li>
</ul>
</li>
<li><strong>协议</strong><ul>
<li>对等实体的通信规则，约束了对等实体之间的数据传输的要求</li>
</ul>
</li>
<li><strong>接口</strong><ul>
<li>同一节点相邻两层的实体交换信息的逻辑通道，又称为<strong>服务访问点</strong>(Service Access Point，SAP)</li>
</ul>
</li>
<li><strong>服务</strong><ul>
<li>同一节点相邻两层中下层为上层提供的功能调用(这里层数小的在下，层数大的在上)</li>
</ul>
</li>
</ul>
<h3 id="数据传输过程"><a href="#数据传输过程" class="headerlink" title="数据传输过程"></a>数据传输过程</h3><ul>
<li>原始数据通过多层处理为物理信号传输，在通过多层反处理转换回数据<br><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CN_u1_9.jpg" alt="数据传输示意图"></li>
<li>数据定义<ul>
<li>协议数据单元(Protocol Data Unit)<ul>
<li>对等层之间传递的消息，第<code>n</code>层的协议数据单元写作<code>n-PDU</code></li>
</ul>
</li>
<li>服务数据单元(Service Data Unit)<ul>
<li>为完成这一层实体而从上一层传入的数据，第<code>n</code>层的服务数据单元写作<code>n-SDU</code></li>
</ul>
</li>
<li>协议控制信息(Protocol Control Infomation)<ul>
<li>控制协议操作的信息，第<code>n</code>层的协议控制信息写作<code>n-PCI</code></li>
</ul>
</li>
<li>三者之间的关系<ul>
<li><code>n-PDU</code> &#x3D; <code>n-PCI</code> + <code>n-SDU</code></li>
<li><code>n-SDU</code> &#x3D; <code>n-1-PDU</code></li>
</ul>
</li>
</ul>
</li>
<li>协议定义<ul>
<li>语法<ul>
<li>数据与控制信息的格式。例如协议控制信息部分占几个字节、每个字节是什么含义、协议的数据部分最多有多少字节</li>
</ul>
</li>
<li>语义<ul>
<li>需要发送何种控制信息，完成何种动作及作出何种应答，例如发送完数据后接收方是否需要“应答”，以及应答的种类(传输成功、传输失败)</li>
</ul>
</li>
<li>时序<ul>
<li>执行各种操作的条件、时序关系等，即事件实现顺序的详细说明，例如发送方发送数据后接收方需要立即应答，如果发送方在 10 秒内没有应答，发送方会再次发送数据</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="OSI与TCP-IP"><a href="#OSI与TCP-IP" class="headerlink" title="OSI与TCP/IP"></a><code>OSI</code>与<code>TCP/IP</code></h3><h4 id="OSI模型详述"><a href="#OSI模型详述" class="headerlink" title="OSI模型详述"></a><code>OSI</code>模型详述</h4><ul>
<li>常见网络设备功能层次<ul>
<li>主机：<code>#1 ~ #7</code></li>
<li>集线器：<code>#1</code></li>
<li>交换机：<code>#1 ~ #2</code></li>
<li>路由器：<code>#1 ~ #3</code></li>
<li>物理传输媒体：<code>#0</code></li>
</ul>
</li>
<li>各层详解<ol>
<li>物理层<ul>
<li>实现相邻节点<code>bit</code>传输</li>
<li>定义电路接口参数，形状、尺寸、引脚数等</li>
<li>定义传输信号含义，例如 5v 代表 1，1v 代表 0，每<code>bit</code>传输的持续时间为 0.1ms</li>
</ul>
</li>
<li>数据链路层<ul>
<li>保证相邻节点间的链路<strong>逻辑上无差错</strong></li>
<li>原始数据传入链路层，链路层对长信息<strong>拆分并添加校验位</strong>组成**帧(Frame)**含有多个<code>bit</code>，再将帧陆续传给物理层转化为实际的物理信号传输       </li>
<li><strong>差错控制</strong>：检错+纠错或者检错+丢弃+重传</li>
<li><strong>流量控制</strong>：协调相邻节点的帧的传输速率</li>
</ul>
</li>
<li>网络层<ul>
<li>将分组<strong>从源结点转发至目的结点</strong></li>
<li><strong>路由选择</strong>：构造并且维护路由表，选择从源结点转向目的结点的最佳路径</li>
<li><strong>分组转发</strong>：将分组从合适的端口传出</li>
<li><strong>拥塞控制</strong>：发现网络拥塞，并采取措施缓解拥塞</li>
<li><strong>网际互联</strong>：由于各个局域网可能采用不同的技术，通过网络层实现异构网络的互联</li>
<li><strong>差错控制</strong>：校验分组</li>
<li><strong>流量控制</strong>：协调分组的传输速率</li>
<li><strong>连接建立与释放</strong>：建立虚电路发送分组</li>
<li><strong>可靠传输管理</strong>：接收方返回分组确认消息</li>
</ul>
</li>
<li>传输层<ul>
<li>端到端的通信，即实现<strong>进程到进程</strong>的通信</li>
<li>多个不同进程的数据通过传输层组合成<strong>报文段</strong>(Segment)</li>
<li><strong>复用与分用</strong>：发送端的几个高层实体例如微信、QQ 的数据共同组成报文段，复用接下来低层的路线；在接收端将报文段重新拆分为多个端口的数据传入</li>
<li><strong>差错控制</strong>：校验报文段</li>
<li><strong>流量控制</strong>：协调报文段段的传输速率</li>
<li><strong>建立连接与释放</strong>：建立虚电路发送报文段</li>
<li><strong>可靠传输管理</strong>：接收方返回报文段确认消息</li>
</ul>
</li>
<li>会话层<ul>
<li>管理进程间的会话</li>
<li><strong>会话管理</strong>：采用检查点机制，当通信失效时从检查点继续恢复通信</li>
</ul>
</li>
<li>表示层<ul>
<li>解决不同主机上编码方式不同，数据格式转换还有压缩、解密等</li>
</ul>
</li>
<li>应用层<ul>
<li>实现特定的网络应用</li>
<li>各类数据以<strong>报文</strong>(Message)为单位传递</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="TCP-IP模型详述"><a href="#TCP-IP模型详述" class="headerlink" title="TCP/IP模型详述"></a><code>TCP/IP</code>模型详述</h4><ul>
<li><code>OSI</code>与<code>TCP/IP</code>模型的区别<ul>
<li><code>OSI.#5~#7</code>与<code>TCP/IP.#4</code><ul>
<li>数据编码格式转换与会话管理功能并不是对于每个网络应用都需要的，所以可以并入应用层</li>
<li>对于某些需要这种特定功能的应用，可以采用具有特定功能的协议去完成</li>
</ul>
</li>
<li><code>OSI.#1~#2</code>与<code>TCP/IP.#1</code><ul>
<li>网络层将分组传递给网络接口层，但是不硬性规定处理或者传输分组的方式</li>
</ul>
</li>
<li><code>OSI.#3</code>与<code>TCP/IP.#2</code><ul>
<li><code>TCP/IP</code>模型的网络层取消了对于分组检查与控制协调的若干功能，如差错控制、流量控制、连接管理、可靠传输管理</li>
<li><code>TCP/IP</code>模型的网络层的传输数据不可靠</li>
<li><code>TCP/IP</code>模型中不需要中间路由器等计算机网络核心管理流量等行为而将各种功能施加在端系统中</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络--物理层</title>
    <url>/2024/10/06/CN_u2/</url>
    <content><![CDATA[<h1 id="计算机网络–物理层"><a href="#计算机网络–物理层" class="headerlink" title="计算机网络–物理层"></a>计算机网络–物理层</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>在上一次的 blog 中我们对于计算机网络的结构功能等基础内容，从这一节开始我们将要学习的是计算机网络模型的第一层–物理层，通过物理层我们可以将需要传递的数据变为真实的物理信号，由此通过信息通路(也就是第零层)传递出去</li>
</ul>
<h2 id="通信基础"><a href="#通信基础" class="headerlink" title="通信基础"></a>通信基础</h2><ul>
<li>信源<ul>
<li>信息的发送方</li>
</ul>
</li>
<li>信宿<ul>
<li>信息的接收方</li>
</ul>
</li>
<li>信道<ul>
<li>信息传输的通道</li>
</ul>
</li>
<li>信号<ul>
<li>数字信号：信号是离散的</li>
<li>模拟信号：信号是连续的</li>
</ul>
</li>
</ul>
<hr>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><ul>
<li>在计算机中，我们常常使用一位的二进制 0&#x2F;1 来表示信号，但是这并不代表着信号只能是一位的二进制(两种)</li>
<li><strong>码元</strong><ul>
<li>每一个信号都是一个码元，每一个码元都对应一个二进制数</li>
<li>对于一位的信号只有两种码元，我们称为<strong>二进制码元</strong>；对于两位的信号会有四种码元，我们称为<strong>四进制码元</strong>。一个信号输出的整个周期被称为信号周期或者码元周期</li>
<li>优缺点<ul>
<li>优点：每个信号周期可以携带更多信息，每个码元可以携带更多信息</li>
<li>缺点：需要加强信号功率，并且对信道的要求更高</li>
</ul>
</li>
</ul>
</li>
<li><strong>码元</strong>与<strong>比特</strong>的关系<ul>
<li>一个码元可以携带多少比特，这取决于一个码元周期可以有多少种信号</li>
<li>$ X_{码元} &#x3D; \log_2 K * X_{比特}$($K$为信号的种类数量)</li>
</ul>
</li>
<li>速率<ul>
<li>波特率：每秒钟传递多少码元</li>
<li>比特率：每秒钟传递多少比特信息</li>
</ul>
</li>
</ul>
<hr>
<h3 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h3><ul>
<li><strong>带宽</strong><ul>
<li>含义一：传输的最大速率</li>
<li>含义二：允许通过的信号频带范围<br><font color = red> $Attention$</font>:下面为了方便突出两者的联系，取<strong>最高传输速率</strong>表示带宽第一种含义，取<strong>带宽</strong>只表示第二种含义<br>
虽然带宽的两种含义看起来毫不相关，但是下面介绍的两个定理都揭示了这两种含义之间的内在联系，在这之前我们先介绍噪声，这个极易影响信息传输的坏家伙</li>
</ul>
</li>
<li><strong>噪声</strong><ul>
<li>对于在信道中传输的信号有干扰作用，会影响信道的数据传输速率<br>这和我们在学习物理中声音的噪声概念几乎是一致的，都是干扰、妨碍的作用。</li>
</ul>
</li>
<li><strong>奈奎斯特定理</strong>(奈氏准则)<ul>
<li>对于一个<strong>理想低通信道</strong>(没有噪声、带宽有限的信道)</li>
<li>$ V_{极限波特率} &#x3D; 2 * X_{带宽}$</li>
<li>注意<strong>极限波特率</strong>与最高传输速率(默认比特率的转换<br>奈氏准则向我们揭示了<strong>无噪声</strong>情况下最高传输速率与带宽之间的内在联系</li>
</ul>
</li>
<li><strong>香农定理</strong><ul>
<li>对于一个有噪声、带宽有限的信道</li>
<li>$ V_{极限比特率} &#x3D; X_{带宽} * \log_2 (1 + S&#x2F;N) $</li>
<li>$S&#x2F;N$是信噪比，即$\frac{W_{信号的功率}} {W_{噪声的功率}}$</li>
<li>由于信噪比的值往往很大，所以我们采取另一种记录信噪比的记法，即$ N_{信噪比} &#x3D; 10 * \log_{10} S&#x2F;N $单位是<code>dB</code></li>
<li>注意是<strong>极限比特率</strong></li>
</ul>
</li>
</ul>
<hr>
<h3 id="信号变换"><a href="#信号变换" class="headerlink" title="信号变换"></a>信号变换</h3><ul>
<li>数字信号<ul>
<li>对于二进制数据与数字信号之间的转换，我们称为<strong>编码与解码</strong></li>
</ul>
</li>
<li>模拟信号<ul>
<li>对于二进制数据与模拟信号之间的转换，我们称之为<strong>调制与解调</strong><br><strong>变换器</strong>可以将二进制信号转换为物理信号，<strong>反变换器</strong>可以将物理信号转换为二进制信号</li>
</ul>
</li>
<li>变换器<ul>
<li>有线网络适配器(网卡)：编码-解码器</li>
<li>光猫：调制-解调器</li>
</ul>
</li>
</ul>
<hr>
<h4 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a>编码方式</h4><ul>
<li>不归零编码(Non-Return-to-Zero)<ul>
<li>低 0 高 1，中不变</li>
<li>在每一个信号周期内信号始终不会归零，缺点是要给出时钟线</li>
</ul>
</li>
<li>归零编码(Return-to-Zero)<ul>
<li>低 0 高 1，中归零</li>
<li>每一个信号周期中间信号归零，保持发送方与接收方的时间节奏，保持时钟信号</li>
</ul>
</li>
<li>反向非归零编码(Non-Return-to-Zero-Inverted)<ul>
<li>起点跳 0 不跳 1，中不变</li>
<li>每一个信号周期始终不归零，但是看每一个周期的起点是否会发生跳变</li>
</ul>
</li>
<li>曼彻斯特编码<ul>
<li>上跳 0 下跳 1，中必变</li>
<li>每个周期中间位置将发生信号的跳变，根据信号是向上跳变还是向下跳变来规定这个信号周期对应的到底是 0 还是 1</li>
</ul>
</li>
<li>差分曼彻斯特编码<ul>
<li>起点跳 0 不跳 1，中必变</li>
<li>与<code>NRZI</code>的区别在于信号周期中间一定会发生跳变<br><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CN_u2_1.jpg" alt="编码方式示意图"><table>
<thead>
<tr>
<th align="center">编码方式</th>
<th align="center">自同步能力</th>
<th align="center">浪费带宽</th>
<th align="center">抗干扰能力</th>
</tr>
</thead>
<tbody><tr>
<td align="center">非归零编码</td>
<td align="center">无</td>
<td align="center">不浪费</td>
<td align="center">弱</td>
</tr>
<tr>
<td align="center">归零编码</td>
<td align="center">有</td>
<td align="center">浪费</td>
<td align="center">弱</td>
</tr>
<tr>
<td align="center">反向非归零编码</td>
<td align="center">增加冗余位可支持</td>
<td align="center">浪费(浪费的是冗余位)</td>
<td align="center">弱</td>
</tr>
<tr>
<td align="center">曼彻斯特编码</td>
<td align="center">有</td>
<td align="center">浪费</td>
<td align="center">强</td>
</tr>
<tr>
<td align="center">差分曼彻斯特编码</td>
<td align="center">有</td>
<td align="center">浪费</td>
<td align="center">强</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="调制方式"><a href="#调制方式" class="headerlink" title="调制方式"></a>调制方式</h4><ul>
<li>调幅(<code>AM</code>) or 幅移键控(<code>ASK</code>)<ul>
<li>根据振幅表示信号</li>
<li>有振幅为 1，无振幅为 0</li>
<li>不同码元的振幅不同</li>
</ul>
</li>
<li>调频(<code>FM</code>) or 频移键控(<code>FSK</code>)<ul>
<li>根据频率表示信号</li>
<li>例如频率低为 0，频率高为 1</li>
<li>不同的码元频率不同</li>
</ul>
</li>
<li>调相(<code>PM</code>) or 相移键控(<code>PSK</code>)<ul>
<li>根据相位表示信号</li>
<li>例如相位为 0 则为 0，相位为$\pi$ 则为 1</li>
<li>不同的码元相位不同<br>对于这些调制方式甚至可以采用复合的方式，产生不同的调制方式</li>
</ul>
</li>
<li>正交幅度调制(<code>QAM</code>)<ul>
<li>例如有<code>m</code>种振幅大小与<code>n</code>种频率大小，则共同可以综合出<code>mn</code>种码元<br><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CN_u2_2.jpg" alt="调制方式示意图"></li>
</ul>
</li>
</ul>
<hr>
<h4 id="传输介质"><a href="#传输介质" class="headerlink" title="传输介质"></a>传输介质</h4><ul>
<li>导向型介质：即沿着特定的方向传播，一般而言，有线信号是使用导向型介质<ul>
<li>双绞线(<code>Twisted Pair</code>)<ul>
<li>主要构成：两根导线相互绞合而成</li>
<li>有屏蔽层：<code>Shielded Twisted Pair</code>，无屏蔽层：<code>Unshielded Twisted Pair</code></li>
<li>抗干扰能力：较好，因为导线绞合以及屏蔽层可以提升抗电磁干扰能力</li>
</ul>
</li>
<li>同轴电缆<ul>
<li>主要构成：内导体(用于传输信号) + 外导体屏蔽层(用于抗电磁干扰)</li>
<li>抗干扰能力：好，因为外导体提供电磁屏蔽可以带来良好的抗干扰性</li>
</ul>
</li>
<li>光纤<ul>
<li>主要构成：纤芯(高折射率) + 包层(低折射率)，利用光的全反射特性让光信号在纤芯内传播</li>
<li>单模光纤：一根光纤中只有一条光线传播，适合长距离的传播；多模光纤：一根光纤中有多条光线传播，适合短距离的传播</li>
<li>抗干扰能力：非常好，光信号对电磁干扰不敏感</li>
</ul>
</li>
</ul>
</li>
<li>非导向型介质：无特定方向传播，一般而言，无线信号是使用非导向型介质<ul>
<li>无线电波<ul>
<li>特点：穿透能力强、传播距离长、信号指向型弱</li>
<li>例如：手机、WIFI 信号</li>
</ul>
</li>
<li>微波<ul>
<li>特点：频率带宽高、信号指向型强、保密性差(容易被窃听)</li>
<li>例如：卫星通信</li>
</ul>
</li>
<li>红外通信、激光通信</li>
</ul>
</li>
<li>以太网对有线介质的命名<ul>
<li>速度 + <code>Base</code> + 介质信息<ul>
<li><code>10Base5</code>：10<code>Mbps</code> + 同轴电缆 + 最远传输距离 500m</li>
<li><code>10Base2</code>：10<code>Mbps</code> + 同轴电缆 + 最远传输距离 200m</li>
<li><code>10BaseF*</code>：10<code>Mbps</code> + 光纤 + *某些其他信息</li>
<li><code>10BaseT*</code>：10<code>Mbps</code> + 双绞线 + *某些其他信息</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="物理层设备"><a href="#物理层设备" class="headerlink" title="物理层设备"></a>物理层设备</h4><ul>
<li><p>中继器(<code>Repeater</code>)</p>
<ul>
<li>若规定 0.5V～1V 是低电平，4.5V～5V 是高电平，不符合此标准的信号视为无效</li>
<li>如果中继器接收了有效的信号会将低电平整形为 1V，将高电平整形为 5V</li>
<li>仅支持<strong>半双工通信</strong>，中继器连接的两个端口不允许同时发送数据，会导致“冲突”</li>
</ul>
</li>
<li><p>集线器(<code>Hub</code>)</p>
<ul>
<li>本质上是多端中继器，集线器将其中一个端口接收到的信号整形再生后，转发到所有的端口中</li>
<li>集线器各端口连接的结点不可以同时发送数据，会导致“冲突”</li>
</ul>
</li>
<li><p>冲突域</p>
<ul>
<li>如果两台主机同时发送数据会导致冲突，则这两台主机处于同一<strong>冲突域</strong>中</li>
</ul>
</li>
<li><p>其他特性</p>
<ul>
<li>集线器、中继器不能<strong>“无限串联”</strong><ul>
<li><code>10Base5</code>遵循<code>5-4-3</code>原则，使用集线器连接<code>10Base5</code>网线时，最多只能串联<strong>5</strong>个网段，使用<strong>4</strong>台集线器，只有<strong>3</strong>个网段可以连接计算机</li>
</ul>
</li>
<li>集线器逻辑上是总线型拓扑结构<ul>
<li>集线器连接的各个网段会“共享带宽”，集线器的总带宽被连接的各个主机平均分配</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>北航计算机组成P0课下</title>
    <url>/2024/09/24/CO_P0/</url>
    <content><![CDATA[<h1 id="北航计算机组成原理P0课下"><a href="#北航计算机组成原理P0课下" class="headerlink" title="北航计算机组成原理P0课下"></a>北航计算机组成原理P0课下</h1><h3 id="P0课下做题的一些分享，思路不一定是最佳实现思路，敬请大家斧正"><a href="#P0课下做题的一些分享，思路不一定是最佳实现思路，敬请大家斧正" class="headerlink" title="P0课下做题的一些分享，思路不一定是最佳实现思路，敬请大家斧正"></a>P0课下做题的一些分享，思路不一定是最佳实现思路，敬请大家斧正</h3><div class="note warning simple"><p>注意$logisim$的$Appearance$调整</p>
</div>

<h2 id="P0-Q1-CRC校验码"><a href="#P0-Q1-CRC校验码" class="headerlink" title="P0.Q1 CRC校验码"></a>P0.Q1 CRC校验码</h2><ul>
<li><del>读完了题目感觉题目和校验没什么关系</del><br>教程已经有了明显的提示，使用<strong>4位模2运算电路</strong>拼出11位的模2除法运算电路，考虑到本题应该是一个组合电路题，所以笔者使用了类似行波进位器的电路<ul>
<li>子电路定义如下(:sob:英语不好轻喷 )<table>
<thead>
<tr>
<th align="center">定义接口</th>
<th align="center">方向</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">div[2:0]</td>
<td align="center">I</td>
<td align="center">上一次$mod2$运算留下的余数</td>
</tr>
<tr>
<td align="center">new</td>
<td align="center">I</td>
<td align="center">本次$mod2$运算放在尾端的数</td>
</tr>
<tr>
<td align="center">todiv[3:0]</td>
<td align="center">I</td>
<td align="center">除数</td>
</tr>
<tr>
<td align="center">hi[2:0]</td>
<td align="center">O</td>
<td align="center">余数</td>
</tr>
<tr>
<td align="center">lo</td>
<td align="center">O</td>
<td align="center">商</td>
</tr>
</tbody></table>
</li>
<li>有八次$mod2$运算所以实现了八个子电路$M_i ( 1 \le i \le 8)$</li>
<li>利用<code>Splitter</code>分出后五位和三位零依次传入子电路中</li>
<li>连接$M_i.hi $ 与$ M_{i+1}.div$，就构成了行波$mod2$运算电路(<br><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/image-8.png" alt="alt text"></li>
</ul>
</li>
<li>其实本来看到$mod2$除法运算第一个想到的是循环移位，但是不知道能不能用时序，应该是不行吧</li>
<li>最后的最后，记得$Appearance$，记得$Appearance$，记得$Appearance$，重要的事情说三遍</li>
</ul>
<hr>
<h2 id="P0-Q2-实现GRF"><a href="#P0-Q2-实现GRF" class="headerlink" title="P0.Q2 实现GRF"></a>P0.Q2 实现GRF</h2><ul>
<li><del>啊，是寄存器堆，我们完了</del><br>整体思路不难，输入数据使用32位<code>DMX</code>分配到各个寄存器，读出操作将寄存器堆连接32位<code>MUX</code>得到输出，最后的使能端口我使用了主的使能端$We$和各个寄存器的使能端$We_i$的综合<br><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/image.png" alt="alt text"></li>
<li><font color = red>$Attention$: </font>对于特殊寄存器<code>$0</code>，我没有单独实现为一个寄存器，而是将写入<code>$0</code>的数据线置空，读取<code>$0</code>的数据线恒置为$0$<br>其实主要是搭建大量的寄存器和连接像上图的<code>Tunnel</code>容易导致莫名的连线问题，不过你<del>可以CV</del>，但是既然助教们在logisim教程中写了自动化教程肯定有他们的道理，所以我们用<code>Python</code>自动化脚本帮助我们生成<code>GRF</code>，<del>感觉没我CV快是怎么回事</del></li>
<li>接下来构建<code>Python</code>自动化脚本<ul>
<li><p>首先，既然要使用脚本生成大量的寄存器，我们就需要找到<code>GRF</code>的最小单位，不然怎么愉快的for循环呢，大概是下面这样<br><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/image-2.png" alt="alt text"></p>
</li>
<li><p>但是，我们观察logisim的电路文件，发现连线的操作很麻烦，是从一个坐标点导向另一个坐标点，坐标点嘛，如果写入脚本中，不仅会耗费大量时间记录需要连线的位置而且更易错，这违背了我们<del>图方便、省事</del>的初衷</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">wire</span> <span class="attr">from</span>=<span class="string">&quot;(340,890)&quot;</span> <span class="attr">to</span>=<span class="string">&quot;(430,890)&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">wire</span> <span class="attr">from</span>=<span class="string">&quot;(70,1050)&quot;</span> <span class="attr">to</span>=<span class="string">&quot;(100,1050)&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">wire</span> <span class="attr">from</span>=<span class="string">&quot;(70,1070)&quot;</span> <span class="attr">to</span>=<span class="string">&quot;(100,1070)&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">wire</span> <span class="attr">from</span>=<span class="string">&quot;(70,250)&quot;</span> <span class="attr">to</span>=<span class="string">&quot;(130,250)&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>所以我们对上述电路进行如下改造，丑是丑了点，但是<code>XML</code>格式十分简洁，反正logisim文件不是给人看的，机器看得明白就行<br><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/image-1.png" alt="alt text"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">comp</span> <span class="attr">lib</span>=<span class="string">&quot;4&quot;</span> <span class="attr">loc</span>=<span class="string">&quot;(500,320)&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Register&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;width&quot;</span> <span class="attr">val</span>=<span class="string">&quot;32&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;label&quot;</span> <span class="attr">val</span>=<span class="string">&quot;$18&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">comp</span> <span class="attr">lib</span>=<span class="string">&quot;0&quot;</span> <span class="attr">loc</span>=<span class="string">&quot;(330,340)&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Tunnel&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;label&quot;</span> <span class="attr">val</span>=<span class="string">&quot;clk&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">comp</span> <span class="attr">lib</span>=<span class="string">&quot;0&quot;</span> <span class="attr">loc</span>=<span class="string">&quot;(480,340)&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Tunnel&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;label&quot;</span> <span class="attr">val</span>=<span class="string">&quot;clk&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">comp</span> <span class="attr">lib</span>=<span class="string">&quot;0&quot;</span> <span class="attr">loc</span>=<span class="string">&quot;(320,395)&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Tunnel&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;facing&quot;</span> <span class="attr">val</span>=<span class="string">&quot;east&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;width&quot;</span> <span class="attr">val</span>=<span class="string">&quot;32&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;label&quot;</span> <span class="attr">val</span>=<span class="string">&quot;write_11&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">comp</span> <span class="attr">lib</span>=<span class="string">&quot;0&quot;</span> <span class="attr">loc</span>=<span class="string">&quot;(500,620)&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Tunnel&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;width&quot;</span> <span class="attr">val</span>=<span class="string">&quot;32&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;label&quot;</span> <span class="attr">val</span>=<span class="string">&quot;rd_22&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">comp</span> <span class="attr">lib</span>=<span class="string">&quot;0&quot;</span> <span class="attr">loc</span>=<span class="string">&quot;(180,565)&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Tunnel&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;label&quot;</span> <span class="attr">val</span>=<span class="string">&quot;clk&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">comp</span> <span class="attr">lib</span>=<span class="string">&quot;0&quot;</span> <span class="attr">loc</span>=<span class="string">&quot;(500,395)&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Tunnel&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;width&quot;</span> <span class="attr">val</span>=<span class="string">&quot;32&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;label&quot;</span> <span class="attr">val</span>=<span class="string">&quot;rd_19&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">comp</span> <span class="attr">lib</span>=<span class="string">&quot;0&quot;</span> <span class="attr">loc</span>=<span class="string">&quot;(630,640)&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Tunnel&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;label&quot;</span> <span class="attr">val</span>=<span class="string">&quot;clk&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>因为原电路已经略显复杂，接下来我单开了一个circuit搭建了一个最小单位，然后就能比较方便地找到这个基本单位了，接下来就是使用Python生成xml文件了，我使用的源码如下</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">grf = <span class="string">&quot;&quot;&quot;   &lt;comp lib=&quot;4&quot; loc=&quot;%s&quot; name=&quot;Register&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;a name=&quot;width&quot; val=&quot;32&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;a name=&quot;label&quot; val=&quot;%s&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/comp&gt;</span></span><br><span class="line"><span class="string">    &lt;comp lib=&quot;0&quot; loc=&quot;%s&quot; name=&quot;Tunnel&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;a name=&quot;width&quot; val=&quot;32&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;a name=&quot;label&quot; val=&quot;%s&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/comp&gt;</span></span><br><span class="line"><span class="string">    &lt;comp lib=&quot;0&quot; loc=&quot;%s&quot; name=&quot;Tunnel&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;a name=&quot;facing&quot; val=&quot;east&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;a name=&quot;label&quot; val=&quot;%s&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/comp&gt;</span></span><br><span class="line"><span class="string">    &lt;comp lib=&quot;0&quot; loc=&quot;%s&quot; name=&quot;Tunnel&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;a name=&quot;label&quot; val=&quot;rst&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/comp&gt;</span></span><br><span class="line"><span class="string">    &lt;comp lib=&quot;0&quot; loc=&quot;%s&quot; name=&quot;Tunnel&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;a name=&quot;label&quot; val=&quot;clk&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/comp&gt;</span></span><br><span class="line"><span class="string">    &lt;comp lib=&quot;0&quot; loc=&quot;%s&quot; name=&quot;Tunnel&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;a name=&quot;facing&quot; val=&quot;east&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;a name=&quot;width&quot; val=&quot;32&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;a name=&quot;label&quot; val=&quot;%s&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/comp&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">row = <span class="number">150</span></span><br><span class="line">col = <span class="number">75</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;grf.xml&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">            reg_loc = [<span class="number">200</span> + i * row, <span class="number">170</span> + j * col]</span><br><span class="line">            grf_name = <span class="string">f&quot;$<span class="subst">&#123;i * <span class="number">8</span> + j &#125;</span>&quot;</span></span><br><span class="line">            rd_name = <span class="string">f&quot;rd_<span class="subst">&#123;i * <span class="number">8</span> + j &#125;</span>&quot;</span></span><br><span class="line">            rd_loc = reg_loc</span><br><span class="line">            we_loc = [reg_loc[<span class="number">0</span>] - <span class="number">30</span>, reg_loc[<span class="number">1</span>] + <span class="number">10</span>]</span><br><span class="line">            we_name = <span class="string">f&quot;we_<span class="subst">&#123;i * <span class="number">8</span> + j &#125;</span>&quot;</span></span><br><span class="line">            rst_loc = [reg_loc[<span class="number">0</span>] - <span class="number">10</span>, reg_loc[<span class="number">1</span>] + <span class="number">20</span>]</span><br><span class="line">            clk_loc = [reg_loc[<span class="number">0</span>] - <span class="number">20</span>, reg_loc[<span class="number">1</span>] + <span class="number">20</span>]</span><br><span class="line">            wri_loc = [reg_loc[<span class="number">0</span>] - <span class="number">30</span>, reg_loc[<span class="number">1</span>]]</span><br><span class="line">            wri_name = <span class="string">f&quot;write_<span class="subst">&#123;i * <span class="number">8</span> + j &#125;</span>&quot;</span></span><br><span class="line">            <span class="comment"># print(grf % (tuple(reg_loc), grf_name, tuple(rd_loc), rd_name, tuple(we_loc), we_name,tuple(rst_loc), tuple(clk_loc), tuple(wri_loc), wri_name))</span></span><br><span class="line">            file.write(grf % (<span class="built_in">tuple</span>(reg_loc), grf_name, <span class="built_in">tuple</span>(rd_loc), rd_name, <span class="built_in">tuple</span>(we_loc), we_name,<span class="built_in">tuple</span>(rst_loc), <span class="built_in">tuple</span>(clk_loc), <span class="built_in">tuple</span>(wri_loc), wri_name))</span><br></pre></td></tr></table></figure>
<p><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/image-4.png" alt="alt text"><br>(大概是这样，间距还可以调整，修改代码中的<code>row</code>和<code>col</code>值即可)</p>
<br>
<br></li>
<li><p>对于连接<code>MUX</code>与<code>DMX</code>我们如法炮制，新开一个文件存放最小单位，这里的最小单位其实是就是自己，只是连接的32个<code>Tunnel</code>还是有规律的</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">comp</span> <span class="attr">lib</span>=<span class="string">&quot;2&quot;</span> <span class="attr">loc</span>=<span class="string">&quot;(560,250)&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Demultiplexer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;select&quot;</span> <span class="attr">val</span>=<span class="string">&quot;5&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;width&quot;</span> <span class="attr">val</span>=<span class="string">&quot;32&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;enable&quot;</span> <span class="attr">val</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">comp</span> <span class="attr">lib</span>=<span class="string">&quot;0&quot;</span> <span class="attr">loc</span>=<span class="string">&quot;(520,10)&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Tunnel&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;label&quot;</span> <span class="attr">val</span>=<span class="string">&quot;write_1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">comp</span> <span class="attr">lib</span>=<span class="string">&quot;0&quot;</span> <span class="attr">loc</span>=<span class="string">&quot;(520,20)&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Tunnel&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;label&quot;</span> <span class="attr">val</span>=<span class="string">&quot;write_2&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>发现在$y&#x3D;250$位置的DMX的第一个接口时从0开始的，每两个接口之间是10个单位，就可以使用for循环生成这些<code>Tunnel</code>了，源码如下</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">mux_1 = <span class="string">&quot;&quot;&quot;    </span></span><br><span class="line"><span class="string">    &lt;comp lib=&quot;2&quot; loc=&quot;(250,250)&quot; name=&quot;Multiplexer&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;a name=&quot;select&quot; val=&quot;5&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;a name=&quot;width&quot; val=&quot;32&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;a name=&quot;enable&quot; val=&quot;false&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/comp&gt;&quot;&quot;&quot;</span></span><br><span class="line">mux_2 = <span class="string">&quot;&quot;&quot;     </span></span><br><span class="line"><span class="string">    &lt;comp lib=&quot;2&quot; loc=&quot;(430,250)&quot; name=&quot;Multiplexer&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;a name=&quot;select&quot; val=&quot;5&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;a name=&quot;width&quot; val=&quot;32&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;a name=&quot;enable&quot; val=&quot;false&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/comp&gt;&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">mux_loc = [(<span class="number">250</span>, <span class="number">250</span>), (<span class="number">430</span>, <span class="number">250</span>)]</span><br><span class="line">tunnel_rd = <span class="string">&quot;&quot;&quot;    </span></span><br><span class="line"><span class="string">    &lt;comp lib=&quot;0&quot; loc=&quot;%s&quot; name=&quot;Tunnel&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;a name=&quot;facing&quot; val=&quot;east&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;a name=&quot;width&quot; val=&quot;32&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;a name=&quot;label&quot; val=&quot;%s&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/comp&gt;&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">dmx = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &lt;comp lib=&quot;2&quot; loc=&quot;(560,250)&quot; name=&quot;Demultiplexer&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;a name=&quot;select&quot; val=&quot;5&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;a name=&quot;enable&quot; val=&quot;false&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/comp&gt;&quot;&quot;&quot;</span></span><br><span class="line">dmx_loc = (<span class="number">560</span>, <span class="number">250</span>)</span><br><span class="line"></span><br><span class="line">tunnel_wr = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &lt;comp lib=&quot;0&quot; loc=&quot;%s&quot; name=&quot;Tunnel&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;a name=&quot;label&quot; val=&quot;%s&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/comp&gt;&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;mux.xml&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    <span class="keyword">for</span> z <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">            tun_loc = [mux_loc[z][<span class="number">0</span>] - <span class="number">40</span>, <span class="number">90</span> + <span class="number">10</span> * i]</span><br><span class="line">            tun_name = <span class="string">f&quot;rd_<span class="subst">&#123;i&#125;</span>&quot;</span></span><br><span class="line">            <span class="built_in">print</span>(tunnel_rd % (<span class="built_in">tuple</span>(tun_loc), tun_name))</span><br><span class="line">            file.write(tunnel_rd % (<span class="built_in">tuple</span>(tun_loc), tun_name))</span><br><span class="line">    file.write(mux_1)</span><br><span class="line">    file.write(mux_2)</span><br><span class="line">    file.write(dmx)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">        tun_loc = [dmx_loc[<span class="number">0</span>] + <span class="number">40</span>, <span class="number">90</span> + <span class="number">10</span> * i]</span><br><span class="line">        tun_name = <span class="string">f&quot;we_<span class="subst">&#123;i&#125;</span>&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(tunnel_wr % (<span class="built_in">tuple</span>(tun_loc), tun_name))</span><br><span class="line">        file.write(tunnel_wr % (<span class="built_in">tuple</span>(tun_loc), tun_name))</span><br><span class="line">    <span class="comment"># 这里本来有一个写WD的write的for循环，图方便注释掉了</span></span><br><span class="line">    <span class="comment"># 只需要把tun_name自行调整即可，记得是DMX哦</span></span><br></pre></td></tr></table></figure>
<p><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/image-9.png" alt="alt text"></p>
</li>
</ul>
</li>
<li>这个题目好，P4写单周期的时候还能用</li>
<li><code>GRF</code>，巨能用，一节更比六节强，玩具车用完收音机还能用</li>
<li>最后的最后，记得$Appearance$，记得$Appearance$，记得$Appearance$，重要的事情说三遍(你怎么知道我$Pre$ 被$Appearance$卡到④了)</li>
</ul>
<hr>
<h2 id="P0-Q3-导航"><a href="#P0-Q3-导航" class="headerlink" title="P0.Q3 导航"></a>P0.Q3 导航</h2><ul>
<li><p><del>爵士好题</del></p>
</li>
<li><p>刚开始看到这道题本来打算用<code>Mealy</code>机，使用<code>Mealy</code>机真的很方便，因为<code>hit</code>和<code>arrive</code>都与<code>status</code>、<code>dir</code>有关，但是因为题目指定了<code>Moore</code>机所有很快就丢弃了这个思路</p>
</li>
<li><p>然后想到了创建多个状态包括撞墙的状态，然后写出复杂的状态转移方程，最后一共有13个状态吧，构建状态转移方程过于复杂，所以也丢弃了</p>
</li>
<li><p>最后我还是决定使用<code>Mealy</code>状态机和<code>Register</code>构建一个<code>Moore</code>状态机（假装输出只和状态相关）</p>
<ul>
<li><code>Register</code>保存<code>hit</code>的值，使得<code>hit</code>只在时钟上升沿变化，看起来就像是只随着<code>status</code>变化了（因为<code>status</code>是随着时钟上升沿变化的），而<code>arrive</code>本身就可以只与<code>status</code>有关，那么我们关于<code>status</code>的<code>Moore</code>机就构建好了</li>
</ul>
</li>
<li><p>状态转移的真值表如下</p>
<table>
<thead>
<tr>
<th align="center">status</th>
<th align="center">dir</th>
<th align="center">next_status</th>
<th align="center">arrive</th>
<th align="center">hit</th>
</tr>
</thead>
<tbody><tr>
<td align="center">000</td>
<td align="center">00</td>
<td align="center">001</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">000</td>
<td align="center">01</td>
<td align="center">000</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">000</td>
<td align="center">10</td>
<td align="center">000</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">000</td>
<td align="center">11</td>
<td align="center">000</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">001</td>
<td align="center">00</td>
<td align="center">011</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">001</td>
<td align="center">01</td>
<td align="center">010</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">001</td>
<td align="center">10</td>
<td align="center">000</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">001</td>
<td align="center">11</td>
<td align="center">001</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">010</td>
<td align="center">00</td>
<td align="center">100</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">010</td>
<td align="center">01</td>
<td align="center">010</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">010</td>
<td align="center">10</td>
<td align="center">010</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">010</td>
<td align="center">11</td>
<td align="center">001</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">011</td>
<td align="center">00</td>
<td align="center">011</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">011</td>
<td align="center">01</td>
<td align="center">100</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">011</td>
<td align="center">10</td>
<td align="center">001</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">011</td>
<td align="center">11</td>
<td align="center">011</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">100</td>
<td align="center">??</td>
<td align="center">000</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
</tbody></table>
</li>
<li><p>主电路图大致如下<br><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/image-5.png" alt="alt text"></p>
</li>
<li><p>在群里看到向巨只用了两位的<code>type</code>，我也想了一下，下面是我的思路</p>
<ul>
<li>相较于原本的电路，将状态<code>100</code>即在B机房这个状态去除，改为在<code>S2</code>状态下 <code>dir</code>为<code>01</code>、<code>S3</code>状态下<code>dir</code>为<code>00</code>时，<code>arrive</code>置1，且返回A机房（<code>Mealy</code>状态机 + 寄存器）</li>
<li><code>arrive</code>模块也使用<code>Register</code>保存，在时钟上升沿更新</li>
<li>在A机房状态下，如果<code>arrive</code>为1，则总状态不更新，类似于同步复位信号，不过<code>status</code>这个时候已经是<code>00</code></li>
</ul>
</li>
<li><p>向巨，yyds</p>
</li>
</ul>
<hr>
<h2 id="P0-Q4-正则表达式"><a href="#P0-Q4-正则表达式" class="headerlink" title="P0.Q4 正则表达式"></a>P0.Q4 正则表达式</h2><ul>
<li><p><del>欸，这道题没有$Q3$难欸，怎么放在$Q4$</del><br>好了回归题目，这次的题目是一个<code>Mealy</code>类型的有限状态机，所以千万不要写错成了<code>Moore</code>类型的状态机啊</p>
</li>
<li><p>主要就是<code>Moore</code>状态机会比<code>Mealy</code>状态机多一个状态，因为<code>Moore</code>状态机保存了最后匹配成功的一个状态，<code>Mealy</code>状态机不需要保存匹配成功的状态，只需要在输入最后匹配条件时输出$1$，并且回到非法状态即可</p>
</li>
<li><p><code>Mealy</code>状态机状态转移图<br><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/image-12.png" alt="alt text"></p>
</li>
<li><p><code>Moore</code>状态机状态转移图<br><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/image-10.png" alt="alt text"></p>
</li>
<li><p><code>Mealy</code>状态机状态转移方程</p>
<table>
<thead>
<tr>
<th align="center">status</th>
<th align="center">input</th>
<th align="center">next_status</th>
<th align="center">output</th>
</tr>
</thead>
<tbody><tr>
<td align="center">00</td>
<td align="center">00</td>
<td align="center">00</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">00</td>
<td align="center">01</td>
<td align="center">01</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">00</td>
<td align="center">10</td>
<td align="center">00</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">00</td>
<td align="center">11</td>
<td align="center">00</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">01</td>
<td align="center">00</td>
<td align="center">10</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">01</td>
<td align="center">01</td>
<td align="center">01</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">01</td>
<td align="center">10</td>
<td align="center">10</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">01</td>
<td align="center">11</td>
<td align="center">00</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">00</td>
<td align="center">00</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">01</td>
<td align="center">01</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">10</td>
<td align="center">00</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">11</td>
<td align="center">00</td>
<td align="center">0</td>
</tr>
</tbody></table>
</li>
</ul>
<hr>
<h2 id="P0-附加题-ftoi"><a href="#P0-附加题-ftoi" class="headerlink" title="P0.附加题 ftoi"></a>P0.附加题 ftoi</h2><ul>
<li><p><del>半精度浮点数，所以不能用C语言编测试数据了，助教很坏</del></p>
</li>
<li><p>根据题目改编的IEEE浮点数，我们大致可以分为四类</p>
<ol>
<li>$规格化小数$</li>
<li>$非规格化小数$</li>
<li>$0$</li>
<li>$\infty$</li>
<li>$NAN$</li>
</ol>
</li>
<li><p>浮点数的类型又可以由下面三个bool型变量决定</p>
<ol>
<li><code>exp_iszero</code></li>
<li><code>exp_isfull</code></li>
<li><code>frac_iszero</code></li>
</ol>
</li>
<li><p>$NAN$ 和 $\infty$只有<code>frac_iszero</code>不一致，又因为刚好有5个类型，所以干脆将这两个类型合并为一个，然后使用真值表技术生成两位<code>type</code>关于三个变量的子电路</p>
<table>
<thead>
<tr>
<th align="center">定义接口</th>
<th align="center">方向</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">exp_iszero</td>
<td align="center">I</td>
<td align="center">所得浮点数exponent位置是否全为0</td>
</tr>
<tr>
<td align="center">exp_isfull</td>
<td align="center">I</td>
<td align="center">所得浮点数exponent位置是否全为1</td>
</tr>
<tr>
<td align="center">frac_iszero</td>
<td align="center">I</td>
<td align="center">所得浮点数fraction位置是否全为0</td>
</tr>
<tr>
<td align="center">type[1:0]</td>
<td align="center">O</td>
<td align="center">浮点数属于的类型</td>
</tr>
</tbody></table>
<ul>
<li>状态转移真值表如下<table>
<thead>
<tr>
<th align="center">exp_iszero</th>
<th align="center">exp_isfull</th>
<th align="center">frac_iszero</th>
<th align="center">type</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">00</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">01</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">10</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">?</td>
<td align="center">11</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>后两个类型的输出都是$0$,前两个类型的唯一区别是<code>frac</code>定点数的小数点前是否有默认的$1$，所以先讲述而这在实现上的共性</p>
<ul>
<li>通过<code>exponent</code>的值和<code>bias</code>的值算出真正需要的位移值<code>shift</code>(补码编码)，这里使用加法电路实现减法电路不用考虑溢出，这得益于移码中<code>bias</code>选择(一般是$\lfloor exp_{max} &#x2F;2 \rfloor$)</li>
<li>如果<code>shift</code>是负数，则直接输出$0$即可，因为$0 \lt frac \lt 2$，所以至多右移$1$位就直接为$0$</li>
<li>我通过<code>shift</code>与$10$比较直接决定左移还是右移，好处是不需要考虑先左移<code>shift</code>再右移$10$可能导致的高位$1$损失，坏处是又要写两个减法电路（，然后再<code>MUX</code>选择结果</li>
<li>根据<code>sign</code>符号位决定是否<code>取反加1</code>，同样不需要考虑溢出</li>
</ul>
</li>
<li><p>接下来分别说明两次可以忽略溢出的原因（<del>有点废话的证明</del>）</p>
<ul>
<li>对于第一个算的<code>shift</code>(补码编码)，主要原因是非符号数的减法电路和符号数的减法电路实际是一套电路，而且<code>bias</code>设置的好，如果<code>exponent</code>的首位是0，我们理解为补码的减法电路，正数减去正数不会溢出，得到的答案（补码是正确的），如果<code>exponent</code>的首位是1，因为<code>bias</code>设置的合理，只有<code>11111</code>的情况会无法得到正数，但是这种情况已经被排除了（因为其他的<code>type</code>使用了），所以得到的补码也是正确的（正数的编码是自己）</li>
<li>第二个负数取补码的情况时，为什么不需要考虑可能已经溢出到32位外的值，取完补码再取后32位，而是直接不考虑开始时的溢出，这和一个小结论有关，对于一个正数取其相反数的补码可以这样做：从这个正数最低位的1开始，到最高位为止中间的所有数字取反，假设1全部溢出在32位外，则后32位始终保持0，假设后32位中有1，根据结论无论考不考虑溢出部分后32位的值都应该一致的<br><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/image-6.png" alt="alt text"></li>
</ul>
</li>
</ul>
<hr>
<h2 id="P0-推荐题目"><a href="#P0-推荐题目" class="headerlink" title="P0.推荐题目"></a>P0.推荐题目</h2><p>好，但是现在还没出</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
        <category>课下复习</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>北航计算机组成P1推荐题汇总</title>
    <url>/2024/09/30/CO_P1_extra/</url>
    <content><![CDATA[<h1 id="北航计算机组成P1推荐题目汇总"><a href="#北航计算机组成P1推荐题目汇总" class="headerlink" title="北航计算机组成P1推荐题目汇总"></a>北航计算机组成P1推荐题目汇总</h1><h2 id="题目怎么来的"><a href="#题目怎么来的" class="headerlink" title="题目怎么来的"></a>题目怎么来的</h2><ul>
<li><del>偷来的(搓手手</del></li>
<li>如果你看了一下推荐题目的<code>URL</code>的话，你会发现<code>cscore</code>简直是天生为<del>爬虫而生的</del>，甚至参数都已经写在<code>URL</code>里面了，这不是勾引是什么？<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://cscore.buaa.edu.cn/#/problem?ProblemId=334&amp;PieId=1202</span><br></pre></td></tr></table></figure></li>
<li><code>PieId</code><ul>
<li>似乎是每个P的编号，每年的都不一样，2306的<code>1202</code>代表推荐题目，其他的大都爬不到(悲</li>
</ul>
</li>
<li><code>ProblemId</code><ul>
<li>下辖的题目编号，额，毫无规律可言，建议遍历爬取</li>
<li>但是似乎每年相同模块（例如推荐题目）的相同题目编号都有题目（未经</li>
</ul>
</li>
<li>以及题目按照难度依次上升（笔者认为的，毫无参考价值（bushi ）<br><a href="https://github.com/Kie-Chi/cscore_crawl.git">源码获取</a></li>
</ul>
<hr>
<h2 id="组合电路"><a href="#组合电路" class="headerlink" title="组合电路"></a>组合电路</h2><ul>
<li>过于简单，仅有提示</li>
</ul>
<h3 id="1202-405-FloatType"><a href="#1202-405-FloatType" class="headerlink" title="1202-405 FloatType"></a>1202-405 FloatType</h3><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> FloatType(</span><br><span class="line">    <span class="keyword">input</span>[<span class="number">31</span>: <span class="number">0</span>] num,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span>[<span class="number">4</span>: <span class="number">0</span>] float_type</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义状态</span></span><br><span class="line">    <span class="keyword">parameter</span> zero = <span class="number">5&#x27;b1</span>;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">7</span>: <span class="number">0</span>] exponent;</span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">22</span>: <span class="number">0</span>] fraction;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        exponent = num[<span class="number">30</span>: <span class="number">23</span>];</span><br><span class="line">        fraction = num[<span class="number">22</span>: <span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算次态</span></span><br><span class="line">        <span class="keyword">if</span> (exponent == <span class="number">8&#x27;b0</span> &amp;&amp; fraction == <span class="number">23&#x27;b0</span>) <span class="keyword">begin</span></span><br><span class="line">            float_type = zero;</span><br><span class="line">        ....</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="1202-202-Comparator"><a href="#1202-202-Comparator" class="headerlink" title="1202-202 Comparator"></a>1202-202 Comparator</h3><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">cin = <span class="number">1&#x27;b1</span>;</span><br><span class="line"></span><br><span class="line">cout = (A[<span class="number">0</span>] &amp; ~B[<span class="number">0</span>]) | (cin &amp; (A[<span class="number">0</span>] ^ ~B[<span class="number">0</span>]));</span><br><span class="line">cin = cout;                </span><br><span class="line"></span><br><span class="line">cout = (A[<span class="number">1</span>] &amp; ~B[<span class="number">1</span>]) | (cin &amp; (A[<span class="number">1</span>] ^ ~B[<span class="number">1</span>]));</span><br><span class="line">cin = cout;    </span><br><span class="line"></span><br><span class="line">cout = (A[<span class="number">2</span>] &amp; ~B[<span class="number">2</span>]) | (cin &amp; (A[<span class="number">2</span>] ^ ~B[<span class="number">2</span>]));</span><br><span class="line">cin = cout;    </span><br><span class="line"></span><br><span class="line">S = A[<span class="number">3</span>] ^ ~B[<span class="number">3</span>] ^ cin;</span><br><span class="line">cout = (A[<span class="number">3</span>] &amp; ~B[<span class="number">3</span>]) | (cin &amp; (A[<span class="number">3</span>] ^ ~B[<span class="number">3</span>]));</span><br><span class="line">cin = cout;    </span><br><span class="line"></span><br><span class="line">Out = S;</span><br></pre></td></tr></table></figure>
<ul>
<li>核心就是一个四位的行波全加器，为了实现减法电路</li>
</ul>
<h3 id="1202-424-Voter"><a href="#1202-424-Voter" class="headerlink" title="1202-424 Voter"></a>1202-424 Voter</h3><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> VoterPlus(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> reset,</span><br><span class="line">    <span class="keyword">input</span>[<span class="number">31</span>: <span class="number">0</span>] np,</span><br><span class="line">    <span class="keyword">input</span>[<span class="number">7</span>: <span class="number">0</span>] vip,</span><br><span class="line">    <span class="keyword">input</span> vvip,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span>[<span class="number">7</span>: <span class="number">0</span>] result</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">31</span>: <span class="number">0</span>] np_vote, next_np_vote;</span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">7</span>: <span class="number">0</span>] vip_vote, next_vip_vote;</span><br><span class="line">    <span class="keyword">reg</span> vvip_vote, next_vvip_vote;</span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">7</span>: <span class="number">0</span>] next_result;</span><br><span class="line">    <span class="keyword">integer</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> reset) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (reset) <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">//复位</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">//状态转移</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">//默认复位，注意题意要求</span></span><br><span class="line">        next_np_vote = np_vote | np;</span><br><span class="line">        next_vip_vote = vip_vote | vip;</span><br><span class="line">        next_vvip_vote = vvip_vote | vvip;</span><br><span class="line"></span><br><span class="line">        next_result = <span class="number">8&#x27;b0</span>;</span><br><span class="line">        <span class="comment">//计算次态，使用for循环</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="1202-102-ALU"><a href="#1202-102-ALU" class="headerlink" title="1202-102 ALU"></a>1202-102 ALU</h3><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> alu(</span><br><span class="line">    <span class="keyword">input</span>[<span class="number">31</span>: <span class="number">0</span>] A,</span><br><span class="line">    <span class="keyword">input</span>[<span class="number">31</span>: <span class="number">0</span>] B,</span><br><span class="line">    <span class="keyword">input</span>[<span class="number">2</span>: <span class="number">0</span>] ALUOp,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span>[<span class="number">31</span>: <span class="number">0</span>] C</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义状态</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">32</span>: <span class="number">0</span>] ext_a, ext_b;</span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">32</span>: <span class="number">0</span>] sum;</span><br><span class="line">    <span class="keyword">reg</span> cout;</span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span> (ALUOp)</span><br><span class="line">            sgtu: <span class="keyword">begin</span></span><br><span class="line">                ext_a = &#123;<span class="number">0</span>, A&#125;;</span><br><span class="line">                ext_b = &#123;<span class="number">0</span>, B&#125;;</span><br><span class="line">                ext_a = ~ext_a;</span><br><span class="line">                </span><br><span class="line">                sum = ext_a + ext_b + <span class="number">1</span>;</span><br><span class="line">                C = sum[<span class="number">32</span>];</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            sgt: <span class="keyword">begin</span></span><br><span class="line">                ext_a = &#123;A[<span class="number">31</span>], A&#125;;</span><br><span class="line">                ext_b = &#123;B[<span class="number">31</span>], B&#125;;</span><br><span class="line">                ext_a = ~ext_a;</span><br><span class="line">                sum = ext_a + ext_b + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                C = sum[<span class="number">32</span>];</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">                C = <span class="number">32&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li>注意使用拓展位的减法电路实现比较即可</li>
</ul>
<hr>
<h2 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h2><h3 id="1202-334-Drink"><a href="#1202-334-Drink" class="headerlink" title="1202-334 Drink"></a>1202-334 Drink</h3><ul>
<li><del>为什么我航的售卖机没有一键退币功能，大一被坑了多少饮料</del></li>
<li>本题似乎是一个<code>Moore</code>型优先状态机的问题，但是我决定使用我的新结构，所以我们使用<code>Mealy</code>机＋<code>Register</code>的方式解决输出不与状态同步的问题</li>
<li>四个状态还是很好想的，<code>售货机没吞钱</code> <code>售货机吞0.5元</code> <code>售货机吞1元</code> <code>售货机吞1.5元</code>，然后就是状态转移方程了<br><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/p1_drink.png" alt="alt-text"></li>
<li>提供一个我使用的新结构框架（<del>应该没有泄露源码之嫌</del>）<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> drink(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> reset,</span><br><span class="line">    <span class="keyword">input</span>[<span class="number">1</span>: <span class="number">0</span>] coin,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> drink,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span>[<span class="number">1</span>: <span class="number">0</span>] back</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义状态</span></span><br><span class="line">    <span class="keyword">parameter</span> s0 = <span class="number">2&#x27;b0</span>;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义寄存器变量</span></span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">1</span>: <span class="number">0</span>] state, next_state; </span><br><span class="line">    <span class="keyword">reg</span> next_drink;</span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">1</span>: <span class="number">0</span>] next_back;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> reset) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (reset) <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">//复位</span></span><br><span class="line">            ......</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">//状态转移</span></span><br><span class="line">            state &lt;= next_state;</span><br><span class="line">            back &lt;= next_back;</span><br><span class="line">            drink &lt;= next_drink;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">//默认赋值</span></span><br><span class="line">        next_back = <span class="number">2&#x27;b0</span>;</span><br><span class="line">        next_drink = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        next_state = state;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> (state)</span><br><span class="line">            s0: <span class="keyword">begin</span></span><br><span class="line">                <span class="comment">//状态转移</span></span><br><span class="line">                ......</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">                <span class="comment">//......</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1202-145-String"><a href="#1202-145-String" class="headerlink" title="1202-145 String"></a>1202-145 String</h3><ul>
<li>其实本质是课下题的升级版，对于左括号进行记录即可</li>
<li>多重括号的辨别使用一个变量寄存左括号数量即可<ul>
<li>string状态没有分开，看起来有一点乱<br><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/P1_string2.png" alt="状态转移图"></li>
<li>将带有左括号未匹配时单独分出状态，这样大概不会显得乱吧<br><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/P1_string.png" alt="wty赞助"></li>
</ul>
</li>
</ul>
<h3 id="1202-336-IntCheck"><a href="#1202-336-IntCheck" class="headerlink" title="1202-336 IntCheck"></a>1202-336 IntCheck</h3><ul>
<li>第一，读到<code>;</code>语句才截止，所以要考虑每个状态遇到<code>;</code>的情况</li>
<li>第二，多个标识符可以复用状态，详情请看下面状态转移图</li>
<li>第三，不要在小情侣后面码代码<br><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/P1_int.svg" alt="复杂图"><a class="btn-beautify " href="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/P1_int.svg" 
  title="查看原图"><span>查看原图</span></a></li>
</ul>
]]></content>
      <categories>
        <category>计算机组成原理</category>
        <category>推荐题目</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>北航计算机组成P2推荐题汇总</title>
    <url>/2024/10/09/CO_P2_extra/</url>
    <content><![CDATA[<h1 id="北航计算机组成P2推荐题目汇总"><a href="#北航计算机组成P2推荐题目汇总" class="headerlink" title="北航计算机组成P2推荐题目汇总"></a>北航计算机组成P2推荐题目汇总</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>题目怎么来的就不再赘述，有感兴趣的同学可以走这里 <a href="/2024/09/30/CO_P1_extra/" title="北航计算机组成P1推荐题汇总">北航计算机组成P1推荐题汇总</a></li>
</ul>
<h2 id="P2推荐题目汇总"><a href="#P2推荐题目汇总" class="headerlink" title="P2推荐题目汇总"></a>P2推荐题目汇总</h2><h3 id="1202-35-calculate"><a href="#1202-35-calculate" class="headerlink" title="1202-35 calculate"></a>1202-35 calculate</h3><ul>
<li>注意题目要求的是按照<strong>输入的顺序</strong>输出计数的字符，不是按照<code>ascii</code>码表的位置</li>
<li>我开了两个数组一个记录26个字母的数量，一个记录出现的顺序(<strong>重复出现的字母不会进行第二遍</strong>)，最后遍历记录出现顺序的数组即可</li>
<li>还有一个小小的点：因为样例看起来是一行读入一个字符，实际测评机是一个接一个的字符读入，所以不需要处理<code>\n</code>(我刚开始就处理了，导致报了一个非法读入的错误)  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.macro read_chr(%chr)</span><br><span class="line">    li $v0, 12</span><br><span class="line">    syscall</span><br><span class="line">    move %chr, $v0</span><br><span class="line"></span><br><span class="line">    # 不需要处理字母后面的\n</span><br><span class="line">    # li $v0, 12</span><br><span class="line">    # syscall</span><br><span class="line">.end_macro</span><br></pre></td></tr></table></figure></li>
<li>提供一个有处理是否有重复输入的代码块<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> .text</span><br><span class="line">	for_z_begin: # 用于判断是否出现过这个字符</span><br><span class="line">		beq $t2, $s1, for_z_end # 对目前出现的所有字符遍历 </span><br><span class="line">		sll $t3, $t2, 2 </span><br><span class="line">		lw $t4, buffer($t3) # 读出第$t2个已有字符</span><br><span class="line">		sub $t4, $t4, $t1 # 判断是否为同一个字符</span><br><span class="line">		if_begin_1:</span><br><span class="line">			bne $t4, $zero, if_end_1 # 如果不是则跳转</span><br><span class="line">			j not_for_z_end # 如果是则直接结束这段内容</span><br><span class="line">		if_end_1:</span><br><span class="line">		addi $t2, $t2, 1</span><br><span class="line">		j for_z_begin</span><br><span class="line">	for_z_end:</span><br><span class="line">		sll $t3, $t2, 2 # 存入新读入的字符</span><br><span class="line">		sw $t1, buffer($t3)</span><br><span class="line">		addi $s1, $s1, 1</span><br><span class="line">	not_for_z_end:</span><br><span class="line">	</span><br><span class="line">	sll $t1, $t1, 2 # 找到指定字母的偏移字节</span><br><span class="line">	</span><br><span class="line">	lw $t2, num($t1)</span><br><span class="line">	addi $t2, $t2, 1 # 找到的字母加1</span><br><span class="line">	sw $t2, num($t1)</span><br><span class="line">	</span><br><span class="line">	addi $t0, $t0, 1 # 循环继续条件</span><br><span class="line">	j for_i_begin</span><br><span class="line">for_i_end:</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1202-52-add"><a href="#1202-52-add" class="headerlink" title="1202-52 add"></a>1202-52 add</h3><ul>
<li>看上去有点麻烦而已，其实完全可以使用一个矩阵接收两次数字完成两次加法(因为所有内存起始值赋值为0)</li>
<li>最后的转置也只是需要将原来的嵌套<code>for</code>循环中的<strong>先<code>row</code>后<code>col</code></strong> 改为 **先<code>col</code>后<code>row</code>**就可以了</li>
<li>同样提供一个有大致思路的<code>main</code>模块<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> .text</span><br><span class="line">read_in($s0) # 读入n</span><br><span class="line">read_in($s1) # 读入m</span><br><span class="line"></span><br><span class="line">li $s2, 2 # 直接设置读入两次</span><br><span class="line">li $t0, 0 # 设置循环变量i</span><br><span class="line"># 双重for循环读入</span><br><span class="line"></span><br><span class="line">print_str(hint) # 打印题目要求的hint信息</span><br><span class="line"># 双重for循环打印</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1202-53-full-reserved"><a href="#1202-53-full-reserved" class="headerlink" title="1202-53 full_reserved"></a>1202-53 full_reserved</h3><ul>
<li>对于全排列问题(顺序)，可以考虑下面的思路(只想看汇编内容可以跳过，这里主要讲的是全排列是如何写的)<ul>
<li>我们以<code>1234</code>四个数字举例，开头为<code>1</code>和<code>2</code>的情况</li>
<li><code>1</code>:<code>1234 1243 1324 1342 1423 1432</code></li>
<li><code>2</code>:<code>2134 2143 2314 2341 2413 2431</code></li>
<li>可以发现，以某个数字开头的全排列其实是 以<strong>这个数字开头</strong>加上<strong>剩下所有数字按相对大小重新构成的数字队列</strong>的全排列 </li>
<li>例如<code>1</code>与<code>234</code>的全排列构成<code>1234</code>以<code>1</code>开头的全排列;<code>2</code>与<code>134</code>的全排列构成了<code>1234</code>以<code>2</code>开头的全排列，所以就可以写递归程序了(雾)</li>
<li>所以所给递归程序的<code>symbol</code>全局数组是用来记录这个<strong>开头的数字</strong></li>
</ul>
</li>
<li>题目要求你改写<strong>逆序</strong>的全排列汇编程序<ul>
<li>最方便的思路就是打印的时候不打印<code>array[i]</code>而打印<code>n+1-array[i]</code>这样相当于用<code>n....1</code>来全排列</li>
<li>当然，如果你理解了这个C语言程序如何运作的，可以将<code>for</code>循环的顺序反过来，从最高位<code>n</code>来开始，思路同上面的讲解思路</li>
</ul>
</li>
<li>仔细考虑入栈出栈情况，如果使用栈传递参数记得开始时就要先出栈，<code>$ra</code>的保留值在任何一个程序的返回点都要弹出，总之<strong>入栈则一定要出栈</strong>(虽然有点像废话，但某些地方真的必须考虑清楚)，切记</li>
<li>给出一个可以参考的<code>FullArray</code>函数的模板<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">full_array:</span><br><span class="line">    addi $sp, $sp, -8 # 给出一定的栈空间</span><br><span class="line">    sw $a0, 4($sp) # 压栈</span><br><span class="line">    sw $ra 0($sp) </span><br><span class="line">    move $t0, $a0 # t0代表index</span><br><span class="line">    if_begin:</span><br><span class="line">        sltu $t2, $t0, $s0 # 判断index与n的大小</span><br><span class="line">        bne $t2, $zero, if_end</span><br><span class="line">        </span><br><span class="line">        li $t1, 0 # 设置循环变量i</span><br><span class="line">        for_i_begin:</span><br><span class="line">            beq $t1, $s0, for_i_end </span><br><span class="line">            sll $t2, $t1, 2 </span><br><span class="line">            lw $t3, array($t2) # 得到array[i]</span><br><span class="line">            sub $t3, $zero, $t3</span><br><span class="line">            addi $t4, $s0, 1</span><br><span class="line">            add $t3, $t3, $t4 # 得到n+1-array[i]</span><br><span class="line">            print_int($t3) # 打印这个值</span><br><span class="line">            print_str(space) # 打印空格</span><br><span class="line">            addi $t1, $t1, 1 # 循环i继续条件</span><br><span class="line">            j for_i_begin</span><br><span class="line">        for_i_end:</span><br><span class="line">        print_str(enter) # 打印换行</span><br><span class="line">        add $sp, $sp ,8 # 注意出栈，这里可以不用弹出值，但是一定要栈空间减少</span><br><span class="line">        jr $ra # 返回</span><br><span class="line">    if_end:</span><br><span class="line">        </span><br><span class="line">    # else执行的for循环递归</span><br><span class="line">    addi $sp, $sp, 8 # 将刚开始保留的参数弹出</span><br><span class="line">    lw $a0, -4($sp)</span><br><span class="line">    lw $ra -8($sp)	</span><br><span class="line">    </span><br><span class="line">    jr $ra # 返回</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1202-329-sum"><a href="#1202-329-sum" class="headerlink" title="1202-329 sum"></a>1202-329 sum</h3><ul>
<li>大概就是一个变量保留 $n!$ 的值，一个变量保留 $\sum\limits_{i&#x3D;1}^n i!$，然后进行递推就可以了，千万不要递归啊(雾，大概率会爆吧</li>
<li>提供一个可参考的<code>main</code>模板<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main:</span><br><span class="line">    read($s0)</span><br><span class="line">    li $s1, 0</span><br><span class="line">    li $s2, 1</span><br><span class="line">    li $t0, 1</span><br><span class="line">    li $s3, 1</span><br><span class="line">    for_start:</span><br><span class="line">        sltu $s3, $s0, $t0</span><br><span class="line">        bne $s3, $zero, for_end</span><br><span class="line">        multu $t0, $s2</span><br><span class="line">        mflo $s2</span><br><span class="line">        addu $s1, $s1, $s2</span><br><span class="line">        addi $t0, $t0, 1</span><br><span class="line">        j for_start</span><br><span class="line">    for_end:</span><br><span class="line">        printU($s1)</span><br><span class="line">        done</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1202-330-hanoi"><a href="#1202-330-hanoi" class="headerlink" title="1202-330 hanoi"></a>1202-330 hanoi</h3><ul>
<li>诶呀，<del>是大一写的递归程序呢</del></li>
<li>不论是C语言代码的理解和整体程序都没有难点，所以注意的只有压栈弹栈时候小心即可！</li>
<li>因为函数参数过多，所以我采用了用栈传输参数的思路，所以要更加小心，哪些部分是保存参数、弹出参数，哪些部分是传递参数、接收参数</li>
<li>本题给出了关于模板字符串的提示，虽然没法用占位符<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">format_str: .asciiz &quot;move disk D from C to C\n&quot;</span><br><span class="line">.macro print(%disk, %from, %to)</span><br><span class="line">    li $t7, 10</span><br><span class="line">    addi $t6, %disk, 48</span><br><span class="line">    sb $t6, format_str($t7)</span><br><span class="line">    </span><br><span class="line">    li $t7, 17</span><br><span class="line">    sb %from, format_str($t7)</span><br><span class="line">    </span><br><span class="line">    li $t7, 22</span><br><span class="line">    sb %to, format_str($t7)</span><br><span class="line">    </span><br><span class="line">    la $a0, format_str</span><br><span class="line">    li $v0, 4</span><br><span class="line">    syscall</span><br><span class="line">.end_macro</span><br></pre></td></tr></table></figure></li>
<li>同样，给出参考的模板<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main:</span><br><span class="line">    read_in($t0) # 读入n</span><br><span class="line">    li $t1, 65</span><br><span class="line">    li $t2, 66</span><br><span class="line">    li $t3, 67</span><br><span class="line">    la $sp, stack</span><br><span class="line">    addi $sp, $sp, 800 # 初始化参数与stack</span><br><span class="line">    </span><br><span class="line">    push($t0) # 传参数</span><br><span class="line">    ...</span><br><span class="line">    jal hanoi</span><br><span class="line">    </span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">hanoi:</span><br><span class="line">    pop($t3) # 接收参数</span><br><span class="line">    ...</span><br><span class="line">    push($ra) # 保存返回值</span><br><span class="line">    if_begin:</span><br><span class="line">        bne $t0, $zero, if_end</span><br><span class="line">        print($t0, $t1, $t2)</span><br><span class="line">        print($t0, $t2, $t3)</span><br><span class="line">        pop($ra) # 弹返回地址</span><br><span class="line">        jr $ra</span><br><span class="line">    if_end:</span><br><span class="line">    </span><br><span class="line">    push($t0) # 保存参数</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    addi $t0, $t0, -1</span><br><span class="line">    push($t0) # 传递参数</span><br><span class="line">    ...</span><br><span class="line">    jal hanoi</span><br><span class="line">    </span><br><span class="line">    pop($t3) # 取出保留的参数</span><br><span class="line">    ...</span><br><span class="line">    print($t0, $t1, $t2)</span><br><span class="line">    </span><br><span class="line">    ...若干递归</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1202-415-bsearch"><a href="#1202-415-bsearch" class="headerlink" title="1202-415 bsearch"></a>1202-415 bsearch</h3><ul>
<li>二分查找！！！</li>
<li>因为已经给出了C语言参考模板了，没有的话或许有同学会因为不清楚<code>[low,high]</code>还是<code>[low,high)</code>两种查找方式的区别，而写出一些小bug</li>
<li>注意<code>slt</code>与<code>sltu</code>因为如果查找的<code>key</code>比数组中最小的值还要小的话，那么最后得到的值是-1，但是-1在无符号数中是最大的，会出现死循环哦</li>
<li>直接给出可参考的模板了<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">binary_search:</span><br><span class="line">    push($s1)</span><br><span class="line">    move $s1, $a0 # key</span><br><span class="line">    li $t0, 0 # low</span><br><span class="line">    addi $t1, $s0, -1 # high</span><br><span class="line">    li $t2, 0 # mid</span><br><span class="line">    </span><br><span class="line">    while_begin:</span><br><span class="line">        slt $t5, $t1, $t0</span><br><span class="line">        bne $t5, $zero, while_end</span><br><span class="line">        </span><br><span class="line">        add $t2, $t0, $t1</span><br><span class="line">        srl $t2, $t2, 1</span><br><span class="line">        </span><br><span class="line">        //判断arr[mid]与key的大小</span><br><span class="line">        j while_begin</span><br><span class="line">    while_end:</span><br><span class="line"></span><br><span class="line">    li $t5, 0</span><br><span class="line">    print($t5)</span><br><span class="line">    pop($s1)</span><br><span class="line">    jr $ra</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1202-416-flower"><a href="#1202-416-flower" class="headerlink" title="1202-416 flower"></a>1202-416 flower</h3><ul>
<li>简单汇编，直接给出可参考的模板<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main:</span><br><span class="line">    read_in($t0) # 读入m</span><br><span class="line">    read_in($s0) # 读入n</span><br><span class="line">    </span><br><span class="line">    for_i_begin:</span><br><span class="line">        beq $t0, $s0, for_i_end</span><br><span class="line">        divu $t1, $t0, 100</span><br><span class="line">        </span><br><span class="line">        mul $t2, $t1, 100</span><br><span class="line">        sub $t4, $t0, $t2</span><br><span class="line">        divu $t2, $t4, 10</span><br><span class="line">        </span><br><span class="line">        mul $t3, $t2, 10</span><br><span class="line">        sub $t3, $t4, $t3</span><br><span class="line">        </span><br><span class="line">        mul $t4, $t1, $t1</span><br><span class="line">        mul $t4, $t4, $t1</span><br><span class="line">        </span><br><span class="line">        mul $t5, $t2, $t2</span><br><span class="line">        mul $t5, $t5, $t2</span><br><span class="line">        add $t4, $t4, $t5</span><br><span class="line">        </span><br><span class="line">        mul $t5, $t3, $t3</span><br><span class="line">        mul $t5, $t5, $t3</span><br><span class="line">        add $t4, $t4, $t5</span><br><span class="line">        </span><br><span class="line">        if_begin:</span><br><span class="line">            bne $t4, $t0, if_end</span><br><span class="line">            print($t0)</span><br><span class="line">        if_end:</span><br><span class="line">        add $t0, $t0, 1</span><br><span class="line">        j for_i_begin</span><br><span class="line">    for_i_end:</span><br><span class="line">    end</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1202-419-josef"><a href="#1202-419-josef" class="headerlink" title="1202-419 josef"></a>1202-419 josef</h3><ul>
<li>也是一道大一写的题目呢，<del>小海豚</del></li>
<li>其实刚开始我想如果暴力数组没过的话就用循环链表了(没想都暴力可以直接过)</li>
<li>这里主要通过一个数组记录某个编号是否已经被删除了</li>
<li>计数就是数组下标加一，遇到等于数组长度时自动返回0</li>
<li>给出一个可以参考的模板<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read($s0) # 读入人数n</span><br><span class="line">read($s1) # 读入报数m</span><br><span class="line"></span><br><span class="line">li $t0, 0 # 报数的人的编号</span><br><span class="line">li $t1, 0 # 外层循环变量i,将所有人都出局为止</span><br><span class="line">li $t2, 1 # 设置第一次数数</span><br><span class="line">for_start_i:</span><br><span class="line">    beq $t1, $s0, for_end_i # 达到最大人数结束循环</span><br><span class="line">    for_start_j:</span><br><span class="line">        beq $t2, $s1, for_end_j # 达到报数最大值</span><br><span class="line">        </span><br><span class="line">        //使用while循环处理报数，去除已经out的人</span><br><span class="line">    for_end_j:</span><br><span class="line">        sll $t4, $t0, 2</span><br><span class="line">        li $t5, 1</span><br><span class="line">        sw $t5, people($t4) # 记录出局的人，置1</span><br><span class="line">        addi $t5, $t0, 1 # 打印出局的人的编号</span><br><span class="line">        print($t5)</span><br><span class="line">        li $t2, 0 # 设置每次j的</span><br><span class="line">        addi $t1, $t1, 1 # 循环继续条件</span><br><span class="line">        j for_start_i</span><br><span class="line">for_end_i:</span><br><span class="line">    done</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>计算机组成原理</category>
        <category>推荐题目</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>北航计算机组成P1课下</title>
    <url>/2024/09/28/CO_P1/</url>
    <content><![CDATA[<h1 id="北航计算机组成原理P1课下"><a href="#北航计算机组成原理P1课下" class="headerlink" title="北航计算机组成原理P1课下"></a>北航计算机组成原理P1课下</h1><div class="note info simple"><p>通过阅读本文，你可以大致了解北京航空航天大学2023级计算机组成原理P1课下的相关内容，希望能对你有所帮助</p>
</div>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li><del>发现教程有了，不愧是STAR</del></li>
<li>在阅读本次P1题解分享之前，我想单独分享一些关于<code>Verilog</code>编写有限状态机的内容(佬跳过，好吗？好的)</li>
<li>从学习完<code>Verilog</code>到<code>Pre</code>上机之间的很长一段时间，我写<code>Verilog</code>有限状态机都只有一个过程块（<del>可能大概应该有和我一样的同学吧</del>），就像下面这样<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">define</span> S0 2&#x27;b00</span></span><br><span class="line">......</span><br><span class="line"><span class="keyword">module</span> xxx (</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    ......</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        `S0: <span class="keyword">begin</span>:</span><br><span class="line">            <span class="comment">//状态转移代码</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">//消除锁存器</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在写一些简单的<code>Verilog</code>有限状态机的时候觉得结构简单清晰易懂，怎么写这么舒服，感觉脑子都闲置了下来（bushi，但是遇到像<code>cpu_checker_challenge</code>那样状态多且转移方程复杂的题目，就会显得单一过程块冗长且十分不易<code>debug</code>，几百行代码挤在一个<code>always</code>块中，总感觉像写C语言只写一个<code>main</code>函数</li>
</ul>
</li>
</ul>
<hr>
<h3 id="重构Verilog结构"><a href="#重构Verilog结构" class="headerlink" title="重构Verilog结构"></a>重构<code>Verilog</code>结构</h3><ul>
<li>直到我遇见了<code>HDLbits</code>，它向我提供了一种使用<code>Verilog</code>搭建和<code>logisim</code>结构很相似的有限状态机的代码机构，感觉会比一个<code>always</code>块清晰一些？</li>
<li>首先，解决最大的问题，把<code>always</code>块拆分出来，像<code>logisim</code>一样，我们将代码分出计算次态的状态转移逻辑使用纯组合电路代替  <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span>[<span class="number">1</span>: <span class="number">0</span>] state, next_state;</span><br><span class="line"></span><br><span class="line"><span class="comment">//时钟沿上升，状态转移</span></span><br><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (reset) <span class="keyword">begin</span></span><br><span class="line">        state &lt;= <span class="number">2&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        state &lt;= next_state;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//计算次态next_state</span></span><br><span class="line"><span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span>(state)</span><br><span class="line">        `S0: <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">//状态转移</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//输出逻辑方案1</span></span><br><span class="line"><span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">    out = ......</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//输出逻辑方案2</span></span><br><span class="line"><span class="keyword">assign</span> out = ......</span><br></pre></td></tr></table></figure>
<ul>
<li>诶呀，瞬间感觉代码变得清爽了，结构更加清晰了有没有（<del>没有也不许说</del>）</li>
</ul>
</li>
<li>也许此时你觉得这样不过只是拆了几个<code>always</code>出来，没什么技术含量，那么接下来我们还可以利用新的结构做出一些原本结构做不出来的优化–<strong>简化代码逻辑</strong>与<strong>消除锁存器plus</strong><ul>
<li>你是否常常遇到这种情况，某个变量多个状态下的变化是一致的，只有极少部分的值改变的不一致<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span>(status)</span><br><span class="line">        `S0: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span> (in == a) <span class="keyword">begin</span></span><br><span class="line">                count &lt;= <span class="number">1</span>;</span><br><span class="line">                .......</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (in == b) <span class="keyword">begin</span></span><br><span class="line">                count &lt;= <span class="number">0</span>;</span><br><span class="line">                .......</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (in == c) <span class="keyword">begin</span></span><br><span class="line">                count &lt;= <span class="number">0</span>;</span><br><span class="line">                .......</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (in == d) <span class="keyword">begin</span></span><br><span class="line">                count &lt;= <span class="number">0</span>;</span><br><span class="line">                .......</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                count &lt;= <span class="number">0</span>;</span><br><span class="line">                .......</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        ......</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
上面只展示一个状态下<code>count</code>变量的转移，如果你有10个状态呢（<del>你真的敢像<code>logisim</code>一样CV吗</del>），但是如果我们使用新结构就可以在<code>always</code>块开始时默认赋值了，节省代码<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    count &lt;= next_count;</span><br><span class="line">    status &lt;= next_status;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">//默认赋值区域</span></span><br><span class="line">    next_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span>(status)</span><br><span class="line">        `S0: <span class="keyword">begin</span>:</span><br><span class="line">            <span class="keyword">if</span> (in == a) <span class="keyword">begin</span></span><br><span class="line">                next_count = <span class="number">1</span>;   </span><br><span class="line">            .......</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (in == b) <span class="keyword">begin</span></span><br><span class="line">                .......</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (in == c) <span class="keyword">begin</span></span><br><span class="line">                .......</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (in == d) <span class="keyword">begin</span></span><br><span class="line">                .......</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                .......</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
这得益于我们使用组合逻辑的always块不是非阻塞赋值，可以多次赋值，所以不用像之前一样每个情况都要重复</li>
<li>同样，通过预先赋初值的办法我们就可以彻底消除锁存器这个bug了，因为锁存器产生原因就是我们没有明确赋值导致<code>Verilog</code>推导出锁存器记录之前的状态（<code>Verilog</code>帮我们默认赋值）<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (in == a) <span class="keyword">begin</span></span><br><span class="line">        count &lt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span> <span class="comment">//缺少else分支</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (in == a) <span class="keyword">begin</span></span><br><span class="line">        count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
新结构的代码没有锁存器问题，但是<font color = red>不要故意不写else，重申，我们只是抑制锁存器plus</font></li>
</ul>
</li>
</ul>
<hr>
<h3 id="TestBench输入编写"><a href="#TestBench输入编写" class="headerlink" title="TestBench输入编写"></a>TestBench输入编写</h3><ul>
<li>我在看学长的博客之前，例如暑假学co_pre的时候我一直是使用CV编写<code>tb</code>文件的。。。效率还是稍微太低了点，后来需要的测试数据加多了之后我也使用过<code>python</code>脚本帮我自动化生成<code>tb</code>文件，但是我还是不喜欢，效率还是太低了</li>
<li>于是乎，我开始寻找直接在verilog中简单编写<code>tb</code>的方案，<a href="https://flyinglandlord.github.io/2021/10/24/BUAA-CO-2021/P1/P1%E8%AF%BE%E4%B8%8B%E5%AD%A6%E4%B9%A0/">这位20级的学长</a>提供了一个使用<code>while</code>循环的简单思路</li>
<li>首先我们知道<code>Verilog</code>是允许给整个寄存器赋值一个字符串的<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span>[<span class="number">1023</span>: <span class="number">0</span>] data;</span><br><span class="line"><span class="keyword">reg</span>[<span class="number">0</span>: <span class="number">1023</span>] test_data;</span><br><span class="line">data = <span class="string">&quot;begin endBeGin this is a great End Begin end&quot;</span>;</span><br><span class="line">test_data = <span class="string">&quot;begin endBgein&quot;</span>;</span><br><span class="line"><span class="comment">// data[1023: 0](radix: ascii) ______________begin endBeGin this is a great End Begin end</span></span><br><span class="line"><span class="comment">// test_data[0: 1023](radix: ascii) _____________________begin endBegin</span></span><br></pre></td></tr></table></figure></li>
<li>这样字符串会按照一个字符8个bit填入data数组中，将字符串从尾部开始依次填入data尾部索引，所以我们可以通过循环取值的方式获得每一个字符<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="keyword">reg</span>[<span class="number">0</span>: <span class="number">1023</span>] data;</span><br><span class="line"><span class="keyword">reg</span>[<span class="number">1023</span>: <span class="number">0</span>] test_data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">	<span class="comment">// Initialize Inputs</span></span><br><span class="line">	in = <span class="number">0</span>;</span><br><span class="line">	data = <span class="string">&quot;begin yes or no this is a question&quot;</span>;</span><br><span class="line">	test_data = <span class="string">&quot;begin yes or no this is a question&quot;</span>;</span><br><span class="line">	<span class="comment">// Wait 100 ns for global reset to finish</span></span><br><span class="line">	#<span class="number">100</span>;</span><br><span class="line">       <span class="keyword">while</span>(!data[<span class="number">0</span>: <span class="number">7</span>]) data = data &lt;&lt; <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(data[<span class="number">0</span>: <span class="number">7</span>]) <span class="keyword">begin</span></span><br><span class="line">		in[<span class="number">7</span>: <span class="number">0</span>] = data[<span class="number">0</span>: <span class="number">7</span>];</span><br><span class="line">		data = data &lt;&lt; <span class="number">8</span>;</span><br><span class="line">		#<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line">	in = <span class="number">0</span>;</span><br><span class="line">	#<span class="number">100</span>;</span><br><span class="line">	<span class="keyword">while</span>(test_data[<span class="number">7</span>: <span class="number">0</span>]) <span class="keyword">begin</span></span><br><span class="line">		in = test_data[<span class="number">7</span>: <span class="number">0</span>];</span><br><span class="line">		test_data = test_data &gt;&gt; <span class="number">8</span>;</span><br><span class="line">		#<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">end</span> </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="P1-Q5-表达式状态机"><a href="#P1-Q5-表达式状态机" class="headerlink" title="P1.Q5 表达式状态机"></a>P1.Q5 表达式状态机</h2><ul>
<li>大抵是一道很显然的<code>Moore</code>状态机，只需要判断<code>需要运算符</code>和<code>需要数字</code>两种状态即可，大致的思路如下<br><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/P1_Q5.png" alt="状态转移图"></li>
<li>等等，这里的<code>*</code>和正则里面的不是一个啊，这里的是<code>\*</code>，笔者忘改了</li>
<li>写起来也是顺手啊</li>
<li>提供一个进阶题(<a href="/2024/09/30/CO_P1_extra/" title="北航计算机组成P1推荐题汇总">北航计算机组成P1推荐题汇总</a>)，移步1202-145，加入匹配括号，甚至是多重嵌套括号，思路其实是一致的</li>
</ul>
<hr>
<h2 id="P1-extra-BlockChecker"><a href="#P1-extra-BlockChecker" class="headerlink" title="P1.extra BlockChecker"></a>P1.extra BlockChecker</h2><ul>
<li>一道好题，<del>但不至于卡我一天吧</del>(<code>&amp;&amp;</code>别再写成<code>||</code>了</li>
<li>因为我第一个思路因为某些莫名的原因一直没过(手真贱，所以我就换了一个思路，那么我提供两个思路思考</li>
</ul>
<h3 id="思路一-多个寄存器"><a href="#思路一-多个寄存器" class="headerlink" title="思路一 多个寄存器"></a>思路一 多个寄存器</h3><ul>
<li><p><del>好处是状态少，坏处是容易手误</del></p>
</li>
<li><p>状态设置思路</p>
<ul>
<li>首先设置了四个状态<code>start</code>、<code>word</code>、<code>illegal</code>分别表示空闲状态、匹配单词状态、匹配已经非法状态</li>
</ul>
</li>
<li><p>寄存器变量设置思路</p>
<table>
<thead>
<tr>
<th align="center">寄存器变量</th>
<th align="center">位宽</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">num</td>
<td align="center">32</td>
<td align="center">保存读入的单词长度(unsigned)</td>
</tr>
<tr>
<td align="center">flag</td>
<td align="center">33</td>
<td align="center">保存目前未匹配的begin数量(signed)</td>
</tr>
<tr>
<td align="center">has_begin</td>
<td align="center">1</td>
<td align="center">前一个周期是否已经匹配begin成功</td>
</tr>
<tr>
<td align="center">has_end</td>
<td align="center">1</td>
<td align="center">前一个周期是否已经匹配end成功</td>
</tr>
<tr>
<td align="center">first</td>
<td align="center">8</td>
<td align="center">最近五个周期内第1个周期的字符</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">8</td>
<td align="center">最近五个周期内第i个周期的字符</td>
</tr>
<tr>
<td align="center">fifth</td>
<td align="center">8</td>
<td align="center">这个周期读入的in，即最近五个周期内第5个周期的字符</td>
</tr>
</tbody></table>
</li>
<li><p>状态转移思路</p>
<ul>
<li><code>start</code>状态<ul>
<li><code>reset</code>生效后回到<code>start</code>状态</li>
<li>匹配到字母则<code>num</code>自增，且进入状态<code>word</code></li>
<li>匹配到空格保持原状态</li>
<li>若匹配到其他的进入<code>illegal</code>状态</li>
</ul>
</li>
<li><code>word</code>状态<ul>
<li>读入字母，<code>num</code>自增，如果在包括此次<code>in</code>输入共有五个字符时，且<code>first</code> ~ <code>fifth(in)</code>是<code>begin</code>(不区分大小写)，<code>flag</code>加1，设置<code>has_begin</code></li>
<li>同上，在包含此次<code>in</code>共三个字符时，且<code>third</code> ~ <code>fifth(in)</code>是<code>end</code>(不区分大小写)，<code>flag</code>减1，设置<code>has_end</code></li>
<li>读入字母，<code>has_begin</code>已经置高，说明前面五个字符已经是<code>begin</code>了，但是又读入一个字母，说明这个单词不是<code>begin</code>了，<code>flag</code>减1</li>
<li>同上，<code>has_end</code>已经置高了，说明这个单词不是<code>end</code>，<code>flag</code>需要加1</li>
<li>读入空格，说明单词已经读入完毕，<code>num</code>置0，如果<code>flag</code>此时是-1(<code>0x1ffffffff</code>)，说明先出现了未匹配的<code>end</code>，此时进入<code>illegal</code>状态，等待复位信号否则回到<code>start</code>空闲状态</li>
<li>读入其他字符进入<code>illegal</code>状态</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="思路二-多个状态"><a href="#思路二-多个状态" class="headerlink" title="思路二 多个状态"></a>思路二 多个状态</h3><ul>
<li><del>好处是清晰，没有坏处</del></li>
<li>状态设置思路<table>
<thead>
<tr>
<th align="center">状态</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">_start</td>
<td align="center">空闲状态等待空格或者字母</td>
</tr>
<tr>
<td align="center">_b</td>
<td align="center">匹配到单词b</td>
</tr>
<tr>
<td align="center">_be</td>
<td align="center">匹配到单词be</td>
</tr>
<tr>
<td align="center">_beg</td>
<td align="center">匹配到单词beg</td>
</tr>
<tr>
<td align="center">_begi</td>
<td align="center">匹配到单词begi</td>
</tr>
<tr>
<td align="center">_begin</td>
<td align="center">匹配到单词begin</td>
</tr>
<tr>
<td align="center">_e</td>
<td align="center">匹配到单词e</td>
</tr>
<tr>
<td align="center">_en</td>
<td align="center">匹配到单词en</td>
</tr>
<tr>
<td align="center">_end</td>
<td align="center">匹配到单词end</td>
</tr>
<tr>
<td align="center">_other</td>
<td align="center">匹配到其他单词</td>
</tr>
</tbody></table>
</li>
<li>寄存器设置思路<ul>
<li>只需要<code>state</code>寄存器保存状态和<code>flag</code>寄存器保存左括号数</li>
</ul>
</li>
<li>状态转移思路<ul>
<li><code>_start</code>状态<ul>
<li>复位后回到<code>_start</code>状态等待输入</li>
<li>如果是字母<code>b</code>进入<code>_b</code>状态</li>
<li>如果是字母<code>e</code>进入<code>_e</code>状态</li>
<li>如果是其他字母进入<code>_other</code>状态</li>
<li>空格保持状态</li>
</ul>
</li>
<li><code>_b</code> ~ <code>_en</code>状态<ul>
<li>每个都是匹配到某个字母转为下一个状态：<code>_b</code>匹配到字母<code>e</code>转到<code>_be</code></li>
<li>匹配到其他字母直接转为<code>_other</code></li>
<li>匹配到空格回到空闲状态</li>
</ul>
</li>
<li><code>_begin</code>与<code>_end</code><ul>
<li>两个状态特殊在于判断其后是否还有字母，也即到底是完整单词还是其他单词的前缀例如<code>endx</code></li>
<li>因为前一个状态转移时时默认匹配到了完整单词，例如<code>_begi</code>到<code>_begin</code>是匹配到了<code>begin</code>一个周期的，所以如果后面有其他字母需要调整<code>flag</code>的值</li>
</ul>
</li>
<li><code>_other</code><ul>
<li>接收到字母保持原态</li>
<li>接收到空格回到空闲状态</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="P1推荐题汇总"><a href="#P1推荐题汇总" class="headerlink" title="P1推荐题汇总"></a>P1推荐题汇总</h2><a class="btn-beautify " href="https://kie-chi.github.io/2024/09/30/CO_P1_extra/" 
  title="P1推荐题汇总"><span>P1推荐题汇总</span></a>
<p><a href="https://kie-chi.github.io/2024/09/30/CO_P1_extra/">P1推荐题汇总</a></p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
        <category>课下复习</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>北航计算机组成P4</title>
    <url>/2024/11/13/CO_P4/</url>
    <content><![CDATA[<h1 id="北航计算机组成P4"><a href="#北航计算机组成P4" class="headerlink" title="北航计算机组成P4"></a>北航计算机组成P4</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>咳咳，最近太忙了作业好多啊，搭完CPU每周还要迭代自己的测评机，原来CO也可以训练我们面向对象的能力</li>
</ul>
<hr>
<h2 id="课下"><a href="#课下" class="headerlink" title="课下"></a>课下</h2><ul>
<li>其实P4就是把P3的电路图翻译成代码，整体上没有难度，如果你P3有好好设计你的CPU的话，<del>没有好好设计的话，就照着学长设计好的CPU翻译</del>，总之也是从一个一个的模块开始搭建，这里不赘述了</li>
</ul>
<h3 id="组合逻辑建模"><a href="#组合逻辑建模" class="headerlink" title="组合逻辑建模"></a>组合逻辑建模</h3><ul>
<li>我啰嗦一两句，最近几年课程组不知道在干什么（<del>明年等我当助教我也要搞得抽象</del>），考试喜欢考一些奇奇怪怪的组合逻辑，所以或许你需要根据你使用的建模逻辑稍微熟练一些Verilog的语法，这样课上的时候或许不会那么慌</li>
<li>两种组合逻辑建模方式对于写CPU的思路还是有略微不同的，而且各有各的好处，见仁见智了</li>
</ul>
<h4 id="assign"><a href="#assign" class="headerlink" title="assign"></a><code>assign</code></h4><ul>
<li>最大的优点就是简洁、代码量很少，而且就是电路连线，从P3转过来会比较方便<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> ALU_out = (ALUOp == `ALU_add) ? A + B :</span><br><span class="line">                 (ALUOp == `ALU_sub) ? A - B :</span><br><span class="line">                 (ALUOp == `ALU_or) ? A | B :</span><br><span class="line">                 (ALUOp == `ALU_and) ? A &amp; B : <span class="number">32&#x27;b0</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>一行就解决了ALU，反正就是挺爽的</li>
</ul>
</li>
<li>缺点是对于复杂逻辑建模比较困难，所以<strong>强烈建议</strong>掌握<code>function</code>和<code>task</code>(这个或许不用嘛)的用法，反正考场上会用到的，比如我随便编一个指令，要求实现<code>gxadd rd, rs, rt</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gray(00): 00</span><br><span class="line">gray(01): 01</span><br><span class="line">gray(10): 11</span><br><span class="line">gray(11): 10</span><br><span class="line"></span><br><span class="line">temp1 &lt;- GPR[rs] + GPR[rt]</span><br><span class="line">for i in range(0,16):</span><br><span class="line">    temp2[2*i+1: 2*i] &lt;- gray(temp1[2*i+1: 2*i])</span><br><span class="line">temp2 &lt;- temp2 ^ temp1</span><br><span class="line">if temp2 &gt; temp1:</span><br><span class="line">    GPR[rd] = temp2</span><br><span class="line">else:</span><br><span class="line">    GPR[rd] = temp1</span><br></pre></td></tr></table></figure>
<ul>
<li>好，你现在用assign语句把它建模到ALU里面去（），是吧，这个时候<code>function</code>就要发力了，管他三七二十一全部丢进函数里面<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> [<span class="number">1</span>: <span class="number">0</span>] cal_gray;</span><br><span class="line">    <span class="keyword">input</span>[<span class="number">1</span>: <span class="number">0</span>] origin;</span><br><span class="line">    <span class="keyword">if</span> (origin == <span class="number">2&#x27;b0</span>) cal_gray = <span class="number">2&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (origin == <span class="number">2&#x27;b1</span>) cal_gray = <span class="number">2&#x27;b1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (origin == <span class="number">2&#x27;b10</span>) cal_gray = <span class="number">2&#x27;b11</span>;</span><br><span class="line">    <span class="keyword">else</span> cal_gray = <span class="number">2&#x27;b10</span>;</span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure></li>
<li>其实也可以如果你熟悉掩码和格雷码的定义的话，例如<code>gray(x) = x ^ (x &gt;&gt; 1)</code>，又因为两位的二进制右移一位第一位一定是0，所以我们考虑将32位的数字的奇数位覆盖再整体右移，达到一次实现16次2位的异或<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">temp1 = A + B;</span><br><span class="line">temp2 = temp1 &amp; <span class="number">0xaaaaaaaa</span>;</span><br><span class="line"><span class="comment">//0xaaaaaaaa就是....10101010</span></span><br><span class="line"><span class="comment">//反正奇数位就这样被覆盖了</span></span><br><span class="line">temp2 = temp2 &gt;&gt; <span class="number">1</span></span><br><span class="line"><span class="comment">//相当于进行了上面的 x &gt;&gt; 1，反正奇数位都是0了</span></span><br><span class="line">temp2 = temp2 ^ temp1</span><br><span class="line"><span class="comment">//最终的temp2就是经历两位gray转化后的数字了</span></span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> ALU_out = (ALUOp == `ALU_gxadd) ? </span><br><span class="line">(( ((A+B) ^ (((A+B) &amp; <span class="number">32&#x27;haaaaaaaa</span>) &gt;&gt; <span class="number">1</span>)) &gt; (A+B) ) ? ((A+B) ^ (((A+B) &amp; <span class="number">32&#x27;haaaaaaaa</span>) &gt;&gt; <span class="number">1</span>)) : (A+B))</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h4 id="always"><a href="#always" class="headerlink" title="always@(*)"></a><code>always@(*)</code></h4><ul>
<li>最大的缺点是代码量可能会比上面大一些，也可能大很多，全面准备吧</li>
<li>最大的优点就是适合复杂逻辑的建模，比如上面那个瞎编的指令</li>
<li>不过还是建议掌握<code>function</code>，多好啊，变成纯纯面向过程的语言了</li>
<li>讲一个经常会用的切片，好玩爱玩<ul>
<li>假设你现在想要学lb、lh指令取出一个字中的某个字节或者半字，但是不想要一直if-else（考场上不会的话枚举是一个很好的选择），你想到了verilog可以切片<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">input</span> <span class="keyword">wire</span> h_adder;</span><br><span class="line"><span class="keyword">input</span> <span class="keyword">wire</span>[<span class="number">1</span>: <span class="number">0</span>] b_adder;</span><br><span class="line"><span class="keyword">reg</span>[<span class="number">31</span>: <span class="number">0</span>] pos;</span><br><span class="line"><span class="keyword">reg</span>[<span class="number">0</span>: <span class="number">31</span>] neg;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pos[h_adder * 16 + 15: h_adder * 16]</span></span><br><span class="line"><span class="comment">//pos[b_adder * 8 + 7: b_adder * 8]</span></span><br><span class="line"><span class="comment">//错误用法，Verilog的切片两边要是常数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//正确写法</span></span><br><span class="line"><span class="comment">//定义高位到低位</span></span><br><span class="line">pos[h_adder * <span class="number">16</span> + <span class="number">15</span> -: <span class="number">16</span>]</span><br><span class="line"><span class="comment">//从h_adder * 16 + 15 取低16位，按照高位到低位排列</span></span><br><span class="line"><span class="comment">//pos[h_adder * 16 + 15: h_adder * 16]</span></span><br><span class="line">pos[h_adder * <span class="number">16</span> +: <span class="number">16</span>]</span><br><span class="line"><span class="comment">//从h_adder * 16 取高16位，但是还是按照从高到低排列</span></span><br><span class="line"><span class="comment">//pos[h_adder * 16 + 15: h_adder * 16]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义从低到高</span></span><br><span class="line">neg[h_adder * <span class="number">16</span> + <span class="number">15</span> -: <span class="number">16</span>]</span><br><span class="line"><span class="comment">//同上，但是从低到高排列</span></span><br><span class="line"><span class="comment">//neg[h_adder * 16: h_adder * 16 + 15]</span></span><br><span class="line">neg[h_adder * <span class="number">16</span> +: <span class="number">16</span>]</span><br><span class="line"><span class="comment">//同理</span></span><br><span class="line"><span class="comment">//neg[h_adder * 16: h_adder * 16 + 15]</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h2 id="课上"><a href="#课上" class="headerlink" title="课上"></a>课上</h2><h3 id="T1-eam"><a href="#T1-eam" class="headerlink" title="T1 eam"></a>T1 eam</h3><ul>
<li><code>eam $rd, $rs, $rt</code></li>
<li>R型指令<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ext_imm &lt;- signed(GPR[rs][15: 0])</span><br><span class="line">res &lt;- ext_imm % 17</span><br><span class="line">if signed(GPR[rt]) &lt; 0:</span><br><span class="line">    GPR[rd] = one_ext(res)</span><br><span class="line">else:</span><br><span class="line">    GPR[rd] = zero_ext(res)</span><br></pre></td></tr></table></figure>
<ul>
<li>将rs寄存器低16位截断为有符号数，这个数对17取模得到的<strong>正余数</strong>，然后根据另一个操作数的正负进行1或者0拓展</li>
</ul>
</li>
</ul>
<h3 id="T2-cptl"><a href="#T2-cptl" class="headerlink" title="T2 cptl"></a>T2 cptl</h3><ul>
<li><code>cptl $rs, $rt, label</code></li>
<li>I型指令<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">temp &lt;- PC + 4 + sign_ext(offset || 00)</span><br><span class="line">PC &lt;- temp</span><br><span class="line"></span><br><span class="line">if GPR[rs][17: 12] == 6&#x27;b111111 || ......GPR[rs][5: 0] == 6&#x27;b111111: </span><br><span class="line">    GPR[rt] &lt;- PC + 4</span><br><span class="line">else:</span><br><span class="line">    GPR[31] &lt;- PC + 4</span><br></pre></td></tr></table></figure>
<ul>
<li>跳转类指令，然后链接内容和rs寄存器低18位是否有6个连续的1有关系</li>
</ul>
</li>
</ul>
<h3 id="T3-olw"><a href="#T3-olw" class="headerlink" title="T3 olw"></a>T3 olw</h3><ul>
<li><code>olw $rt, offset($base)</code></li>
<li>I型指令<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vadder &lt;- GPR[base] + sign_ext(offset || 00)</span><br><span class="line">temp &lt;- Mem[vadder[31: 2]]</span><br><span class="line"></span><br><span class="line">if func(temp):</span><br><span class="line">    GPR[rt] &lt;- temp</span><br><span class="line">else:</span><br><span class="line">    None</span><br></pre></td></tr></table></figure>
<ul>
<li>如果读出来的数据是单调不减的，那么才写入</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>课上没什么好玩的，第一个指令注意要使用有符号，不然你就会像我一样疑惑了半个小时为什么这么取模都是0然后暴力while循环求余数。。。</li>
<li>过两天会把P5好好更新的，顺便预告一下测评机，其实写好了，只是想等P6直接做一个流水线全的，over</li>
<li>先不写题解了，亲爱的小羊找我看视频，我先溜了</li>
</ul>
]]></content>
      <categories>
        <category>计算机组成原理</category>
        <category>课下复习</category>
        <category>课上考试</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>北航计算机组成P3课下</title>
    <url>/2024/10/22/CO_P3/</url>
    <content><![CDATA[<h1 id="北航计算机组成原理P3课下"><a href="#北航计算机组成原理P3课下" class="headerlink" title="北航计算机组成原理P3课下"></a>北航计算机组成原理P3课下</h1><div class="note info simple"><p>通过阅读本文，你可以大致了解北京航空航天大学2023级计算机组成原理P3课下的相关内容，希望能对你有所帮助</p>
</div>
<h2 id="设计文档"><a href="#设计文档" class="headerlink" title="设计文档"></a>设计文档</h2><h3 id="总要求"><a href="#总要求" class="headerlink" title="总要求"></a>总要求</h3><ul>
<li>实现指令集<code>&#123;addu、subu、ori、lui、lw、sw、beq、nop&#125;</code></li>
<li>指令集所有指令的<code>RTL</code><ul>
<li><code>add</code>(<code>addu</code>)<br><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CO_P3_image0.png" alt="add指令RTL"></li>
<li><code>sub</code>(<code>subu</code>)<br><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CO_P3_image1.png" alt="sub指令RTL"></li>
<li><code>ori</code><br><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CO_P3_image2.png" alt="ori指令RTL"></li>
<li><code>lui</code><br><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CO_P3_image3.png" alt="lui指令RTL"></li>
<li><code>lw</code><br><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CO_P3_image4.png" alt="lw指令RTL"><br><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CO_P3_image5.png" alt="lw指令RTL"></li>
<li><code>sw</code><br><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CO_P3_image6.png" alt="sw指令RTL"></li>
<li><code>beq</code><br><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CO_P3_image7.png" alt="beq指令RTL"></li>
<li><code>nop</code><ul>
<li>特殊，一般可以用<code>sll</code>一起代替，这里因为指令集没有<code>sll</code>所以我们直接使用<code>sll</code>的部分代替<code>nop</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="数据通路设计草图"><a href="#数据通路设计草图" class="headerlink" title="数据通路设计草图"></a>数据通路设计草图</h3><p><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CO_P3_06e1d48e25b28e0dd5a05c1c5069791.jpg" alt="数据通路草图"><br>注：上述的<code>j</code>、<code>jal</code>、<code>jr</code>指令不在指令集中</p>
<hr>
<h3 id="数据通路详细设计"><a href="#数据通路详细设计" class="headerlink" title="数据通路详细设计"></a>数据通路详细设计</h3><h4 id="IF"><a href="#IF" class="headerlink" title="IF"></a><code>IF</code></h4><ul>
<li>首先我们观察需要设计的CPU，必不可少的一部分就是<code>PC</code>、<code>IM</code>，没有指令谈何执行指令呢，所以我们将这个阶段称为<strong>取指</strong>(<code>IF</code>)</li>
<li>基于低耦合的原则，我们希望<code>PC</code>永远只是指向当前需要执行的指令，而不需要进行其他的操作，因此，我们在取指阶段多加入一个模块**次地址计算模块(<code>NPC</code>)**，专门用于计算根据<code>PC</code>的值以及执行的指令与结果更新<code>PC</code>的值</li>
<li>至此，<code>IF</code>阶段的所有模块都浮出水面了分别是<code>PC</code>、<code>NPC</code>、<code>IM</code></li>
</ul>
<h5 id="PC"><a href="#PC" class="headerlink" title="PC"></a><code>PC</code></h5><ul>
<li>取指阶段最最重要的一个模块无疑是<code>PC</code>程序计数器，没有地址无从取指</li>
<li>程序计数器<code>PC</code>始终指向当前执行的指令地址，且会根据<code>NPC</code>提供的值更新值<table>
<thead>
<tr>
<th align="center">端口</th>
<th align="center">位宽</th>
<th align="center">方向</th>
<th align="center">功能描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">init[31:0]</td>
<td align="center">32</td>
<td align="center">input</td>
<td align="center">对于PC端口的初始化，默认为<code>0x00003000</code></td>
</tr>
<tr>
<td align="center">NPC[31:0]</td>
<td align="center">32</td>
<td align="center">input</td>
<td align="center">NPC传入的值，时钟沿更新PC值</td>
</tr>
<tr>
<td align="center">clk</td>
<td align="center">1</td>
<td align="center">input</td>
<td align="center">时钟信号</td>
</tr>
<tr>
<td align="center">rst</td>
<td align="center">1</td>
<td align="center">input</td>
<td align="center"><strong>异步</strong>复位信号</td>
</tr>
<tr>
<td align="center">PC[31:0]</td>
<td align="center">32</td>
<td align="center">output</td>
<td align="center">当前执行的指令地址</td>
</tr>
</tbody></table>
<img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CO_P3_image8.png" alt="PC结构图"></li>
</ul>
<h5 id="NPC"><a href="#NPC" class="headerlink" title="NPC"></a><code>NPC</code></h5><ul>
<li><p>既然介绍了<code>PC</code>模块，接下来就需要设计<code>NPC</code>模块与<code>PC</code>模块一起配合不断地获得需要执行的指令的地址</p>
</li>
<li><p><code>NPC</code>将根据当前<code>PC</code>的值与当前指令(例如<code>branch</code>类、<code>jump</code>类指令)综合判断更新<code>PC</code>的值</p>
<table>
<thead>
<tr>
<th align="center">端口</th>
<th align="center">位宽</th>
<th align="center">方向</th>
<th align="center">功能描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">PC[31:0]</td>
<td align="center">32</td>
<td align="center">input</td>
<td align="center">接受当前PC的值</td>
</tr>
<tr>
<td align="center">imm[15:0]</td>
<td align="center">16(目前)</td>
<td align="center">input</td>
<td align="center">branch类指令跳转的立即数</td>
</tr>
<tr>
<td align="center">IM_slt</td>
<td align="center">1(目前)</td>
<td align="center">input</td>
<td align="center">当前执行的指令类型</td>
</tr>
<tr>
<td align="center">RA[31:0] (暂未使用)</td>
<td align="center">32</td>
<td align="center">input</td>
<td align="center">传递<code>$ra</code>的值</td>
</tr>
<tr>
<td align="center"><del>is_eq</del></td>
<td align="center">1(已丢弃)</td>
<td align="center">input</td>
<td align="center">与IM_slt共同决定PC是否发生其他变化</td>
</tr>
<tr>
<td align="center">NPC[31:0]</td>
<td align="center">32</td>
<td align="center">output</td>
<td align="center">输出计算得到的此地址</td>
</tr>
<tr>
<td align="center">PC+4[31:0] (暂未使用)</td>
<td align="center">32</td>
<td align="center">output</td>
<td align="center">传递值给<code>jal</code>、<code>jalr</code>等</td>
</tr>
</tbody></table>
</li>
<li><p><strong>注意</strong>，在后续设计中<code>is_eq</code>这个符号位不再传输给<code>NPC</code>并在<code>NPC</code>内部与<code>IM_slt</code>信号进行合并对<code>PC</code>值变化进行指导，而是<strong>将符号位直接传递给Controller</strong>而<code>IM_slt</code>表示的意思也变成了执行<strong>已满足条件</strong>的指令类型，例如<code>1 -&gt; beq</code>，含义为当前指令是<code>beq</code>且已经满足跳转条件</p>
<p><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CO_P3_image9.png" alt="NPC结构图"><br><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CO_P3_449ed5029e932b2f65a9f080a0dc318.jpg" alt="NPC草图"></p>
</li>
</ul>
<h5 id="IM"><a href="#IM" class="headerlink" title="IM"></a><code>IM</code></h5><ul>
<li>通过<code>PC</code>传入的地址寻找需要执行的地址，使用<code>ROM</code>存储器即可<table>
<thead>
<tr>
<th align="center">端口</th>
<th align="center">位宽</th>
<th align="center">方向</th>
<th align="center">功能描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">PC[31:0]</td>
<td align="center">32</td>
<td align="center">input</td>
<td align="center">传入PC的值</td>
</tr>
<tr>
<td align="center">IM[31:0]</td>
<td align="center">32</td>
<td align="center">output</td>
<td align="center">得到的指令</td>
</tr>
</tbody></table>
<img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CO_P3_image10.png" alt="IM结构图"></li>
</ul>
<hr>
<h4 id="ID"><a href="#ID" class="headerlink" title="ID"></a><code>ID</code></h4><ul>
<li>现在我们已经可以正常地从指令存储器中取出指令了，那么为了执行指令我们首先需要明白这句指令在说什么(通过指令机器码确定指令)，所以我们需要一个指令译码器<code>IM_SPL</code>，其次确定了指令的类型(<code>R</code> <code>I</code> <code>J</code>)、指令的含义，我们就需要取出这个指令需要的操作数因为指令的类型不同，可能来源于寄存器堆<code>GRF</code>，也可能来自于指令给出的立即数，所以我们需要对立即数处理的模块<code>EXT</code>，这个阶段称为<strong>译码(<code>ID</code>)</strong></li>
<li>至此，<code>ID</code>阶段包含<code>IM_SPL</code>、<code>GRF</code>、<code>EXT</code>三个模块</li>
</ul>
<h5 id="IM-SPL"><a href="#IM-SPL" class="headerlink" title="IM_SPL"></a><code>IM_SPL</code></h5><ul>
<li><code>IM_SPL</code>对于从<code>IM</code>中取出的指令进行分线器分出，通过<code>IM_SPL</code>的输出内容，我们能更加清晰地了解指令的类型与用途<table>
<thead>
<tr>
<th align="center">端口</th>
<th align="center">位宽</th>
<th align="center">方向</th>
<th align="center">功能描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">IM[31:0]</td>
<td align="center">32</td>
<td align="center">input</td>
<td align="center">传入解析的指令</td>
</tr>
<tr>
<td align="center">opcode[5:0]</td>
<td align="center">6</td>
<td align="center">output</td>
<td align="center">指令操作码</td>
</tr>
<tr>
<td align="center">rs[4:0]</td>
<td align="center">5</td>
<td align="center">output</td>
<td align="center">源寄存器</td>
</tr>
<tr>
<td align="center">rt[4:0]</td>
<td align="center">5</td>
<td align="center">output</td>
<td align="center">目标寄存器(J、I)</td>
</tr>
<tr>
<td align="center">rd[4:0]</td>
<td align="center">5</td>
<td align="center">output</td>
<td align="center">目的地寄存器(R)</td>
</tr>
<tr>
<td align="center">shamt[4:0] (目前不使用)</td>
<td align="center">5</td>
<td align="center">output</td>
<td align="center">移位</td>
</tr>
<tr>
<td align="center">funct[5:0]</td>
<td align="center">6</td>
<td align="center">output</td>
<td align="center">配合opcode确认R型指令</td>
</tr>
<tr>
<td align="center">imm_i[15:0]</td>
<td align="center">16</td>
<td align="center">output</td>
<td align="center">I型指令的立即数操作数</td>
</tr>
<tr>
<td align="center">imm_j[25:0] (目前不使用)</td>
<td align="center">26</td>
<td align="center">output</td>
<td align="center">J型指令的立即数操作数</td>
</tr>
</tbody></table>
<img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CO_P3_image11.png" alt="IM_SPL结构图"></li>
</ul>
<h5 id="GRF"><a href="#GRF" class="headerlink" title="GRF"></a><code>GRF</code></h5><ul>
<li>假设当前的是R型指令，我们需要的操作数来自于寄存器，所以我们需要使用<code>IM_SPL</code>解析出来的寄存器编号去获得操作数的值<table>
<thead>
<tr>
<th align="center">端口</th>
<th align="center">位宽</th>
<th align="center">方向</th>
<th align="center">功能描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">clk</td>
<td align="center">1</td>
<td align="center">input</td>
<td align="center">时钟信号</td>
</tr>
<tr>
<td align="center">rst</td>
<td align="center">1</td>
<td align="center">input</td>
<td align="center"><strong>异步</strong>复位信号</td>
</tr>
<tr>
<td align="center">A1[4:0]</td>
<td align="center">5</td>
<td align="center">input</td>
<td align="center">第一个读寄存器编号</td>
</tr>
<tr>
<td align="center">A2[4:0]</td>
<td align="center">5</td>
<td align="center">input</td>
<td align="center">第二个读寄存器编号</td>
</tr>
<tr>
<td align="center">A3[4:0] (<code>WB</code>阶段使用)</td>
<td align="center">5</td>
<td align="center">input</td>
<td align="center">写入寄存器编号</td>
</tr>
<tr>
<td align="center">WD[31:0] (<code>WB</code>阶段使用)</td>
<td align="center">32</td>
<td align="center">input</td>
<td align="center">写入寄存器的值</td>
</tr>
<tr>
<td align="center">WE(<code>WB</code>阶段使用)</td>
<td align="center">1</td>
<td align="center">input</td>
<td align="center">写使能信号</td>
</tr>
<tr>
<td align="center">RD1[31:0]</td>
<td align="center">32</td>
<td align="center">output</td>
<td align="center">第一个读寄存器的值</td>
</tr>
<tr>
<td align="center">RD2[31:0]</td>
<td align="center">32</td>
<td align="center">output</td>
<td align="center">第二个读寄存器的值</td>
</tr>
</tbody></table>
<img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CO_P3_image12.png" alt="GRF结构图"><br><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CO_P3_30ef94c2f26f95db316fb797fd8d7c8.jpg" alt="GRF草图"></li>
</ul>
<h5 id="EXT"><a href="#EXT" class="headerlink" title="EXT"></a><code>EXT</code></h5><ul>
<li>对于I型指令与J型指令(目前不涉及)，我们虽然可以直接从指令中获得操作数，但是为了方便后续执行，我们需要将立即数位拓展至与寄存器的值的位数相同(32位)，故<code>EXT</code>就是根据指令来拓展立即数的模块<table>
<thead>
<tr>
<th align="center">端口</th>
<th align="center">位宽</th>
<th align="center">方向</th>
<th align="center">功能描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">imm[15:0]</td>
<td align="center">16(目前)</td>
<td align="center">input</td>
<td align="center">指令传入的立即数</td>
</tr>
<tr>
<td align="center">ext_slt[1:0]</td>
<td align="center">2(目前)</td>
<td align="center">input</td>
<td align="center">控制位拓展的类型</td>
</tr>
<tr>
<td align="center">ext[31:0]</td>
<td align="center">32</td>
<td align="center">output</td>
<td align="center">拓展后的立即数</td>
</tr>
</tbody></table>
<img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CO_P3_image13.png" alt="EXT结构图"><br><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CO_P3_02a7d5e47dc0b941cbed86f3854f146.jpg" alt="EXT草图"></li>
</ul>
<hr>
<h4 id="EX"><a href="#EX" class="headerlink" title="EX"></a><code>EX</code></h4><ul>
<li>现在我们已经做好了执行指令的前的所有准备，接下来我们对这些操作数进行某些操作得到我们指令需要内容，这个阶段称为<strong>执行(<code>EX</code>)</strong></li>
<li><code>EX</code>阶段只有一个模块<code>ALU</code></li>
</ul>
<h5 id="ALU"><a href="#ALU" class="headerlink" title="ALU"></a><code>ALU</code></h5><ul>
<li><code>ALU</code>算术单元来对操作数进行操作得到结果(算术类指令、逻辑类指令、存取类指令)，同时通过<code>ALU</code>输出符号位(<code>OF</code>co实验不需要、<code>ZF</code>目前仅实现、<code>SF</code>比较大小需要、 <code>CF</code>co实验不需要)<table>
<thead>
<tr>
<th align="center">端口</th>
<th align="center">位宽</th>
<th align="center">方向</th>
<th align="center">功能描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A[31:0]</td>
<td align="center">32</td>
<td align="center">input</td>
<td align="center">第一个操作数</td>
</tr>
<tr>
<td align="center">B[31:0]</td>
<td align="center">32</td>
<td align="center">input</td>
<td align="center">第二个操作数</td>
</tr>
<tr>
<td align="center">cal_slt</td>
<td align="center">1</td>
<td align="center">input</td>
<td align="center">加法电路还是减法电路</td>
</tr>
<tr>
<td align="center">out_slt[1:0]</td>
<td align="center">2</td>
<td align="center">input</td>
<td align="center">选择输出了什么</td>
</tr>
<tr>
<td align="center">out[31:0]</td>
<td align="center">32</td>
<td align="center">output</td>
<td align="center">输出数据</td>
</tr>
<tr>
<td align="center">is_eq(目前)</td>
<td align="center">1</td>
<td align="center">output</td>
<td align="center">符号位(目前只有零信号)</td>
</tr>
<tr>
<td align="center">flag_slt(未实现)</td>
<td align="center">？</td>
<td align="center">input</td>
<td align="center">控制输出的符号位</td>
</tr>
</tbody></table>
<img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CO_P3_image14.png" alt="ALU结构图"><br><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CO_P3_0aebdf2625a924021aaf26ac66ddfb8.jpg" alt="ALU草图"></li>
</ul>
<hr>
<h4 id="MEM"><a href="#MEM" class="headerlink" title="MEM"></a><code>MEM</code></h4><ul>
<li>对于存取类指令，我们通过<code>EX</code>阶段获得的是接下来需要操作数在内存中的地址，我们需要对数据存储器<code>DM</code>再进行相应的更改，这个阶段称为<strong>访存(<code>MEM</code>)</strong></li>
<li><code>MEM</code>阶段只有一个模块<code>DM</code></li>
</ul>
<h5 id="DM"><a href="#DM" class="headerlink" title="DM"></a><code>DM</code></h5><ul>
<li>存放数据的存储器，对于存取类指令，我们可以从数据存储器中取得数据<table>
<thead>
<tr>
<th align="center">端口</th>
<th align="center">位宽</th>
<th align="center">方向</th>
<th align="center">功能描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">clk</td>
<td align="center">1</td>
<td align="center">input</td>
<td align="center">时钟信号</td>
</tr>
<tr>
<td align="center">rst</td>
<td align="center">1</td>
<td align="center">input</td>
<td align="center"><strong>异步</strong>复位信号</td>
</tr>
<tr>
<td align="center">A[31:0]</td>
<td align="center">32</td>
<td align="center">input</td>
<td align="center">存取数据地址</td>
</tr>
<tr>
<td align="center">WD[31:0]</td>
<td align="center">32</td>
<td align="center">input</td>
<td align="center">存入数据值</td>
</tr>
<tr>
<td align="center">WE</td>
<td align="center">1</td>
<td align="center">input</td>
<td align="center">写使能信号</td>
</tr>
<tr>
<td align="center">RD[31:0]</td>
<td align="center">32</td>
<td align="center">output</td>
<td align="center">读出数据值</td>
</tr>
</tbody></table>
<img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CO_P3_image15.png" alt="DM结构图"></li>
</ul>
<hr>
<h4 id="WB"><a href="#WB" class="headerlink" title="WB"></a><code>WB</code></h4><ul>
<li>对于<code>ALU</code>计算得到的内容以及从内存中读出的值，我们经常需要写回寄存器堆，所以最后一个阶段虽然仍然是针对寄存器堆，所以这个阶段我们称其为<strong>回写(<code>WB</code>)</strong></li>
<li><code>WB</code>阶段显然也只有唯一的模块<code>GRF</code></li>
</ul>
<h5 id="GRF-1"><a href="#GRF-1" class="headerlink" title="GRF"></a><code>GRF</code></h5><ul>
<li>在<code>ID</code>阶段我们已经使用了<code>GRF</code>作为数据的提供方，但是还有一些端口没有使用，在这里我们将使用余下的一些端口<table>
<thead>
<tr>
<th align="center">端口</th>
<th align="center">位宽</th>
<th align="center">方向</th>
<th align="center">功能描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">clk</td>
<td align="center">1</td>
<td align="center">input</td>
<td align="center">时钟信号</td>
</tr>
<tr>
<td align="center">rst</td>
<td align="center">1</td>
<td align="center">input</td>
<td align="center"><strong>异步</strong>复位信号</td>
</tr>
<tr>
<td align="center">A1[4:0] (<code>ID</code>阶段使用)</td>
<td align="center">5</td>
<td align="center">input</td>
<td align="center">第一个读寄存器编号</td>
</tr>
<tr>
<td align="center">A2[4:0] (<code>ID</code>阶段使用)</td>
<td align="center">5</td>
<td align="center">input</td>
<td align="center">第二个读寄存器编号</td>
</tr>
<tr>
<td align="center">A3[4:0]</td>
<td align="center">5</td>
<td align="center">input</td>
<td align="center">写入寄存器编号</td>
</tr>
<tr>
<td align="center">WD[31:0]</td>
<td align="center">32</td>
<td align="center">input</td>
<td align="center">写入寄存器的值</td>
</tr>
<tr>
<td align="center">WE</td>
<td align="center">1</td>
<td align="center">input</td>
<td align="center">写使能信号</td>
</tr>
<tr>
<td align="center">RD1[31:0] (<code>ID</code>阶段使用)</td>
<td align="center">32</td>
<td align="center">output</td>
<td align="center">第一个读寄存器的值</td>
</tr>
<tr>
<td align="center">RD2[31:0] (<code>ID</code>阶段使用)</td>
<td align="center">32</td>
<td align="center">output</td>
<td align="center">第二个读寄存器的值</td>
</tr>
</tbody></table>
<strong>设计草图等看<a href="#grf">上面</a></strong></li>
</ul>
<hr>
<h4 id="总数据通路草图"><a href="#总数据通路草图" class="headerlink" title="总数据通路草图"></a>总数据通路草图</h4><ul>
<li>对于单周期CPU所有基础部件我们已经搭建完毕，接下来练成数据通路只需要将相应的端口进行连接(<strong>出现多对一端口使用MUX，控制信号后面给出</strong>)<br><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CO_P3_e4b367f3a721a3dbc9b295929b1039b.jpg" alt="总数据通路草图"></li>
</ul>
<hr>
<h3 id="控制信号生成"><a href="#控制信号生成" class="headerlink" title="控制信号生成"></a>控制信号生成</h3><ul>
<li><p>在上述阶段，我们已经基本完成了各个基本指令的数据通路的实现，接下来我们将通过<code>Controller</code>根据指令生成各异的控制信号来指导我们数据通路的流通</p>
</li>
<li><p>接下来的所有控制信号出现顺序采用(<code>IF -&gt; ID -&gt; EX -&gt; MEM -&gt; WB</code>)</p>
<table>
<thead>
<tr>
<th align="center">控制信号</th>
<th align="center">位宽</th>
<th align="center">功能描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">IM_slt</td>
<td align="center">1</td>
<td align="center">控制NPC中im_slt，说明此次执行的指令类型</td>
</tr>
<tr>
<td align="center">A3_slt</td>
<td align="center">1</td>
<td align="center">控制输入GRF的A3端口，根据R型指令与I型指令不同</td>
</tr>
<tr>
<td align="center">GRF_we</td>
<td align="center">1</td>
<td align="center">控制GRF的WE信号，是否写入寄存器堆</td>
</tr>
<tr>
<td align="center">EXT_slt[1:0]</td>
<td align="center">2</td>
<td align="center">控制EXT的ext_slt，调整拓展指令的类型</td>
</tr>
<tr>
<td align="center">B_slt</td>
<td align="center">1</td>
<td align="center">控制ALU的B端口输入，根据R型指令与I型指令不同</td>
</tr>
<tr>
<td align="center">CAL_slt</td>
<td align="center">1</td>
<td align="center">控制ALU的cal_slt信号，选择加法或者减法电路</td>
</tr>
<tr>
<td align="center">OUT_slt</td>
<td align="center">2</td>
<td align="center">控制ALU的out_slt信号，选择输出的类型</td>
</tr>
<tr>
<td align="center">DM_we</td>
<td align="center">1</td>
<td align="center">控制DM的we信号，是否写入内存</td>
</tr>
<tr>
<td align="center">WD_slt</td>
<td align="center">1</td>
<td align="center">控制GRF的WD端口输入，选择不同的写入数据</td>
</tr>
</tbody></table>
</li>
<li><p>采用与或门阵列的形式生成信号，例如，先通过<code>opcode</code>、<code>funct</code>两个信号确定执行的指令类型，再通过指令类型去生成控制信号</p>
<ul>
<li>与门阵列生成指令类型<br><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CO_P3_image16.png" alt="非R型指令与门阵列"><br><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CO_P3_image17.png" alt="R型指令与门阵列"></li>
<li>或门阵列生成控制信号<br><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CO_P3_image18.png" alt="或门阵列"></li>
</ul>
</li>
</ul>
<hr>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><ol>
<li>上面我们介绍了通过 FSM 理解单周期 CPU 的基本方法。请大家指出单周期 CPU 所用到的模块中，哪些发挥状态存储功能，哪些发挥状态转移功能。<br>  CPU中的<code>DM</code>、<code>GRF</code>是状态量。通过<code>IF</code>、<code>ID</code>阶段其他部件、<code>EX</code>阶段的部件来实现状态转移，因为在这些阶段流通的数据并不会保存，而是随着PC的变化而变化，只有发生对<code>DM</code>、<code>GRF</code>读写才会保存下来，视为“状态的改变”</li>
<li>现在我们的模块中 IM 使用 ROM， DM 使用 RAM， GRF 使用 Register，这种做法合理吗 请给出分析，若有改进意见也请一并给出。<br>合理，现代计算机也采取寄存器堆来保存GRF的内容，在于其访问快、效率高。对于IM存储器，我们只需要读取其中的指令而不需要改变，所以我们使用ROM是合理的；对于DM存储器，我们不仅需要从中读取数据，而且还需要向其中写入数据，所以我们使用RAM是合理的。但是他们不能使用寄存器堆，因为太浪费资源了，很多寄存器使用率太低。</li>
<li>在上述提示的模块之外，你是否在实际实现时设计了其他的模块？如果是的话，请给出介绍和设计的思路。<br>多设计了一个<code>IM_SPL</code>模块，用于将<code>IM</code>中取出的指令解析为<code>&#123;opcode, rs, rt, rd, shamt, funct, imm_i, imm_j&#125;</code>的格式并输出，方便后续<code>Controller</code>解析指令含义并生成控制信号</li>
<li>事实上，实现 nop 空指令，我们并不需要将它加入控制信号真值表，为什么？<br>在目前的8指令CPU中，我们通过或门阵列实现控制信号的生成，<code>nop</code>指令不参与任何或门，意味着全部进行默认操作，<code>DM_we</code>与<code>GRF_we</code>都为0，并不会改变CPU的状态；在后续的设计中我们知道<code>nop</code>实际上与<code>sll $0, $0, 0</code>是一致的，这个指令同样不会进行任何改变，所以完全不需要单独加入控制信号真值表中</li>
<li>阅读 Pre 的 “MIPS 指令集及汇编语言” 一节中给出的测试样例，评价其强度（可从各个指令的覆盖情况，单一指令各种行为的覆盖情况等方面分析），并指出具体的不足之处。<br>所有指令都没有将结果存入<code>$0</code>寄存器的行为，无法测试<code>GRF</code>的正确性<br><code>add</code>与<code>sub</code>没有测试边界数据如21474637等接近32位的数据，没有将<code>$0</code>作为操作数的情况<br><code>lw</code>与<code>sw</code>的base寄存器只有<code>$0</code>，而且offset没有同时覆盖正、负、零情况<br><code>beq</code>没有覆盖跳转且向前跳、跳转且向后跳、跳转且原地跳、不跳转且向前跳、不跳转且向后跳、不跳转且原地跳</li>
</ol>
<h2 id="生成测试数据"><a href="#生成测试数据" class="headerlink" title="生成测试数据"></a>生成测试数据</h2><p>小熊正在赶制</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
        <category>课下复习</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>北航计算机组成单周期数据生成</title>
    <url>/2024/10/28/CO_P4_noexam/</url>
    <content><![CDATA[<h1 id="两种可能的测试数据生成方式"><a href="#两种可能的测试数据生成方式" class="headerlink" title="两种可能的测试数据生成方式"></a>两种可能的测试数据生成方式</h1><h2 id="unitTest"><a href="#unitTest" class="headerlink" title="unitTest"></a>unitTest</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li>如同java中的单元测试，我们将常规指令（不包含什么<code>lwso</code>、<code>cwp</code>…）分为五个类别<ol>
<li>寄存器赋值类型指令（set）<ul>
<li>例如<code>lui</code>，能直接通过立即数对寄存器赋值（这里我还加入了<code>ori</code>配对成<code>li</code>），将来可能<code>addi</code>、<code>subi</code>也是这里的一部分</li>
</ul>
</li>
<li>寄存器运算类型指令（arth）<ul>
<li>例如<code>add</code>，通过两个寄存器相互运算得到值的指令，更通俗就是R型指令</li>
</ul>
</li>
<li>存取类型指令（store）<ul>
<li>例如<code>lw</code>，内存参与的指令</li>
</ul>
</li>
<li>分支类型指令（branch）<ul>
<li>例如<code>beq</code>，有条件跳转（有条件跳转并链接）指令</li>
</ul>
</li>
<li>跳转类型指令（jump）<ul>
<li>例如<code>jal</code>，无条件跳转（无条件跳转并链接）指令</li>
</ul>
</li>
</ol>
</li>
<li>接下来将我们已有的指令集分类加入，并按照<code>set -&gt; arth/store -&gt; branch -&gt; jump</code>的顺序依次进行测试，已测试的指令将出现在后面的指令测试中测试后续指令，所以测试顺序也是非常重要的</li>
</ul>
<hr>
<h3 id="测试思路"><a href="#测试思路" class="headerlink" title="测试思路"></a>测试思路</h3><ul>
<li><code>set</code><ul>
<li>先测试<code>set</code>类指令，不仅是因为它们不需要依托其他指令的正确性，而且后续所有边界数据的测试都需要提前赋值，测试思路即多次对<code>$0 ~ $31</code>寄存器赋随机值</li>
</ul>
</li>
<li><code>arth</code><ul>
<li>对于参与运算的数据，分为<code>inf</code>（最大、最小值左右）、<code>zero</code>（0左右）、<code>random</code>（其他随机数），我们对任意的两个寄存器选择上面某种方式<strong>赋值</strong>，再从此次数据集中随机挑选一条指令参与</li>
</ul>
</li>
<li><code>store</code><ul>
<li>同理，选择基地址寄存器，循环随机生成寄存器值和偏移量，满足下面条件才结束循环<ul>
<li>若选出了<code>$0</code>，要求生成<code>0 &lt; offset &lt; 3072</code></li>
<li>若不是<code>$0</code>，要求<code>0 &lt; grf[base] + offset &lt; 3072</code></li>
</ul>
</li>
<li>最后乘4，如果是<code>sb</code>、<code>sh</code>指令的指令考虑再给<code>offset</code>加上一个小的随机数</li>
</ul>
</li>
<li><code>branch</code><ul>
<li>选择测试的<code>branch</code>指令，并随机决定是否跳转</li>
<li>若不跳转<ul>
<li>随机给两个寄存器赋不满足条件的值，然后结束</li>
</ul>
</li>
<li>若跳转<ul>
<li>向前跳，借鉴for循环的思路，但只向前跳一小步，主要测试<strong>能否向前跳</strong>，<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">li $reg1 num1</span><br><span class="line">li $reg2 num1 - num2</span><br><span class="line">li $reg3 num2</span><br><span class="line">Brach:</span><br><span class="line">add $reg2, $reg2, $reg3</span><br><span class="line">beq $reg1, $reg2, Branch</span><br></pre></td></tr></table></figure></li>
<li>向后跳更加随意</li>
</ul>
</li>
<li><strong>关于死循环</strong><ul>
<li>我的数据生成器是可以生成死循环指令，目前只实现了<code>beq</code>死循环，规定死循环只在测试内容的最后5%才有可能出现，并且出现死循环即跳出生成数据返回，<strong>死循环</strong>永远在最后一个指令</li>
<li>所以我的测评机在把代码丢给mars前会先检测最后一条指令（mars死机不会给出十六进制数据。。。），如果是死循环指令将会切除，并在提供给我们CPU的十六进制数据中加入死循环指令和一条<code>set</code>指令，测试CPU是否真的死循环了</li>
<li><del>然后我发现死循环某种程度也是向前跳，其实不用单独测试，又把这个功能去掉了</del></li>
</ul>
</li>
</ul>
</li>
<li><code>jump</code><ul>
<li>对于一个无条件跳转指令，首先他要能跳</li>
<li>对于借助标签的跳转指令<ol>
<li>采用for循环的方式测试能否正常跳转<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">li $reg1, num1</span><br><span class="line">li $reg2, num2</span><br><span class="line">li $reg3, 1</span><br><span class="line">Jumpstart:</span><br><span class="line">beq $reg1, $reg2, Jumpend</span><br><span class="line">add/sub $reg1, $reg1, $reg3</span><br><span class="line">jump Jumpstart</span><br></pre></td></tr></table></figure></li>
<li>采取连续跳跃，提前生成能够跳出的label组合<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Jump0_0:</span><br><span class="line">jal Jump0_3 </span><br><span class="line">Jump0_1:</span><br><span class="line">jal Jump0_4</span><br><span class="line">Jump0_2:</span><br><span class="line">jal Jump0_5</span><br><span class="line">Jump0_3:</span><br><span class="line">jal Jump0_2</span><br><span class="line">Jump0_4:</span><br><span class="line">jal Jump0_1</span><br><span class="line">Jump0_5:</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>对于借助寄存器的跳转指令，将与借助标签的跳转指令联动测试，采取类似函数调用的格式测试<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">beq $0, $0, BranchforJ1_0</span><br><span class="line">Jump1_0:</span><br><span class="line">add $24, $31, $0</span><br><span class="line">jr $24</span><br><span class="line">BranchforJ1_0:</span><br><span class="line">jal Jump1_0</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h3 id="单周期与流水线"><a href="#单周期与流水线" class="headerlink" title="单周期与流水线"></a>单周期与流水线</h3><ul>
<li>对于单周期，单元测试已经可以完备测试，主要是因为单周期指令的数据通路在同一时钟周期仅有一条指令占有，各个指令之间的数据通路不互相影响</li>
<li>对于流水线，我们当然也可以采用单元测试的方式，不过首先指令的格式需要进行细微的调整<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lui $reg1, num1</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">ori $reg1, $reg1, num2</span><br><span class="line">nop</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<ul>
<li>通过插入<code>nop</code>消除指令之间的互相影响，达到测试<strong>数据通路以及部分控制单元</strong>的目的，但也仅仅只能测试这两个</li>
<li>对于<strong>转发电路以及冲突单元</strong>的测试还需依靠更加随机测试</li>
</ul>
</li>
</ul>
<hr>
<h2 id="randomTest"><a href="#randomTest" class="headerlink" title="randomTest"></a>randomTest</h2><h3 id="单周期"><a href="#单周期" class="headerlink" title="单周期"></a>单周期</h3><ul>
<li>单周期的随机测试看起来没什么用途，单元测试已经可以完备测试CPU了（<del>虽然我还是实现了随机测试</del>）</li>
</ul>
<h3 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h3><ul>
<li><p>首先说明，笔者还未将这部分内容加入测评机，仅仅是一个蓝图（）</p>
</li>
<li><p>单元测试有一个最大的缺点即，对于各类指令的测试往往需要<strong>预先赋值</strong>，这大大影响了指令序列的随机性，但是过于随机的指令序列将严重影响<code>store</code>、<code>branch</code>、<code>jump</code>类指令的测试效果</p>
<ul>
<li>这里引入一个寄存器数组、内存数组，在我们生成数据时跟踪，寄存器、内存的变化</li>
<li>再引入一张表（有多少个条件跳转指令则引入多少张表），记录某两个寄存器是否已经满足跳转关系</li>
<li><del>听起来有点像自己写mars</del>，我现在的函数是下面这个样子</li>
</ul>
</li>
<li><p>我们可以将一次随机测试分为数段，每段的开头进行预先赋值，保证一些条件（如至少8个寄存器处于极端数据等等），然后遇到终止条件结束这段测试，对不满足条件的部分重新赋值，终止条件可以如下：</p>
<ol>
<li>少于3个寄存器处于极端数据</li>
<li>少于3个寄存器处于<code>-65535 ~ 65535 + 3072</code></li>
<li>少于3个寄存器满足跳转关系</li>
</ol>
<ul>
<li>由此，我们跟踪了一部分数据，可以摆脱<strong>先赋值再操作</strong>这种单元测试，对于<code>lw</code>、<code>sw</code>之类的可以从条件2的寄存器中直接使用</li>
<li>向后跳转部分可以从满足条件关系中直接使用</li>
<li>同时保证了寄存器组数据的随机性</li>
</ul>
</li>
<li><p>如果单元测试足够充分的话，完全可以在随机测试中只测试指令之间的影响，不在乎<code>branch</code>类指令向前还是向后，不在乎<code>arth</code>类指令的数据是否包含极端，这些都是原本数据通路的问题，不必在randomTest中反复测试啦</p>
</li>
</ul>
<hr>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><ul>
<li>看起来流水线的数据生成还有很长一段路要走啊，希望能实现蓝图吧</li>
<li>数据生成与处理必然有诸多不当之处，希望大家指正。同时，如果在流水线数据方面有思路的同学，请和我交流（orz）<br><a href="https://github.com/Kie-Chi/co_test_builder.git">单周期测评机</a></li>
</ul>
]]></content>
      <categories>
        <category>计算机组成原理</category>
        <category>自动化测试</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>北航计算机组成P6</title>
    <url>/2024/12/08/CO_P6/</url>
    <content><![CDATA[<h1 id="北航计算机组成P6"><a href="#北航计算机组成P6" class="headerlink" title="北航计算机组成P6"></a>北航计算机组成P6</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>不要问我为什么先有P7再有P6，问就是忘了，一直忘到了现在，我真有点不记得课上的指令，反正我记得P6比P5简单来着</li>
</ul>
<hr>
<h2 id="课下复习"><a href="#课下复习" class="headerlink" title="课下复习"></a>课下复习</h2><hr>
<h2 id="课上测试"><a href="#课上测试" class="headerlink" title="课上测试"></a>课上测试</h2><hr>
]]></content>
      <categories>
        <category>计算机组成原理</category>
        <category>课下复习</category>
        <category>课上考试</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>北航计算机组成P5</title>
    <url>/2024/11/14/CO_P5/</url>
    <content><![CDATA[<h1 id="北航计算机组成P5"><a href="#北航计算机组成P5" class="headerlink" title="北航计算机组成P5"></a>北航计算机组成P5</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>P5工作量确实比P4大了不少，画设计图写文档一天半，搭CPU加测试一天，不过如果课下做好准备过了强测那课上100%能过甚至直接ak走人了</li>
</ul>
<h2 id="课下"><a href="#课下" class="headerlink" title="课下"></a>课下</h2><ul>
<li>写完P6已经1700行了，主要是我采取了针对指令的译码方式，所以整体代码量会稍微大一点（），主要这样我比较方便debug，所以就没改了</li>
</ul>
<h3 id="译码方式"><a href="#译码方式" class="headerlink" title="译码方式"></a>译码方式</h3><ul>
<li><p>集中式译码方式</p>
<ul>
<li>最大的优点就是<del>方便从P4改过来</del>，其实我选择集中式译码的理由是方便添加一些指令，而且译码行为在D级就可以全完成，所以如果加入一些额外的指令信号不会出现高阻态或者其他的比较抽象的错误（分布式译码课上如果出锅了可能就是这个原因）</li>
<li>最大的缺点就是需要流水的信号实在是太多了，因为所有要用的信号必须在D级就全部生成完毕，所以向E级就会流水各种信号，不过课下认真设计，仔细连线保证没有bug那在课上也没啥，反正课上最多增加两三个新增的端口，反正不会一次写两个寄存器（）</li>
</ul>
</li>
<li><p>分布式译码                                                               </p>
<ul>
<li>最大的优点就是流水的东西少，几乎可以只流水指令，然后每次在接收到指令之后再译码，从里面接出需要的信号，然后提供给这个级</li>
<li>缺点是，缺点是啥来着，我刚开始不想用分布式译码主要是觉得每个级单独译出$T_{new}$信号什么的特别复杂，还不如刚开始就全部翻译处出来了，但是往届学长还是有很多优秀的分布式译码框架的，只是我没有去参考</li>
</ul>
</li>
<li><p>译码语句没有选<code>assign</code>，那和我搭logisim有什么区别（怒），我verilog就要用不一样的东西，事实是不如<code>assign</code>，代码量还是太大了，不过课上加指令的适合比较方便，毕竟每个指令之间不会互相影响</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">    NPCSel = `NPC_normal;</span><br><span class="line">    ExtOp = `EXT_zero;</span><br><span class="line">    GRFA3Sel = `GRFA3_zero;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">case</span>(instr) <span class="keyword">begin</span></span><br><span class="line">    `Op_add: <span class="keyword">begin</span></span><br><span class="line">        GRFA3Sel = `GRFA3_rd;</span><br><span class="line"></span><br><span class="line">        calr = <span class="number">1&#x27;b1</span>;</span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure></li>
<li><p>事实上也可以像logisim一样用与或门阵列的方式，但是我不使用的原因是P3课上加指令的时候加的太慢而且老是搭错线。。。，优点是代码量压缩程度很优秀，尤其适合P6支持更多指令的时候</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">wire</span> add, sub.....;</span><br><span class="line"><span class="keyword">wire</span>[<span class="number">1</span>: <span class="number">0</span>] GRFA3Sel...;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> add = (Opcode == <span class="number">6&#x27;b0</span>) &amp; (Funct == `Func_add);</span><br><span class="line"><span class="keyword">assign</span> GRFA3Sel[<span class="number">0</span>] = (add | ....)</span><br><span class="line"><span class="keyword">assign</span> GRFA3Sel[<span class="number">1</span>] = ....</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">assign</span> GRFA3Sel = (add | ....) ? <span class="number">2&#x27;b00</span> :</span><br><span class="line">                  (ori | .....) ? <span class="number">2&#x27;b01</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="数据通路设计"><a href="#数据通路设计" class="headerlink" title="数据通路设计"></a>数据通路设计</h3><h4 id="F"><a href="#F" class="headerlink" title="F"></a><code>F</code></h4><h5 id="PC"><a href="#PC" class="headerlink" title="PC"></a><code>PC</code></h5><ul>
<li>同理我们先建模<del>最简单</del>(最重要)的PC寄存器，理由同单周期CPU，我们需要PC寄存器指向当前的指令地址<table>
<thead>
<tr>
<th align="center">端口</th>
<th align="center">位宽</th>
<th align="center">方向</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">clk</td>
<td align="center">1</td>
<td align="center">input</td>
<td align="center">时钟信号</td>
</tr>
<tr>
<td align="center">reset</td>
<td align="center">1</td>
<td align="center">input</td>
<td align="center"><strong>同步</strong>复位信号</td>
</tr>
<tr>
<td align="center">we</td>
<td align="center">1</td>
<td align="center">input</td>
<td align="center">PC寄存器使能信号</td>
</tr>
<tr>
<td align="center">NPC[31:0]</td>
<td align="center">32</td>
<td align="center">input</td>
<td align="center">传入更新的值</td>
</tr>
<tr>
<td align="center">PC[31:0]</td>
<td align="center">32</td>
<td align="center">output</td>
<td align="center">传出目前的PC值</td>
</tr>
</tbody></table>
</li>
</ul>
<h5 id="IM"><a href="#IM" class="headerlink" title="IM"></a><code>IM</code></h5><ul>
<li>指令寄存器，同单周期CPU，没有任何改变  <table>
<thead>
<tr>
<th align="center">端口</th>
<th align="center">位宽</th>
<th align="center">方向</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">PC[31:0]</td>
<td align="center">32</td>
<td align="center">input</td>
<td align="center">传入PC值供取指</td>
</tr>
<tr>
<td align="center">Instr[31:0]</td>
<td align="center">32</td>
<td align="center">input</td>
<td align="center">获得指令</td>
</tr>
</tbody></table>
</li>
</ul>
<hr>
<h4 id="D"><a href="#D" class="headerlink" title="D"></a><code>D</code></h4><h5 id="D-REG"><a href="#D-REG" class="headerlink" title="D_REG"></a><code>D_REG</code></h5><ul>
<li><code>F/D</code>流水寄存器，将F级的信息传递给D级<table>
<thead>
<tr>
<th align="center">端口</th>
<th align="center">位宽</th>
<th align="center">方向</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">clk</td>
<td align="center">1</td>
<td align="center">input</td>
<td align="center">时钟信号</td>
</tr>
<tr>
<td align="center">reset</td>
<td align="center">1</td>
<td align="center">input</td>
<td align="center"><strong>同步</strong>复位信号</td>
</tr>
<tr>
<td align="center">we</td>
<td align="center">1</td>
<td align="center">input</td>
<td align="center">D流水寄存器使能信号</td>
</tr>
<tr>
<td align="center">F_PC[31:0]</td>
<td align="center">32</td>
<td align="center">input</td>
<td align="center">F级传入PC值</td>
</tr>
<tr>
<td align="center">F_Instr[31:0]</td>
<td align="center">32</td>
<td align="center">input</td>
<td align="center">F级传入指令</td>
</tr>
<tr>
<td align="center">D_PC[31:0]</td>
<td align="center">32</td>
<td align="center">output</td>
<td align="center">传入D级PC值</td>
</tr>
<tr>
<td align="center">D_Instr[31:0]</td>
<td align="center">32</td>
<td align="center">output</td>
<td align="center">传入D级别PC值</td>
</tr>
</tbody></table>
</li>
</ul>
<h5 id="IM-SPL"><a href="#IM-SPL" class="headerlink" title="IM_SPL"></a><code>IM_SPL</code></h5><ul>
<li>D级分线器，将指令分为若干部分<table>
<thead>
<tr>
<th align="center">端口</th>
<th align="center">位宽</th>
<th align="center">方向</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Instr[31:0]</td>
<td align="center">32</td>
<td align="center">input</td>
<td align="center">传入解析指令</td>
</tr>
<tr>
<td align="center">Opcode[5:0]</td>
<td align="center">6</td>
<td align="center">output</td>
<td align="center">指令操作码</td>
</tr>
<tr>
<td align="center">Funct[5:0]</td>
<td align="center">6</td>
<td align="center">output</td>
<td align="center">R型指令函数操作码</td>
</tr>
<tr>
<td align="center">Rs[4:0]</td>
<td align="center">5</td>
<td align="center">output</td>
<td align="center">源寄存器</td>
</tr>
<tr>
<td align="center">Rt[4:0]</td>
<td align="center">5</td>
<td align="center">output</td>
<td align="center">目标寄存器</td>
</tr>
<tr>
<td align="center">Rd[4:0]</td>
<td align="center">5</td>
<td align="center">output</td>
<td align="center">目的寄存器</td>
</tr>
<tr>
<td align="center">Shamt[4:0]</td>
<td align="center">5</td>
<td align="center">output</td>
<td align="center">移位值</td>
</tr>
<tr>
<td align="center">Imm_i[15:0]</td>
<td align="center">16</td>
<td align="center">output</td>
<td align="center">I型指令立即数</td>
</tr>
<tr>
<td align="center">Imm_j[25:0]</td>
<td align="center">26</td>
<td align="center">output</td>
<td align="center">J型指令立即数</td>
</tr>
</tbody></table>
</li>
</ul>
<h5 id="GRF"><a href="#GRF" class="headerlink" title="GRF"></a><code>GRF</code></h5><ul>
<li>D级寄存器堆，取出对应寄存器值<table>
<thead>
<tr>
<th align="center">端口</th>
<th align="center">位宽</th>
<th align="center">方向</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">clk</td>
<td align="center">1</td>
<td align="center">input</td>
<td align="center">时钟信号</td>
</tr>
<tr>
<td align="center">reset</td>
<td align="center">1</td>
<td align="center">input</td>
<td align="center"><strong>同步</strong>复位信号</td>
</tr>
<tr>
<td align="center">A1[4:0]</td>
<td align="center">5</td>
<td align="center">input</td>
<td align="center">第一个读寄存器</td>
</tr>
<tr>
<td align="center">A2[4:0]</td>
<td align="center">5</td>
<td align="center">input</td>
<td align="center">第二个读寄存器</td>
</tr>
<tr>
<td align="center">A3[4:0] (<code>W</code>)</td>
<td align="center">5</td>
<td align="center">input</td>
<td align="center">写寄存器</td>
</tr>
<tr>
<td align="center">WD[31:0] (<code>W</code>)</td>
<td align="center">32</td>
<td align="center">input</td>
<td align="center">寄存器写入值</td>
</tr>
<tr>
<td align="center">RD1[31:0]</td>
<td align="center">32</td>
<td align="center">output</td>
<td align="center">读寄存器值(已内部转发)</td>
</tr>
<tr>
<td align="center">RD2[31:0]</td>
<td align="center">32</td>
<td align="center">output</td>
<td align="center">读寄存器值(已内部转发)</td>
</tr>
</tbody></table>
</li>
</ul>
<h5 id="EXT"><a href="#EXT" class="headerlink" title="EXT"></a><code>EXT</code></h5><ul>
<li>D级拓展单元<ul>
<li><p>端口定义</p>
<table>
<thead>
<tr>
<th align="center">端口</th>
<th align="center">位宽</th>
<th align="center">方向</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Imm[15:0]</td>
<td align="center">16</td>
<td align="center">input</td>
<td align="center">拓展立即数</td>
</tr>
<tr>
<td align="center">ExtOp[1:0]</td>
<td align="center">2</td>
<td align="center">input</td>
<td align="center">控制立即数拓展</td>
</tr>
<tr>
<td align="center">Ext_imm[31:0]</td>
<td align="center">32</td>
<td align="center">input</td>
<td align="center">拓展后立即数</td>
</tr>
</tbody></table>
</li>
<li><p>控制信号定义</p>
<table>
<thead>
<tr>
<th align="center">信号名</th>
<th align="center">取值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">EXT_zero</td>
<td align="center">2’b00</td>
<td align="center">控制ExtOp信号零拓展</td>
</tr>
<tr>
<td align="center">EXT_sign</td>
<td align="center">2’b01</td>
<td align="center">控制ExtOp信号符号位拓展</td>
</tr>
<tr>
<td align="center">EXT_lui</td>
<td align="center">2’b10</td>
<td align="center">控制ExtOp信号高位加载</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h5 id="NPC"><a href="#NPC" class="headerlink" title="NPC"></a><code>NPC</code></h5><ul>
<li>D级次地址计算单元<ul>
<li><p>端口定义</p>
<table>
<thead>
<tr>
<th align="center">端口</th>
<th align="center">位宽</th>
<th align="center">方向</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">F_PC[31:0]</td>
<td align="center">32</td>
<td align="center">input</td>
<td align="center">F级PC值</td>
</tr>
<tr>
<td align="center">D_PC[31:0]</td>
<td align="center">32</td>
<td align="center">input</td>
<td align="center">D级PC值</td>
</tr>
<tr>
<td align="center">Rs[31:0]</td>
<td align="center">32</td>
<td align="center">input</td>
<td align="center">跳转寄存器值</td>
</tr>
<tr>
<td align="center">Imm[25:0]</td>
<td align="center">26</td>
<td align="center">input</td>
<td align="center">立即数</td>
</tr>
<tr>
<td align="center">NpcSel[1:0]</td>
<td align="center">2</td>
<td align="center">input</td>
<td align="center">控制NPC</td>
</tr>
<tr>
<td align="center">NPC[31:0]</td>
<td align="center">32</td>
<td align="center">output</td>
<td align="center">次地址</td>
</tr>
</tbody></table>
</li>
<li><p>控制信号定义</p>
<table>
<thead>
<tr>
<th align="center">信号名</th>
<th align="center">取值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">NPC_normal</td>
<td align="center">2’b00</td>
<td align="center">NpcSel正常跳转</td>
</tr>
<tr>
<td align="center">NPC_branch</td>
<td align="center">2’b01</td>
<td align="center">NpcSel条件跳转</td>
</tr>
<tr>
<td align="center">NPC_jadder</td>
<td align="center">2’b10</td>
<td align="center">NpcSel跳转地址</td>
</tr>
<tr>
<td align="center">NPC_jrs</td>
<td align="center">2’b11</td>
<td align="center">NpcSel跳转寄存器</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h5 id="CMP"><a href="#CMP" class="headerlink" title="CMP"></a><code>CMP</code></h5><ul>
<li>D级branch指令前移比较器<ul>
<li>端口定义<table>
<thead>
<tr>
<th align="center">端口</th>
<th align="center">位宽</th>
<th align="center">方向</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Rs_val[31:0]</td>
<td align="center">32</td>
<td align="center">input</td>
<td align="center">rs寄存器读出值</td>
</tr>
<tr>
<td align="center">Rt_val[31:0]</td>
<td align="center">32</td>
<td align="center">input</td>
<td align="center">rt寄存器读出值</td>
</tr>
<tr>
<td align="center">CmpOp</td>
<td align="center">1</td>
<td align="center">input</td>
<td align="center">比较类型</td>
</tr>
<tr>
<td align="center">Flag</td>
<td align="center">1</td>
<td align="center">output</td>
<td align="center">比较结果</td>
</tr>
</tbody></table>
</li>
<li>控制信号定义<table>
<thead>
<tr>
<th align="center">信号名</th>
<th align="center">取值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">CMP_eq</td>
<td align="center">1’b0</td>
<td align="center">控制CmpOp信号相等比较</td>
</tr>
<tr>
<td align="center">CMP_ne</td>
<td align="center">1’b1</td>
<td align="center">控制CmpOp信号不等比较</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h5 id="Control"><a href="#Control" class="headerlink" title="Control"></a><code>Control</code></h5><ul>
<li>D级集中译码器<table>
<thead>
<tr>
<th align="center">端口</th>
<th align="center">位宽</th>
<th align="center">方向</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Opcode[5:0]</td>
<td align="center">6</td>
<td align="center">input</td>
<td align="center">指令操作码</td>
</tr>
<tr>
<td align="center">Funct[5:0]</td>
<td align="center">6</td>
<td align="center">input</td>
<td align="center">函数码</td>
</tr>
<tr>
<td align="center">Tuse_rs[1:0]</td>
<td align="center">2</td>
<td align="center">output</td>
<td align="center">rs寄存器的Tuse</td>
</tr>
<tr>
<td align="center">Tuse_rt[1:0]</td>
<td align="center">2</td>
<td align="center">output</td>
<td align="center">rt寄存器的Tuse</td>
</tr>
<tr>
<td align="center">Tnew[1:0]</td>
<td align="center">2</td>
<td align="center">output</td>
<td align="center">指令Tnew</td>
</tr>
<tr>
<td align="center">NpcSel[1:0]</td>
<td align="center">2</td>
<td align="center">output</td>
<td align="center">控制NPC</td>
</tr>
<tr>
<td align="center">CmpOp</td>
<td align="center">1</td>
<td align="center">output</td>
<td align="center">控制CMP</td>
</tr>
<tr>
<td align="center">ExtOp[1:0]</td>
<td align="center">2</td>
<td align="center">output</td>
<td align="center">控制EXT</td>
</tr>
<tr>
<td align="center">GRFA3Sel[1:0]</td>
<td align="center">2</td>
<td align="center">output</td>
<td align="center">控制GRFA3Mux</td>
</tr>
<tr>
<td align="center">ALUASel</td>
<td align="center">1</td>
<td align="center">output</td>
<td align="center">控制ALUAMux</td>
</tr>
<tr>
<td align="center">ALUBSel[1:0]</td>
<td align="center">2</td>
<td align="center">output</td>
<td align="center">控制ALUBMux</td>
</tr>
<tr>
<td align="center">ALUOp[1:0]</td>
<td align="center">2</td>
<td align="center">output</td>
<td align="center">控制ALU</td>
</tr>
<tr>
<td align="center">DMWe</td>
<td align="center">1</td>
<td align="center">output</td>
<td align="center">DM使能</td>
</tr>
<tr>
<td align="center">DMOp[2:0]</td>
<td align="center">3</td>
<td align="center">output</td>
<td align="center">DM写入方式</td>
</tr>
<tr>
<td align="center">GRFWDSel[1:0]</td>
<td align="center">2</td>
<td align="center">output</td>
<td align="center">控制GRFWDMux</td>
</tr>
</tbody></table>
</li>
</ul>
<h5 id="MUX"><a href="#MUX" class="headerlink" title="MUX"></a><code>MUX</code></h5><ul>
<li><code>GRFA3Mux</code><ul>
<li>选择GRF写入地址的多路选择器<table>
<thead>
<tr>
<th align="center">信号名</th>
<th align="center">取值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">GRFA3_rt</td>
<td align="center">2’b00</td>
<td align="center">选择rt寄存器值</td>
</tr>
<tr>
<td align="center">GRFA3_rd</td>
<td align="center">2’b01</td>
<td align="center">选择rd寄存器值</td>
</tr>
<tr>
<td align="center">GRFA3_ra</td>
<td align="center">2’b10</td>
<td align="center">选择$ra寄存器</td>
</tr>
<tr>
<td align="center">GRFA3_zero</td>
<td align="center">2’b11</td>
<td align="center">默认不写寄存器</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><code>RSFDMux</code><ul>
<li>对于读出的rs寄存器进行转发</li>
</ul>
</li>
<li><code>RTFDMux</code><ul>
<li>对于读出的rt寄存器进行转发</li>
</ul>
</li>
</ul>
<hr>
<h4 id="E"><a href="#E" class="headerlink" title="E"></a><code>E</code></h4><h5 id="E-REG"><a href="#E-REG" class="headerlink" title="E_REG"></a><code>E_REG</code></h5><ul>
<li><p><code>D/E</code>流水寄存器 </p>
<table>
<thead>
<tr>
<th align="center">端口</th>
<th align="center">位宽</th>
<th align="center">方向</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">clk</td>
<td align="center">1</td>
<td align="center">input</td>
<td align="center">时钟信号</td>
</tr>
<tr>
<td align="center">reset</td>
<td align="center">1</td>
<td align="center">input</td>
<td align="center"><strong>同步</strong>复位信号</td>
</tr>
<tr>
<td align="center">we</td>
<td align="center">1</td>
<td align="center">input</td>
<td align="center">写使能信号</td>
</tr>
<tr>
<td align="center">D_rs[4:0]</td>
<td align="center">5</td>
<td align="center">input</td>
<td align="center">D级rs编号</td>
</tr>
<tr>
<td align="center">D_rt[4:0]</td>
<td align="center">5</td>
<td align="center">input</td>
<td align="center">D级rt编号</td>
</tr>
<tr>
<td align="center">D_a3[4:0]</td>
<td align="center">5</td>
<td align="center">input</td>
<td align="center">D级A3</td>
</tr>
<tr>
<td align="center">D_rs_val[31:0]</td>
<td align="center">32</td>
<td align="center">input</td>
<td align="center">D级rs寄存器值</td>
</tr>
<tr>
<td align="center">D_rt_val[31:0]</td>
<td align="center">32</td>
<td align="center">input</td>
<td align="center">D级rt寄存器值</td>
</tr>
<tr>
<td align="center">D_ext_imm[31:0]</td>
<td align="center">32</td>
<td align="center">input</td>
<td align="center">D级ext_imm值</td>
</tr>
<tr>
<td align="center">D_shamt[4:0]</td>
<td align="center">5</td>
<td align="center">input</td>
<td align="center">D级shamt值</td>
</tr>
<tr>
<td align="center">D_pcwith8[31:0]</td>
<td align="center">32</td>
<td align="center">input</td>
<td align="center">D级PC+8</td>
</tr>
<tr>
<td align="center">E_rs[4:0]</td>
<td align="center">5</td>
<td align="center">output</td>
<td align="center">E级rs编号</td>
</tr>
<tr>
<td align="center">E_rt[4:0]</td>
<td align="center">5</td>
<td align="center">output</td>
<td align="center">E级rt编号</td>
</tr>
<tr>
<td align="center">E_a3[4:0]</td>
<td align="center">5</td>
<td align="center">output</td>
<td align="center">E级A3</td>
</tr>
<tr>
<td align="center">E_rs_val[31:0]</td>
<td align="center">32</td>
<td align="center">output</td>
<td align="center">E级rs寄存器值</td>
</tr>
<tr>
<td align="center">E_rt_val[31:0]</td>
<td align="center">32</td>
<td align="center">output</td>
<td align="center">E级rt寄存器值</td>
</tr>
<tr>
<td align="center">E_ext_imm[31:0]</td>
<td align="center">32</td>
<td align="center">output</td>
<td align="center">E级ext_imm值</td>
</tr>
<tr>
<td align="center">E_shamt[4:0]</td>
<td align="center">5</td>
<td align="center">output</td>
<td align="center">E级shamt值</td>
</tr>
<tr>
<td align="center">E_pcwith8[31:0]</td>
<td align="center">32</td>
<td align="center">output</td>
<td align="center">E级PC+8</td>
</tr>
<tr>
<td align="center">D_ALUASel</td>
<td align="center">1</td>
<td align="center">input</td>
<td align="center">控制ALUAMux</td>
</tr>
<tr>
<td align="center">D_ALUBSel[1:0]</td>
<td align="center">2</td>
<td align="center">input</td>
<td align="center">控制ALUBMux</td>
</tr>
<tr>
<td align="center">D_ALUOp[1:0]</td>
<td align="center">2</td>
<td align="center">input</td>
<td align="center">控制ALU</td>
</tr>
<tr>
<td align="center">D_DMWe</td>
<td align="center">1</td>
<td align="center">input</td>
<td align="center">DM使能</td>
</tr>
<tr>
<td align="center">D_DMOp[2:0]</td>
<td align="center">3</td>
<td align="center">input</td>
<td align="center">DM写入方式</td>
</tr>
<tr>
<td align="center">D_GRFWDSel[1:0]</td>
<td align="center">2</td>
<td align="center">input</td>
<td align="center">控制GRFWDMux</td>
</tr>
<tr>
<td align="center">E_ALUASel</td>
<td align="center">1</td>
<td align="center">output</td>
<td align="center">控制ALUAMux</td>
</tr>
<tr>
<td align="center">E_ALUBSel[1:0]</td>
<td align="center">2</td>
<td align="center">output</td>
<td align="center">控制ALUBMux</td>
</tr>
<tr>
<td align="center">E_ALUOp[1:0]</td>
<td align="center">2</td>
<td align="center">output</td>
<td align="center">控制ALU</td>
</tr>
<tr>
<td align="center">E_DMWe</td>
<td align="center">1</td>
<td align="center">output</td>
<td align="center">DM使能</td>
</tr>
<tr>
<td align="center">E_DMOp[2:0]</td>
<td align="center">3</td>
<td align="center">output</td>
<td align="center">DM写入方式</td>
</tr>
<tr>
<td align="center">E_GRFWDSel[1:0]</td>
<td align="center">2</td>
<td align="center">output</td>
<td align="center">控制GRFWDMux</td>
</tr>
<tr>
<td align="center">D_Tnew[1:0]</td>
<td align="center">2</td>
<td align="center">input</td>
<td align="center">Tnew</td>
</tr>
<tr>
<td align="center">E_Tnew[1:0]</td>
<td align="center">2</td>
<td align="center">output</td>
<td align="center">Tnew</td>
</tr>
</tbody></table>
</li>
</ul>
<h5 id="ALU"><a href="#ALU" class="headerlink" title="ALU"></a><code>ALU</code></h5><ul>
<li>E级计算单元<ul>
<li><p>端口定义</p>
<table>
<thead>
<tr>
<th align="center">端口</th>
<th align="center">位宽</th>
<th align="center">方向</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A[31:0]</td>
<td align="center">32</td>
<td align="center">input</td>
<td align="center">ALU第一个操作数</td>
</tr>
<tr>
<td align="center">B[31:0]</td>
<td align="center">32</td>
<td align="center">input</td>
<td align="center">ALU第二个操作数</td>
</tr>
<tr>
<td align="center">ALUOp[1:0]</td>
<td align="center">2</td>
<td align="center">input</td>
<td align="center">ALU进行的操作</td>
</tr>
<tr>
<td align="center">ALU_out[31:0]</td>
<td align="center">32</td>
<td align="center">output</td>
<td align="center">ALU结果数</td>
</tr>
</tbody></table>
</li>
<li><p>控制信号定义</p>
<table>
<thead>
<tr>
<th align="center">信号名</th>
<th align="center">取值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ALU_add</td>
<td align="center">2’b00</td>
<td align="center">加法操作</td>
</tr>
<tr>
<td align="center">ALU_sub</td>
<td align="center">2’b01</td>
<td align="center">减法操作</td>
</tr>
<tr>
<td align="center">ALU_or</td>
<td align="center">2’b10</td>
<td align="center">或运算操作</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h5 id="MUX-1"><a href="#MUX-1" class="headerlink" title="MUX"></a><code>MUX</code></h5><ul>
<li><p><code>ALUAMux</code></p>
<table>
<thead>
<tr>
<th align="center">信号名</th>
<th align="center">取值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ALUA_rs</td>
<td align="center">2’b0</td>
<td align="center">选择rs寄存器（一般而言）</td>
</tr>
<tr>
<td align="center">ALUA_rt</td>
<td align="center">2’b1</td>
<td align="center">选择rt寄存器（移位操作）</td>
</tr>
</tbody></table>
</li>
<li><p><code>ALUBMux</code></p>
<table>
<thead>
<tr>
<th align="center">信号名</th>
<th align="center">取值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ALUB_rt</td>
<td align="center">2’b00</td>
<td align="center">选择rt寄存器（一般R型）</td>
</tr>
<tr>
<td align="center">ALUB_imm</td>
<td align="center">2’b01</td>
<td align="center">选择ext_imm</td>
</tr>
<tr>
<td align="center">ALUB_shamt</td>
<td align="center">2’b10</td>
<td align="center">选择shamt</td>
</tr>
<tr>
<td align="center">ALUB_rs</td>
<td align="center">2’b11</td>
<td align="center">选择rs寄存器（R型移位）</td>
</tr>
</tbody></table>
</li>
<li><p><code>RSFEMux</code></p>
</li>
<li><p><code>RTFEMux</code></p>
</li>
</ul>
<hr>
<h4 id="M"><a href="#M" class="headerlink" title="M"></a><code>M</code></h4><h5 id="M-REG"><a href="#M-REG" class="headerlink" title="M_REG"></a><code>M_REG</code></h5><ul>
<li><code>E/M</code>流水寄存器<table>
<thead>
<tr>
<th align="center">端口</th>
<th align="center">位宽</th>
<th align="center">方向</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">clk</td>
<td align="center">1</td>
<td align="center">input</td>
<td align="center">时钟信号</td>
</tr>
<tr>
<td align="center">reset</td>
<td align="center">1</td>
<td align="center">input</td>
<td align="center"><strong>同步</strong>复位信号</td>
</tr>
<tr>
<td align="center">we</td>
<td align="center">1</td>
<td align="center">input</td>
<td align="center">写使能信号</td>
</tr>
<tr>
<td align="center">E_rt[4:0]</td>
<td align="center">5</td>
<td align="center">input</td>
<td align="center">rt寄存器的编号</td>
</tr>
<tr>
<td align="center">E_rt_val[31:0]</td>
<td align="center">32</td>
<td align="center">input</td>
<td align="center">rt寄存器的值</td>
</tr>
<tr>
<td align="center">E_alu_out[31:0]</td>
<td align="center">32</td>
<td align="center">input</td>
<td align="center">ALU运算结果</td>
</tr>
<tr>
<td align="center">E_a3[4:0]</td>
<td align="center">5</td>
<td align="center">input</td>
<td align="center">A3结果</td>
</tr>
<tr>
<td align="center">E_imm[31:0]</td>
<td align="center">32</td>
<td align="center">input</td>
<td align="center">lui结果</td>
</tr>
<tr>
<td align="center">E_pcwith8[31:0]</td>
<td align="center">32</td>
<td align="center">input</td>
<td align="center">PC+8结果</td>
</tr>
<tr>
<td align="center">M_rt[4:0]</td>
<td align="center">5</td>
<td align="center">output</td>
<td align="center">rt寄存器的编号</td>
</tr>
<tr>
<td align="center">M_rt_val[31:0]</td>
<td align="center">32</td>
<td align="center">output</td>
<td align="center">rt寄存器的值</td>
</tr>
<tr>
<td align="center">M_alu_out[31:0]</td>
<td align="center">32</td>
<td align="center">output</td>
<td align="center">ALU运算结果</td>
</tr>
<tr>
<td align="center">M_a3[4:0]</td>
<td align="center">5</td>
<td align="center">output</td>
<td align="center">A3结果</td>
</tr>
<tr>
<td align="center">M_imm[31:0]</td>
<td align="center">32</td>
<td align="center">output</td>
<td align="center">lui结果</td>
</tr>
<tr>
<td align="center">M_pcwith8[31:0]</td>
<td align="center">32</td>
<td align="center">output</td>
<td align="center">PC+8结果</td>
</tr>
<tr>
<td align="center">E_DMWe</td>
<td align="center">1</td>
<td align="center">input</td>
<td align="center">DM写使能信号</td>
</tr>
<tr>
<td align="center">E_DMOp[2:0]</td>
<td align="center">3</td>
<td align="center">input</td>
<td align="center">DM选择</td>
</tr>
<tr>
<td align="center">E_GRFWDSel[1:0]</td>
<td align="center">2</td>
<td align="center">input</td>
<td align="center">选择GRFWD</td>
</tr>
<tr>
<td align="center">M_DMWe</td>
<td align="center">1</td>
<td align="center">input</td>
<td align="center">DM写使能信号</td>
</tr>
<tr>
<td align="center">M_DMOp[2:0]</td>
<td align="center">3</td>
<td align="center">input</td>
<td align="center">DM选择</td>
</tr>
<tr>
<td align="center">M_GRFWDSel[1:0]</td>
<td align="center">2</td>
<td align="center">input</td>
<td align="center">选择GRFWD</td>
</tr>
<tr>
<td align="center">E_Tnew[1:0]</td>
<td align="center">2</td>
<td align="center">input</td>
<td align="center">Tnew</td>
</tr>
<tr>
<td align="center">M_Tnew[1:0]</td>
<td align="center">2</td>
<td align="center">input</td>
<td align="center">Tnew</td>
</tr>
</tbody></table>
</li>
</ul>
<h5 id="DM"><a href="#DM" class="headerlink" title="DM"></a><code>DM</code></h5><ul>
<li>M级数据存储器<ul>
<li><p>端口定义</p>
<table>
<thead>
<tr>
<th align="center">端口</th>
<th align="center">位宽</th>
<th align="center">方向</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">clk</td>
<td align="center">1</td>
<td align="center">input</td>
<td align="center">时钟信号</td>
</tr>
<tr>
<td align="center">reset</td>
<td align="center">1</td>
<td align="center">input</td>
<td align="center"><strong>同步</strong>复位信号</td>
</tr>
<tr>
<td align="center">we</td>
<td align="center">1</td>
<td align="center">input</td>
<td align="center">写使能</td>
</tr>
<tr>
<td align="center">Adder[31:0]</td>
<td align="center">32</td>
<td align="center">input</td>
<td align="center">地址</td>
</tr>
<tr>
<td align="center">WD[31:0]</td>
<td align="center">32</td>
<td align="center">input</td>
<td align="center">写入值</td>
</tr>
<tr>
<td align="center">RD[31:0]</td>
<td align="center">32</td>
<td align="center">output</td>
<td align="center">读出值</td>
</tr>
<tr>
<td align="center">DMOp[2:0]</td>
<td align="center">3</td>
<td align="center">input</td>
<td align="center">选择DM读写方式</td>
</tr>
</tbody></table>
</li>
<li><p>控制信号定义</p>
<table>
<thead>
<tr>
<th align="center">信号名</th>
<th align="center">取值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">DM_w</td>
<td align="center">3’b000</td>
<td align="center">字单位写入读出</td>
</tr>
<tr>
<td align="center">DM_h</td>
<td align="center">3’b001</td>
<td align="center">半字单位写入，符号拓展读出</td>
</tr>
<tr>
<td align="center">DM_hu</td>
<td align="center">3’b010</td>
<td align="center">半字单位写入，无符号拓展读出</td>
</tr>
<tr>
<td align="center">DM_b</td>
<td align="center">3’b011</td>
<td align="center">字节单位写入，符号拓展读出</td>
</tr>
<tr>
<td align="center">DM_bu</td>
<td align="center">3’b100</td>
<td align="center">字节单位写入，无符号拓展读出</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h5 id="MUX-2"><a href="#MUX-2" class="headerlink" title="MUX"></a><code>MUX</code></h5><ul>
<li><code>RTFMMux</code></li>
</ul>
<hr>
<h4 id="W"><a href="#W" class="headerlink" title="W"></a><code>W</code></h4><h5 id="W-REG"><a href="#W-REG" class="headerlink" title="W_REG"></a><code>W_REG</code></h5><ul>
<li><code>M/W</code>级流水寄存器<table>
<thead>
<tr>
<th align="center">端口</th>
<th align="center">位宽</th>
<th align="center">方向</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">clk</td>
<td align="center">1</td>
<td align="center">input</td>
<td align="center">时钟信号</td>
</tr>
<tr>
<td align="center">reset</td>
<td align="center">1</td>
<td align="center">input</td>
<td align="center"><strong>同步</strong>复位信号</td>
</tr>
<tr>
<td align="center">we</td>
<td align="center">1</td>
<td align="center">input</td>
<td align="center">写使能信号</td>
</tr>
<tr>
<td align="center">M_alu_out[31:0]</td>
<td align="center">32</td>
<td align="center">input</td>
<td align="center">ALU运算结果</td>
</tr>
<tr>
<td align="center">M_dm_rd[31:0]</td>
<td align="center">32</td>
<td align="center">input</td>
<td align="center">内存读出结果</td>
</tr>
<tr>
<td align="center">M_a3[4:0]</td>
<td align="center">5</td>
<td align="center">input</td>
<td align="center">A3结果</td>
</tr>
<tr>
<td align="center">M_imm[31:0]</td>
<td align="center">32</td>
<td align="center">input</td>
<td align="center">lui结果</td>
</tr>
<tr>
<td align="center">M_pcwith8[31:0]</td>
<td align="center">32</td>
<td align="center">input</td>
<td align="center">PC+8结果</td>
</tr>
<tr>
<td align="center">W_alu_out[31:0]</td>
<td align="center">32</td>
<td align="center">output</td>
<td align="center">ALU运算结果</td>
</tr>
<tr>
<td align="center">W_dm_rd[31:0]</td>
<td align="center">32</td>
<td align="center">output</td>
<td align="center">内存读出结果</td>
</tr>
<tr>
<td align="center">W_a3[4:0]</td>
<td align="center">5</td>
<td align="center">output</td>
<td align="center">A3结果</td>
</tr>
<tr>
<td align="center">W_imm[31:0]</td>
<td align="center">32</td>
<td align="center">output</td>
<td align="center">lui结果</td>
</tr>
<tr>
<td align="center">W_pcwith8[31:0]</td>
<td align="center">32</td>
<td align="center">output</td>
<td align="center">PC+8结果</td>
</tr>
<tr>
<td align="center">M_GRFWDSel[1:0]</td>
<td align="center">2</td>
<td align="center">input</td>
<td align="center">选择GRFWD</td>
</tr>
<tr>
<td align="center">W_GRFWDSel[1:0]</td>
<td align="center">2</td>
<td align="center">output</td>
<td align="center">选择GRFWD</td>
</tr>
</tbody></table>
</li>
</ul>
<h5 id="GRF-1"><a href="#GRF-1" class="headerlink" title="GRF"></a><code>GRF</code></h5><ul>
<li><p>W级寄存器堆</p>
<table>
<thead>
<tr>
<th align="center">端口</th>
<th align="center">位宽</th>
<th align="center">方向</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">clk</td>
<td align="center">1</td>
<td align="center">input</td>
<td align="center">时钟信号</td>
</tr>
<tr>
<td align="center">reset</td>
<td align="center">1</td>
<td align="center">input</td>
<td align="center"><strong>同步</strong>复位信号</td>
</tr>
<tr>
<td align="center">A1[4:0] (<code>D</code>)</td>
<td align="center">5</td>
<td align="center">input</td>
<td align="center">第一个读寄存器</td>
</tr>
<tr>
<td align="center">A2[4:0] (<code>D</code>)</td>
<td align="center">5</td>
<td align="center">input</td>
<td align="center">第二个读寄存器</td>
</tr>
<tr>
<td align="center">A3[4:0]</td>
<td align="center">5</td>
<td align="center">input</td>
<td align="center">写寄存器</td>
</tr>
<tr>
<td align="center">WD[31:0]</td>
<td align="center">32</td>
<td align="center">input</td>
<td align="center">寄存器写入值</td>
</tr>
<tr>
<td align="center">RD1[31:0] (<code>D</code>)</td>
<td align="center">32</td>
<td align="center">output</td>
<td align="center">读寄存器值(已内部转发)</td>
</tr>
<tr>
<td align="center">RD2[31:0] (<code>D</code>)</td>
<td align="center">32</td>
<td align="center">output</td>
<td align="center">读寄存器值(已内部转发)</td>
</tr>
</tbody></table>
</li>
</ul>
<h5 id="MUX-3"><a href="#MUX-3" class="headerlink" title="MUX"></a><code>MUX</code></h5><ul>
<li><p><code>GRFWDMux</code></p>
<table>
<thead>
<tr>
<th align="center">信号名</th>
<th align="center">取值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">GRFWD_alu</td>
<td align="center">2’b00</td>
<td align="center">选择alu_out写入</td>
</tr>
<tr>
<td align="center">GRFWD_dm</td>
<td align="center">2’b01</td>
<td align="center">选择dm_rd写入</td>
</tr>
<tr>
<td align="center">GRFWD_pcwith8</td>
<td align="center">2’b10</td>
<td align="center">选择PC+8写入</td>
</tr>
<tr>
<td align="center">GRFWD_imm</td>
<td align="center">2’b11</td>
<td align="center">选择ext_imm写入</td>
</tr>
</tbody></table>
</li>
<li><p>说了一大堆，主要注意D级的若干部件还是最大的D_reg,E_reg两个流水寄存器，最好写的时候像我一样将数据、控制信号什么的分开来，而且<strong>一定要先写设计文档，详细设计！！！</strong>，然后定义端口写模块照着你的设计文档就好了，数据通路的连接最好依照你的设计图，不管是手画还是用其他软件画的，</p>
</li>
</ul>
<hr>
<h3 id="关于阻塞与转发"><a href="#关于阻塞与转发" class="headerlink" title="关于阻塞与转发"></a>关于阻塞与转发</h3><ul>
<li>为了方便加入指令，我们将所有指令分为若干类别<ul>
<li>ALU计算R型指令<code>cal_r: add, sub</code></li>
<li>ALU计算I型指令<code>cal_i: ori</code></li>
<li>特殊指令<code>lui: lui</code></li>
<li>存储指令<code>store: sw</code></li>
<li>访存指令<code>load: lw</code></li>
<li>分支指令<code>branch: beq</code></li>
<li>跳转链接指令<code>j_l: jal</code></li>
<li>跳回指令<code>j_r: jr</code></li>
</ul>
</li>
</ul>
<h4 id="转发输出口"><a href="#转发输出口" class="headerlink" title="转发输出口"></a>转发输出口</h4><ul>
<li><p>接下来分析转发电路，明白哪些地方会产生寄存器的新值</p>
<ul>
<li>首先<code>ALU_out</code>与<code>DM_rd</code>这两个端口必然会产生寄存器的新值（这里实际上考虑无脑转发可以将<code>DM_rd</code>换为<code>GRF_wd</code>）</li>
<li>对于<code>lui</code>指令，在D阶段后的<code>ext_imm</code>端口已经产生了值，可以转发</li>
<li>对于<code>j_l</code>指令，在D阶段后的<code>PC+8</code>端口已经产生了值，可以转发</li>
</ul>
<table>
<thead>
<tr>
<th align="center">转发输出</th>
<th align="center">指令类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ALU_out@M</td>
<td align="center">cal_r、cal_i</td>
</tr>
<tr>
<td align="center">GRF_wd@W（过度转发）</td>
<td align="center">(cal_r)、(cal_i)、load、(lui)、(j_l)</td>
</tr>
<tr>
<td align="center">ext_imm@{E、M}</td>
<td align="center">lui</td>
</tr>
<tr>
<td align="center">PC+8@{E、M}</td>
<td align="center">j_l</td>
</tr>
<tr>
<td align="center">寄存器内部转发(M -&gt; D)</td>
<td align="center">略</td>
</tr>
</tbody></table>
<ul>
<li>(指令)代表该指令已经转发过正确的值了</li>
<li>由于寄存器的内部转发使得$W$不需要向$D$转发，而$W$向$E$转发的内容除了<code>load</code>指令外都是<code>ALU_out</code>的值，这里在$M$就已经向$D$转发过了，所以本身就是正确的，不过无脑转发有什么错呢，（大家只是拿一个正确的值替换另一个正确的值罢了，硬件电路不需要感情）</li>
<li>根据需要往grf写入什么来判断需要转发什么，这里只是输出转发的内容，还需要配套转发内容的接收端的选择信号<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> FWD_E = (E_GRFWDSel == `GRFWD_imm) ? E_imm :</span><br><span class="line">                (E_GRFWDSel == `GRFWD_pcwith8) ? E_pcwith8 : <span class="number">32&#x27;b0</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="转发接入口"><a href="#转发接入口" class="headerlink" title="转发接入口"></a>转发接入口</h4><ul>
<li><p>分析转发的接入端口</p>
<ul>
<li>D级可以接收来自E、M、W级别的转发，但是W级转发我们已经在内部实现了<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> val1 = (A1 == <span class="number">0</span>) ? <span class="number">32&#x27;b0</span> : grf[A1];</span><br><span class="line"><span class="keyword">assign</span> RD1 = (A1 != <span class="number">0</span>) &amp; (A1 == A3) ? WD : val1; </span><br></pre></td></tr></table></figure></li>
<li>E级ALU计算前也可以接收转发</li>
<li>最后单独对于store类型指令，rt寄存器在M阶段才会使用，所以DM的输入端口也可以接收转发</li>
</ul>
<table>
<thead>
<tr>
<th align="center">转发输入</th>
<th align="center">指令类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">GRF_rs@D</td>
<td align="center">cal_r、cal_i、store、j_r、branch</td>
</tr>
<tr>
<td align="center">GRF_rt@D</td>
<td align="center">cal_r、branch</td>
</tr>
<tr>
<td align="center">GRF_rs@E</td>
<td align="center">同上</td>
</tr>
<tr>
<td align="center">GRF_rt@E</td>
<td align="center">同上（store指令可能也转了）</td>
</tr>
<tr>
<td align="center">DM_wd@M</td>
<td align="center">store</td>
</tr>
<tr>
<td align="center">寄存器内部转发(M -&gt; D)</td>
<td align="center">略</td>
</tr>
</tbody></table>
<ul>
<li>最后同上，正确的值可能被多次转发，例如store类指令的rt寄存器，在D、E阶段可能都被转发了一次，但是没关系，最后还是对的（），况且真的要考虑只转发一次极容易忽略转发路径，而且在考试的时候容易漏情况，所以我使用无脑转发了<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> D_rs_val = (D_rs == <span class="number">5&#x27;b0</span>) ? <span class="number">32&#x27;b0</span> :</span><br><span class="line">                  (D_rs == E_a3) ? FWD_E :</span><br><span class="line">                  (D_rs == M_a3) ? FWD_M :</span><br><span class="line">                  (D_rs == W_a3) ? FWD_W : D_grf_rd1;</span><br></pre></td></tr></table></figure></li>
<li>这里有一个疑惑，万一正确的数据没生成或者目前是错的但是我们已经无脑转发回去了怎么办？首先我们目前实现的指令集不需要考虑第一种情况，因为它对应着<strong>阻塞</strong>，Tuse &lt; Tnew时会直接阻塞。因为这种情况来不及转发回去，也就是数据没生成就转发了；第二种情况因为Tuse &gt;&#x3D; Tnew，那么Tuse等于0时，Tnew一定也是0，说明正确的数据已经生成了并且已经转回去了，覆盖率原来错误的数据。</li>
<li><strong>注意</strong>：其实可以使用恰当转发，如加入Tnew&#x3D;&#x3D;0条件，生成数据才转发回去，不过实际上我们目前不会使用，课上倒是又可能，不过也有其他办法规避，至少目前可以认为我们不选恰当转发（我后面会更新的</li>
</ul>
</li>
</ul>
<h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><ul>
<li><p>根据指令类别判断$T_{use}$,$T_{new}$ </p>
<table>
<thead>
<tr>
<th align="center">指令类别</th>
<th align="center">$ T_{use}:rs $(@D)</th>
<th align="center">$ T_{use}:rt $(@D)</th>
<th align="center">$T_{new} $@E</th>
<th align="center">$ T_{new} $@M</th>
<th align="center">$ T_{new} $@W</th>
</tr>
</thead>
<tbody><tr>
<td align="center">cal_r</td>
<td align="center">$1$</td>
<td align="center">$1$</td>
<td align="center">$1$</td>
<td align="center">$0$</td>
<td align="center">$0$</td>
</tr>
<tr>
<td align="center">cal_i</td>
<td align="center">$1$</td>
<td align="center">($3$)</td>
<td align="center">$1$</td>
<td align="center">$0$</td>
<td align="center">$0$</td>
</tr>
<tr>
<td align="center">lui</td>
<td align="center">($3$)</td>
<td align="center">($3$)</td>
<td align="center">$0$</td>
<td align="center">$0$</td>
<td align="center">$0$</td>
</tr>
<tr>
<td align="center">store</td>
<td align="center">$1$</td>
<td align="center">$2$</td>
<td align="center">($0$)</td>
<td align="center">($0$)</td>
<td align="center">($0$)</td>
</tr>
<tr>
<td align="center">load</td>
<td align="center">$1$</td>
<td align="center">($3$)</td>
<td align="center">$2$</td>
<td align="center">$1$</td>
<td align="center">$0$</td>
</tr>
<tr>
<td align="center">branch</td>
<td align="center">$0$</td>
<td align="center">$0$</td>
<td align="center">($0$)</td>
<td align="center">($0$)</td>
<td align="center">($0$)</td>
</tr>
<tr>
<td align="center">j_l</td>
<td align="center">($3$)</td>
<td align="center">($3$)</td>
<td align="center">$0$</td>
<td align="center">$0$</td>
<td align="center">$0$</td>
</tr>
<tr>
<td align="center">j_r</td>
<td align="center">$0$</td>
<td align="center">($3$)</td>
<td align="center">($0$)</td>
<td align="center">($0$)</td>
<td align="center">($0$)</td>
</tr>
</tbody></table>
<ul>
<li>($3$)代表不会需要读这个寄存器，所以不需要关注它的$T_{use}$，直接认为在W级使用即可，<del>反正没有指令会在W级才用寄存器</del></li>
<li>($0$)代表不会写寄存器，也即不会影响后续的读取，即<code>A3@&#123;E、M、W&#125;</code>都为0，所以转发会被我们排除，同时也不会干扰阻塞</li>
<li>由于$T_{use}$只会在译码阶段使用所以不需要考虑后续流水，但是$T_{new}$信号将参与流水，表达式为$T_{new}$@{N+1} $&#x3D; \max{$ $T_{new}$@{N} $ -1,0}$</li>
</ul>
</li>
<li><p>当D级需要使用rs或者rt且满足（以rs举例）：$rs \ne 0$ &amp;&amp; $rs &#x3D;&#x3D; rd$@{N} &amp;&amp; $T_{use} \lt T_{new}$@{N}则阻塞</p>
</li>
<li><p>由于我们使用的是暴力转发，能转则转，应转尽转，所以不需要考虑先前是否转发过了，后续就算转发的也一定是正确内容，且转发$E \gt M \gt W \gt GRF$</p>
</li>
<li><p>ok，言尽于此，少年加油吧，搭完课下再来看课上的内容。跟我念<strong>P5一遍过前来还愿</strong></p>
</li>
</ul>
<hr>
<h2 id="课上"><a href="#课上" class="headerlink" title="课上"></a>课上</h2><h3 id="T1-xe"><a href="#T1-xe" class="headerlink" title="T1 xe"></a>T1 xe</h3><ul>
<li>R型指令<br><code>xe rd, rs, rt</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">temp1 &lt;- GPR[rs]</span><br><span class="line">temp2 &lt;- GPR[rt]</span><br><span class="line">for i in range(0, 16):</span><br><span class="line">    temp &lt;- temp1[2*i+1] ^ temp2[2*i+1]</span><br><span class="line">GPR[rd] &lt;- temp </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="T2-jtl"><a href="#T2-jtl" class="headerlink" title="T2 jtl"></a>T2 jtl</h3><ul>
<li>I型指令<br><code>jtl rs, rt, label</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">temp1 &lt;- GPR[rs] + GPR[rt]</span><br><span class="line">temp2 &lt;- PC + 4 + sign_ext(offset || 00)</span><br><span class="line">if temp1 &gt; temp2:</span><br><span class="line">    PC &lt;- temp2</span><br><span class="line">else:</span><br><span class="line">    PC &lt;- temp1</span><br><span class="line">    Nullifycation()</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="T3-lwoc"><a href="#T3-lwoc" class="headerlink" title="T3 lwoc"></a>T3 lwoc</h3><ul>
<li>I型指令<br><code>lwoc rt, offset(base)</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adder &lt;- GPR[base] + sign_ext(offset || 00)</span><br><span class="line">vadder &lt;- adder[31: 2]</span><br><span class="line">temp1 &lt;- Mem[vadder]</span><br><span class="line">temp2 &lt;- temp1[3: 0]</span><br><span class="line">if temp1 &lt; 0x80000000:</span><br><span class="line">    GPR[temp2] &lt;- temp1</span><br><span class="line">else:</span><br><span class="line">    GPR[rt] &lt;- temp1</span><br></pre></td></tr></table></figure></li>
<li>D级译码一个check信号然后流水，就可以在流水线中识别有没有这条指令了</li>
<li>这题说一嘴，我刚开始给他设置了lw的阻塞信号搭配暴力阻塞低16个寄存器，但是WA了两个sw的点，其实这里就是无脑转发的问题<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lwoc $3, 124($0)</span><br><span class="line">sw $3, 124($0)</span><br></pre></td></tr></table></figure>
<ul>
<li>假设最后没有向<code>$3</code>写入，但是我们在W级才将<code>$3</code>修改为实际写入的寄存器，这个时候lwoc在M级别就向sw转发了一个完全错误的内容，但是没有像一般的lw一样在W级向sw再次转发，导致sw接收到错误的转发值</li>
<li>解决方案一：刚开始就设置<code>GRFA3Sel == `GRFA3_zero</code>这样就不会向前转发，然后把rt和低16个寄存器堵住，等到W级知道要写什么的情况在继续即可<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> stall_rs_E = (E_check ? (D_rs == E_rt || D_rs &lt; <span class="number">5&#x27;d16</span>) : D_rs == E_a3) &amp; (D_rs != <span class="number">5&#x27;d0</span>) &amp; (Tuse_rs &lt; E_Tnew)</span><br><span class="line"><span class="comment">//assign stall_rt_E</span></span><br><span class="line"><span class="comment">//assign stall_rs_M</span></span><br><span class="line"><span class="comment">//assign stall_rt_M</span></span><br></pre></td></tr></table></figure></li>
<li>解决方案二；改为恰当转发，当一个指令得到最后正确的结果才会向前转发，详情可见前面讲暴力转发的时候提了一嘴<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> stall_rs_E = (E_check ? D_rs &lt; <span class="number">5&#x27;d16</span> : <span class="number">1&#x27;b1</span>) &amp; (D_rs == E_a3) &amp; (D_rs != <span class="number">0</span>) &amp; (Tuse_rs &lt; E_Tnew)</span><br><span class="line"><span class="comment">//assign stall_rt_E</span></span><br><span class="line"><span class="comment">//assign stall_rs_M</span></span><br><span class="line"><span class="comment">//assign stall_rt_M</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> D_rs_val = (D_rs == <span class="number">5&#x27;b0</span>) ? <span class="number">32&#x27;b0</span> :</span><br><span class="line">                  ((D_rs == E_a3) &amp;&amp; (E_Tnew == <span class="number">3&#x27;b0</span>)) ? FWD_E :</span><br><span class="line">                  ((D_rs == M_a3) &amp;&amp; (M_Tnew == <span class="number">3&#x27;b0</span>)) ? FWD_M : </span><br><span class="line">                  (D_rs == W_a3) ? FWD_W : D_grf_rs;</span><br><span class="line">                  <span class="comment">//W级一定已经产生数据了</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>最后怎么AC的呢，当然我考场上并没有发现可能出现的错误，但是不能完全暴力阻塞遇到这条指令则阻塞（课程组卡了一下t），所以我把<code>$31</code>寄存器放出来了（纯粹是因为眼缘，毕竟卡着31号寄存器大概率没啥用），所以就过了，总体而言还是暴力阻塞。</li>
</ul>
]]></content>
      <categories>
        <category>计算机组成原理</category>
        <category>课下复习</category>
        <category>课上考试</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>北航计算机组成P2课下</title>
    <url>/2024/10/15/CO_p2/</url>
    <content><![CDATA[<h1 id="北航计算机组成原理P2课下"><a href="#北航计算机组成原理P2课下" class="headerlink" title="北航计算机组成原理P2课下"></a>北航计算机组成原理P2课下</h1><div class="note info simple"><p>通过阅读本文，你可以大致了解北京航空航天大学2023级计算机组成原理P2课下的相关内容，希望能对你有所帮助</p>
</div>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>在分享此次P2附加题做题思路前，我想对于在做题过程中错误和技巧进行总结与反思</li>
</ul>
<h3 id="对于栈的使用"><a href="#对于栈的使用" class="headerlink" title="对于栈的使用"></a>对于栈的使用</h3><ul>
<li>为了使用栈，<del>首先我们要有一个栈</del>，而且对于某些递归程序或者传递参数较多的程序，频繁地对栈指针进行加减操作可能会出现某些难以察觉的问题，所以常常对于入栈和出栈操作封装函数<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">  stack: .space 400</span><br><span class="line"></span><br><span class="line">.macro push(%int)</span><br><span class="line">  addi $sp, $sp, -4</span><br><span class="line">  sw %int, $sp</span><br><span class="line">.end_macro</span><br><span class="line"></span><br><span class="line">.macro pop(%int)</span><br><span class="line">  lw %int $sp</span><br><span class="line">  addi $sp, $sp, 4</span><br><span class="line">.end_macro</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">  la $sp, stack</span><br><span class="line">  addi $sp, $sp, 400</span><br></pre></td></tr></table></figure></li>
<li>对于含有多个参数的递归程序，比如汉罗塔问题（四个参数用寄存器其实也还可以），将会使用栈传递和接收参数，同时还需要使用栈保护寄存器，所以可以规定自己的一套规则（在函数的开始接收参数再保存寄存器，调用函数前先保护寄存器再传递参数），总之一定要明白每次出入栈的真正含义，例如对于下面的c语言代码翻译<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">hanoi</span><span class="params">(<span class="type">int</span> base, <span class="type">char</span> from, <span class="type">char</span> via, <span class="type">char</span> to)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (base == <span class="number">0</span>) &#123;</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line">  hanoi(base - <span class="number">1</span>, from, via, to);</span><br><span class="line">  move(base, from, via);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main:</span><br><span class="line">    push($t0) # 传参数</span><br><span class="line">    ...</span><br><span class="line">    jal hanoi</span><br><span class="line">    </span><br><span class="line">hanoi:</span><br><span class="line">    pop($t3) # 接收参数</span><br><span class="line">    ...</span><br><span class="line">    push($ra) # 保存返回地址</span><br><span class="line">    </span><br><span class="line">    # if模块</span><br><span class="line">    </span><br><span class="line">    push($t0) # 保存参数</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    addi $t0, $t0, -1</span><br><span class="line">    push($t0) # 传递参数</span><br><span class="line">    ...</span><br><span class="line">    jal hanoi</span><br><span class="line">    </span><br><span class="line">    pop($t3) # 取出保留的参数</span><br><span class="line">    ...</span><br><span class="line">    print($t0, $t1, $t2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    pop($ra) # 取出返回地址</span><br><span class="line">    jr $ra</span><br></pre></td></tr></table></figure></li>
<li>如果你喜欢，可以永远只在调用函数前保留所有的参数，但是我个人比较喜欢在函数的开头保留<code>$ra</code>和<code>$s</code>（不过似乎从来没这样用过），然后在每一个返回的地方<code>pop($ra); jr $ra</code>，这样可以避免出现<code>$ra</code>混乱（可能是叶子函数但是弹了一个不是<code>$ra</code>的值，可能是中间函数使用了上层函数的<code>$ra</code>，莫名其妙出现一些很奇怪的bug）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push($ra) # 保存返回地址</span><br><span class="line"></span><br><span class="line">if_begin:</span><br><span class="line">    ...</span><br><span class="line">    pop($ra) # 取出返回地址</span><br><span class="line">    jr $ra</span><br><span class="line"></span><br><span class="line">jal others</span><br><span class="line">...</span><br><span class="line">pop($ra) # 取出返回地址</span><br><span class="line">jr $ra</span><br></pre></td></tr></table></figure></li>
<li>如果出现了调用栈时的bug可以从顶层模块开始将各个部分拆分出来，例有如下调用关系<code>main -&gt; hanoi -&gt; move/hanoi</code>，我们编写<code>main</code>函数的栈使用时，将假设<code>hanoi</code>等下层的函数正确地使用了栈，所以在调用前后除了传递进去的参数其他部分应该保持完全一致，不必纠结下层函数中间如何使用栈，然后依次向下编写<code>hanoi</code>、<code>move</code>函数，方能条理清晰、面面俱到<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hanoi:</span><br><span class="line"></span><br><span class="line">    push($t0) # 保护寄存器</span><br><span class="line">    push($t1)</span><br><span class="line"></span><br><span class="line">    push($t0) # 传递参数</span><br><span class="line">    push($t1)</span><br><span class="line"></span><br><span class="line">    jal hanoi # 可以理解除了传递的参数，调用函数前后栈结构不变</span><br><span class="line"></span><br><span class="line">    pop($t1) # 取出保护的寄存器</span><br><span class="line">    pop($t0)</span><br></pre></td></tr></table></figure>
<ul>
<li>调用函数前栈内容<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">                                     </span><br><span class="line">                          </span><br><span class="line">                         +-------------+ &lt;-$sp               </span><br><span class="line">                  --&gt;    |  传递参数    |     --&gt;           </span><br><span class="line">+--------+ &lt;-$sp  准备   +-------------+     调用       </span><br><span class="line">| ...    |               |  ...        |               </span><br></pre></td></tr></table></figure></li>
<li>调用函数后栈内容<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+----------------+ &lt;-$sp</span><br><span class="line">|被调用者保存寄存器| </span><br><span class="line">+----------------+      </span><br><span class="line">|  返回地址       |    --&gt;  </span><br><span class="line">+----------------+    返回  +----------+ &lt;-$sp</span><br><span class="line">|  ...           |          | ...      |</span><br></pre></td></tr></table></figure>
<a href="http://cscore.buaa.edu.cn/#/problem?ProblemId=330&PieId=1202">MIPS汉罗塔</a><br><a href="http://cscore.buaa.edu.cn/#/problem?ProblemId=53&PieId=1202">MIPS全排列反转</a>(其实是P1课下一摸一样)</li>
</ul>
</li>
</ul>
<hr>
<h2 id="P2-extra-1-1206-33-puzzle"><a href="#P2-extra-1-1206-33-puzzle" class="headerlink" title="P2_extra_1 1206-33 puzzle"></a>P2_extra_1 1206-33 puzzle</h2><ul>
<li>本题看起来就像DP算法，但是想了好半天也没有找到一个可靠的状态转移方程（我不会算法，我是fw），所以我就正常使用递归来写了<ul>
<li>首先我们确认探索的起点</li>
<li>有四个可选择方向，上下左右</li>
<li>判断向某个方向走是否会出边界</li>
<li>判断某个方向是否有路，以及是否是此次寻找的完整路径已经走过的结点</li>
<li>最后以走到的结点为下一次探索的起点<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> matrix[<span class="number">8</span>][<span class="number">8</span>] = &#123;<span class="number">0</span>&#125;;  <span class="comment">// 定义矩阵</span></span><br><span class="line"><span class="type">int</span> visited[<span class="number">8</span>][<span class="number">8</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 记录访问状态</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> row, col;</span><br><span class="line"><span class="type">int</span> end_r, end_c;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> s_row, <span class="type">int</span> s_col)</span> &#123;</span><br><span class="line">    <span class="comment">// 找到终点</span></span><br><span class="line">    <span class="keyword">if</span> (s_row == end_r - <span class="number">1</span> &amp;&amp; s_col == end_c - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 四个方向：上、下、左、右</span></span><br><span class="line">    <span class="type">int</span> dir_r[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> dir_c[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    visited[s_row][s_col] = <span class="number">1</span>; <span class="comment">// 标记当前节点为已访问</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历四个方向</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> new_r = s_row + dir_r[i];</span><br><span class="line">        <span class="type">int</span> new_c = s_col + dir_c[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 边界检查</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> &lt;= new_r &amp;&amp; new_r &lt; row &amp;&amp; <span class="number">0</span> &lt;= new_c &amp;&amp; new_c &lt; col) &#123;</span><br><span class="line">            <span class="comment">// 如果该位置没有障碍物且未被访问</span></span><br><span class="line">            <span class="keyword">if</span> (!matrix[new_r][new_c] &amp;&amp; !visited[new_r][new_c] ) &#123;</span><br><span class="line">                total += dfs(new_r, new_c); <span class="comment">// 递归搜索</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    visited[s_row][s_col] = <span class="number">0</span>; <span class="comment">// 回溯，解除当前节点的访问标记</span></span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> start_r, start_c;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入矩阵的行数和列数</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;row, &amp;col);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读入矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;matrix[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入起点和终点坐标</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;start_r, &amp;start_c, &amp;end_r, &amp;end_c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用DFS并输出结果</span></span><br><span class="line">    <span class="type">int</span> total_paths = dfs(start_r - <span class="number">1</span>, start_c - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, total_paths);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>这道题翻译大概率不会有<code>$ra</code>的问题，因为虽然我全程使用的是栈传递，但是因为这个递归函数有返回值，所以每次返回前我都需要将返回值压栈，自然会想到返回地址的问题</li>
<li>但是因为是多个条件的if判断，触发任何一个不满足条件直接跳出即可<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># read in new_r</span><br><span class="line">lw $t4, dir_r($t3)</span><br><span class="line">add $t4, $t4, $t0</span><br><span class="line"></span><br><span class="line"># 0 &lt;= new_r</span><br><span class="line">slt $t5 ,$t4, $zero </span><br><span class="line">bne $t5, $zero, if_end_2</span><br><span class="line"></span><br><span class="line"># new_r &lt; row</span><br><span class="line">slt $t5, $t4, $s0 </span><br><span class="line">beq $t5, $zero, if_end_2</span><br><span class="line"></span><br><span class="line"># read in new_c</span><br><span class="line">lw $t3, dir_c($t3) </span><br><span class="line">add $t3, $t3, $t1</span><br><span class="line"></span><br><span class="line"># 0 &lt;= new_c</span><br><span class="line">slt $t5, $t3, $zero </span><br><span class="line">bne $t5, $zero, if_end_2</span><br><span class="line"></span><br><span class="line"># new_c &lt; col</span><br><span class="line">slt $t5, $t3, $s1 # new</span><br><span class="line">beq $t5, $zero, if_end_2</span><br><span class="line"></span><br><span class="line"># !matrix[i][j]</span><br><span class="line">read_matrix($t4, $t3, $s1, $t5)</span><br><span class="line">bne $t5, $zero, if_end_2</span><br><span class="line"></span><br><span class="line"># !visited[i][j]</span><br><span class="line">read_visited($t4, $t3, $s1, $t5)</span><br><span class="line">bne $t5, $zero, if_end_2</span><br></pre></td></tr></table></figure></li>
<li>虽然我没找到DP的写法，但是可以开一个数组<code>path[i][j]</code>表示<code>(i,j)</code>位置到<code>(end_r,end_c)</code>的路径数，这样如果这个值不是0就可以不用继续递归了，效率应该还是略低于DP（如果有的话），<strong>请教我DP！！！</strong></li>
</ul>
<hr>
<h2 id="p2-extra-1-1206-418-factorial"><a href="#p2-extra-1-1206-418-factorial" class="headerlink" title="p2_extra_1 1206-418 factorial"></a>p2_extra_1 1206-418 factorial</h2><ul>
<li>高精度！！！</li>
<li>本题应该纯粹是考察高精度的，目测数据不强，<del>毕竟我只能算不到600位也过了</del>，测试数据应该是远远没有1000位的</li>
<li>如果你选了6系人都爱的oop，你一定很喜欢java；如果你喜欢java，你就会知道里面有一个很有趣的类<code>BigInteger</code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> signum; <span class="comment">//存储数字符号</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span>[] mag; <span class="comment">//存储二进制块</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>BigInteger</code>将大数字分为若干二进制块(unsigned)，动态调整存储这些二进制块的数组，<code>BigInteger</code>理论上可以表示任意大的数字（受限于java数组只能开<code>Integer.MAX_VALUE</code>大小，所以最大大概可以表示 $ (2 \times 2147483648) ^ {2147483648} $ </li>
<li>显然，<code>BigInteger</code>挑选了一个很大的值作为基准，所以我们可以参考它的思想，也像它这样存储大数，不过因为我们<del>没有java那么nb</del>，我们算乘法的值不能超过32位，所以<code>base</code>可以适当地取得小一点例如我取了<code>10000</code>也就是每一个进制块只能表示<code>0 ~ 9999</code></li>
</ul>
</li>
<li>最后，似乎大数乘法也有若干很神奇的优化，像什么<code>FFT</code>、<code>Karatsuba</code>什么什么算法，太高大上了看不懂怎么实现的（<del>找了一段<code>FFT + Karatsuba</code>的诡异代码</del>，明明每个操作都认识，放一起这么出来了这么奇怪的代码）</li>
<li>所以我使用了最最朴素的乘法<code>*</code><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BASE 1000</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">multiply</span><span class="params">(<span class="type">int</span> mag[], <span class="type">int</span> *mag_size, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; *mag_size; i++) &#123;</span><br><span class="line">        <span class="type">int</span> prod = mag[i] * num + carry;</span><br><span class="line">        mag[i] = prod % BASE;</span><br><span class="line">        carry = prod / BASE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (carry) &#123;</span><br><span class="line">        mag[(*mag_size)++] = carry % BASE;</span><br><span class="line">        carry /= BASE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>一个提醒<ul>
<li>最开始我一直有一个点没过，我以为有一个超级超级强的数据，而且还放在第一个，<del>差点就回去看<code>FFT + Karatsuba</code></del>，后来发现我使用的<code>beq</code>指令，如果碰见计算<code>0!</code>下面这样的情况循环21亿多次才会结束（<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read_in($s0) # 读入n</span><br><span class="line">li $t0, 2 # 从2的阶乘开始算</span><br><span class="line">addi $s0, $s0, 1 # n = n + 1</span><br><span class="line"></span><br><span class="line">for_i_begin:</span><br><span class="line">    beq $t0, $s0, for_i_end</span><br><span class="line">for_i_end:</span><br></pre></td></tr></table></figure></li>
<li>数据还是很弱的，没有真的到1000位，主要还是考查高精度吧，助教们真好</li>
</ul>
</li>
</ul>
<hr>
<h3 id="鬼点子"><a href="#鬼点子" class="headerlink" title="鬼点子"></a>鬼点子</h3><ul>
<li>接下来的一切内容全部不保真，<del>仅供学习和交流使用</del></li>
<li>例如上面两道附加题，大概都是需要自己写出C语言代码再进行翻译，当然不乏有巨佬完全不需要这样orz，所以是否可以使用gcc编译器汇编并用objdump进行反汇编得到汇编代码<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -O3 -funroll-loops -finline-functions -fomit-frame-pointer -march=native factorial.c -o factorial</span><br><span class="line">objdump -d factorial</span><br></pre></td></tr></table></figure></li>
<li>然后观察生成的<code>x86-64</code>代码的思路，或者<del>直接将其修改为mips汇编</del>，感觉有可行性，但是不多，不过可以使用gcc编译器学一学汇编是真的，可以看编译器会这么使用寄存器和栈来实现一个结构、函数之类的</li>
<li>不过也许或者大概可能课上不会出现强优化的题目？（味精）</li>
</ul>
<hr>
<h2 id="P2推荐题目"><a href="#P2推荐题目" class="headerlink" title="P2推荐题目"></a>P2推荐题目</h2><p><a href="https://kie-chi.github.io/2024/10/09/CO_P2_extra/">偷摸地夹带私货</a></p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
        <category>课下复习</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>北航计算机组成P7</title>
    <url>/2024/12/08/CO_P7/</url>
    <content><![CDATA[<h1 id="北航计组组成P7"><a href="#北航计组组成P7" class="headerlink" title="北航计组组成P7"></a>北航计组组成P7</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>咳咳，更的越来越少了（），最近在致力于把测评机搭得花里胡哨，所以一直没有写博客，现在刚好有点闲所以写一下P7的博客，再不写课上的指令什么的都忘光了</li>
</ul>
<hr>
<h2 id="课下搭建注意"><a href="#课下搭建注意" class="headerlink" title="课下搭建注意"></a>课下搭建注意</h2><ul>
<li>欸为什么不写课下的搭建博客。第一，我觉得之前的学长已经写得很好了（反正看懂博客P7就成功一半了，看懂源码P7就成了hhh）；第二，我好懒；第三，之前似乎没看到有人写测试的博客，所以我来填一点点坑，希望对以后的同学有用（话说2024以后计组好像要改革了，希望不要删掉P7</li>
<li>搭建博客<ul>
<li><a href="https://flyinglandlord.github.io/2021/12/15/BUAA-CO-2021/P7/P7%E8%AF%BE%E4%B8%8A&%E8%AF%BE%E4%B8%8B/">flyinglanlord</a></li>
<li><a href="https://roife.github.io/posts/buaa-co-lab-p7/">roife</a></li>
</ul>
</li>
<li>一些补充的搭建要点<ul>
<li>说实话我没看明白为什么要加入eret，似乎返回的EPC并不会触发这个异常（）<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> pc_error = (|PC[<span class="number">1</span>: <span class="number">0</span>]) | (PC &lt; <span class="number">32&#x27;h0000_3000</span>) | (PC &gt; <span class="number">32&#x27;h0000_6fff</span>) | !D_eret;</span><br></pre></td></tr></table></figure></li>
<li>Req和stall的优先级反了，这样会出bug下面同样给出测出bug的代码，或者直接用我的测评机吧（） <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">E_PC &lt;= stall ? D_PC : (Req ? <span class="number">32&#x27;h0000_4180</span> : <span class="number">32&#x27;b0</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ori $1, $0, 0x4180</span><br><span class="line">lw $31, 0($1)                           &lt;- exception</span><br><span class="line">beq $31, $0, jlabel                     &lt;- interrupt</span><br><span class="line">nop</span><br><span class="line">jlabel:</span><br><span class="line">nop</span><br></pre></td></tr></table></figure>
<ul>
<li>如果按照学长先判断阻塞再判断异常的话，处理lw的异常时会意外触发外部中断，导致CP0模块的cause寄存器记录interrupt的被意外置位</li>
<li>话说课程组也说过reset位应该是最优先的，但是实际我们实现时都是将reset放在优先级最低的位置，不过还是过了，大概是因为使用reset没办法和mars对拍吗（烧烤ing）</li>
</ul>
</li>
<li>尽量不要用课程组的Mars的计时器吧，毕竟Mars终究还是一个单周期CPU，和我们的时钟不一样，而且就算是和好兄弟们对拍也需要保证你们阻塞的思路是一致的，烦死了（悟空脸）</li>
</ul>
<hr>
</li>
</ul>
<h2 id="课下测试"><a href="#课下测试" class="headerlink" title="课下测试"></a>课下测试</h2><h3 id="CP0"><a href="#CP0" class="headerlink" title="CP0"></a>CP0</h3><ul>
<li>毕竟是P7新增的模块，自然和异常中断是强相关的。其中和异常处理程序只会使用<code>Cause</code>和<code>EPC</code>两个寄存器<ul>
<li><code>Cause(ExcCode)</code><ul>
<li>用于判断异常中断类型，一般在异常处理程序开头就读出，再通过掩码处理<strong>跳转不同异常的处理部分</strong></li>
</ul>
</li>
<li><code>Cause(BD)</code><ul>
<li>这个位主要是为了中断设计的，假如在一条<strong>会发生跳转</strong>的跳转指令的延迟槽触发了中断异常，这个时候我们最后应该返回跳转指令而非其延迟槽</li>
<li><strong>中断并不改变原有程序执行路径，只是暂时停止去做一些其他的事情</strong>，我们跳回延迟槽就默认这条跳转指令不会发生跳转，显然矛盾了，所以只能设置一个延迟槽位跳回跳转指令让跳转指令重新执行一遍</li>
<li>因为BD不是给异常用的，所以我们处理异常的时候反而需要特判BD位，防止跳错位置</li>
</ul>
</li>
<li><code>Cause(IP)</code><ul>
<li>这6个位记录了中断产生的原因，通过它们我们可以处理不同的中断，不论是计时器的中断还是外界给的中断</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h3><ul>
<li>P7测试与以往最不同的地方大概就是多了一段异常处理程序。为了保证我们的程序可以正常运行下去，有一个适合自己生成器的异常处理程序是很重要的呀，我编写异常处理程序时主要关注以下几个点<ul>
<li>对于PC的异常（单独从AdEL错误中分出来）</li>
<li>对于其余AdEL、AdES、RI、Ov处理</li>
<li>对于Interrupt处理</li>
<li>记得存储上下文和恢复上下文</li>
<li>生成器遵从一般汇编程序编写思路，不使用<code>$a0, $a1, $k0, $k1</code>，因为异常处理程序刚开始需要使用这些寄存器</li>
</ul>
</li>
<li>对于PC错误异常<ul>
<li>超出正常PC错误，从内存<code>0x2180</code>位置读出新的EPC（这个不是什么特殊位置，或者你可以专门用一个寄存器作为存储应该返回的地址，主要就是为了一个可控，保证测试代码可以正常执行下去）</li>
<li>PC未对齐，强行对齐，并将PC指向下一位置(<code>0x3003 -&gt; 0x3000 -&gt; 0x3004</code>)</li>
</ul>
</li>
<li>对于其他异常<ul>
<li>直接跳过这条异常指令（记得判断延迟槽，如果是延迟槽需要跳两位，因为此时EPC指向了异常指令前面的跳转指令）</li>
</ul>
</li>
<li>对于Interrupt<ul>
<li>对于tb文件中给出的中断，我们直接响应<code>0x7f20</code>即可，tb文件接受到响应会取消中断</li>
<li>对于计时器触发的异常，我们需要写计时器的<code>CTRL</code>寄存器，赋0给使能位就是<code>CTRL[0]</code>或者干脆直接全给0就好了</li>
</ul>
</li>
<li>其他注意点<ul>
<li>调用函数慎用<code>jal</code>，改用<code>beq</code>或<code>j</code>，因为有的时候我们在主程序中会使用31号寄存器做些什么，异常程序按理不应该改变除了<code>$a0, $a1, $k0, $k1</code>的寄存器，或者<strong>请在保存上下文之后</strong>再使用<code>jal</code></li>
</ul>
</li>
</ul>
<details class="toggle" ><summary class="toggle-button" style="">handler源码</summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 主要处理PC异常</span><br><span class="line">_quick_handle:</span><br><span class="line">    mfc0 $k0, $13</span><br><span class="line">    andi $k0, $k0, 0x00fc</span><br><span class="line"></span><br><span class="line">    # 没有srl指令，这一步骤判断异常是否为0x0004</span><br><span class="line">    ori	$k1, $0, 0x0010</span><br><span class="line">    beq	$k0, $k1, adel_handler_quick</span><br><span class="line">    nop</span><br><span class="line">    </span><br><span class="line">    beq $0, $0, _entry</span><br><span class="line">    nop</span><br><span class="line"></span><br><span class="line"># 入口程序</span><br><span class="line">_entry:	</span><br><span class="line">    mfc0 $1, $13</span><br><span class="line">    ori	$k0, $0, 0x1000</span><br><span class="line">    sw $sp, -4($k0)</span><br><span class="line">    </span><br><span class="line">    addi $k0, $k0, -256</span><br><span class="line">    add $sp, $0, $k0</span><br><span class="line">    </span><br><span class="line">    beq $0, $0,	_save_context</span><br><span class="line">    nop</span><br><span class="line"></span><br><span class="line"># PC错误</span><br><span class="line">adel_handler_quick:</span><br><span class="line">    mfc0 $k0, $14</span><br><span class="line">    addi $k0, $k0, -0x3000</span><br><span class="line">    lui $k1, 0xffff</span><br><span class="line">    ori $k1,$k1,0xe000</span><br><span class="line">    and $k0,$k0,$k1</span><br><span class="line">    bne $k0,$0,adel_type_2</span><br><span class="line">    nop</span><br><span class="line">    mfc0 $k0, $14</span><br><span class="line">    andi $k0,$k0,3</span><br><span class="line">    bne $k0,$0,adel_type_1</span><br><span class="line">    nop</span><br><span class="line">    jal _entry</span><br><span class="line">    nop</span><br><span class="line">    </span><br><span class="line"># PC未对齐</span><br><span class="line">adel_type_1:</span><br><span class="line">    mfc0 $k0, $14</span><br><span class="line">    andi $k0, $k0, 0xfffc</span><br><span class="line">    addi $k0, $k0, 4</span><br><span class="line">    mtc0 $k0, $14</span><br><span class="line">    eret</span><br><span class="line">    ori $1, $0, 0x1234</span><br><span class="line">    </span><br><span class="line"># PC超出范围</span><br><span class="line">adel_type_2:</span><br><span class="line">    ori $k0, $0, 0x2180</span><br><span class="line">    lw $k0, 0($k0)</span><br><span class="line">    mtc0 $k0,$14</span><br><span class="line">    nop</span><br><span class="line">    eret</span><br><span class="line">    ori $1, $0, 0x1234</span><br><span class="line"></span><br><span class="line"># 判断异常中断类型</span><br><span class="line">_main_handler:</span><br><span class="line">    mfc0 $k0, $13</span><br><span class="line">    andi $k0, $k0, 0x00fc</span><br><span class="line">    </span><br><span class="line">    ori	$k1, $0, 0x0000</span><br><span class="line">    beq	$k0, $k1, int_handler</span><br><span class="line">    nop</span><br><span class="line">    ori	$k1, $0, 0x0010</span><br><span class="line">    beq	$k0, $k1, adel_handler</span><br><span class="line">    nop</span><br><span class="line">    ori	$k1, $0, 0x0014</span><br><span class="line">    beq	$k0, $k1, ades_handler</span><br><span class="line">    nop</span><br><span class="line">    ori	$k1, $0, 0x0028</span><br><span class="line">    beq	$k0, $k1, ri_handler</span><br><span class="line">    nop</span><br><span class="line">    ori	$k1, $0, 0x0030</span><br><span class="line">    beq	$k0, $k1, ov_handler</span><br><span class="line">    nop</span><br><span class="line">    ori $k1, $0, 0x0020</span><br><span class="line">    beq $k0, $k1, syscall_handler</span><br><span class="line">    nop</span><br><span class="line"></span><br><span class="line"># 判断中断类型</span><br><span class="line">int_handler:</span><br><span class="line">    sw $ra, 0($sp)</span><br><span class="line">    addi $sp, $sp, -16</span><br><span class="line">    mfc0 $v0, $12</span><br><span class="line">    sw $v0, 0($sp)</span><br><span class="line">    mfc0 $v0, $13</span><br><span class="line">    sw $v0, 4($sp)</span><br><span class="line">        </span><br><span class="line">    # check INT[3]</span><br><span class="line">    lw $v0, 0($sp)</span><br><span class="line">    lw $v1, 4($sp)</span><br><span class="line">    and	$v0, $v1, $v0</span><br><span class="line">    andi $v0, $v0, 0x800</span><br><span class="line">    bne	$v0, $0, timer1_handler</span><br><span class="line">    nop</span><br><span class="line">    </span><br><span class="line">    # check INT[2]</span><br><span class="line">    lw	$v0, 0($sp)</span><br><span class="line">    lw	$v1, 4($sp)</span><br><span class="line">    and	$v0, $v1, $v0</span><br><span class="line">    andi $v0, $v0, 0x400</span><br><span class="line">    bne	$v0, $0, timer0_handler</span><br><span class="line">    nop</span><br><span class="line">    jal interrupt_handler</span><br><span class="line">    nop</span><br><span class="line"></span><br><span class="line"># 外部中断</span><br><span class="line">interrupt_handler:</span><br><span class="line">    lui $k0, 0xffff</span><br><span class="line">    ori $k0, $k0, 0xffff</span><br><span class="line">    addi $k1, $0, 0x2180</span><br><span class="line">    lw $k1, 0($k1)</span><br><span class="line">    addi $k0, $0, 0x7f20</span><br><span class="line">    sb $0, 0($k0)</span><br><span class="line">    jal _restore_context</span><br><span class="line">    nop</span><br><span class="line"></span><br><span class="line"># Timer0中断</span><br><span class="line">timer0_handler:</span><br><span class="line">    lui $k0, 0xffff</span><br><span class="line">    addi $k1, $0, 0x2180</span><br><span class="line">    lw $k1, 0($k1) </span><br><span class="line">    addi $k0, $0, 0x7f00</span><br><span class="line">    sw $0, 0($k0)</span><br><span class="line">    jal _restore_context</span><br><span class="line">    nop</span><br><span class="line"></span><br><span class="line"># Timer1中断</span><br><span class="line">timer1_handler:</span><br><span class="line">    lui $k0, 0xffff</span><br><span class="line">    ori $k0, $k0, 0x1</span><br><span class="line">    addi $k1, $0, 0x2180</span><br><span class="line">    lw $k1, 0($k1)</span><br><span class="line">    addi $k0, $0, 0x7f10</span><br><span class="line">    sw $0, 0($k0)</span><br><span class="line">    jal _restore_context</span><br><span class="line">    nop</span><br><span class="line"></span><br><span class="line"># 其他AdEL异常直接跳过</span><br><span class="line">adel_handler:</span><br><span class="line">    mfc0 $t0, $14</span><br><span class="line">    mfc0 $k0, $13</span><br><span class="line">    lui	$t2, 0x8000</span><br><span class="line">    and	$t3, $k0, $t2</span><br><span class="line">    addi $t0, $t0, 4</span><br><span class="line">    bne	$t3, $t2, adel_nxt</span><br><span class="line">    nop</span><br><span class="line">    addi $t0, $t0, 4</span><br><span class="line">    adel_nxt:</span><br><span class="line">    mtc0 $t0, $14</span><br><span class="line">    jal	_restore_context</span><br><span class="line">    nop</span><br><span class="line"></span><br><span class="line"># AdES异常直接跳过</span><br><span class="line">ades_handler:</span><br><span class="line">    mfc0 $t0, $14</span><br><span class="line">    mfc0 $k0, $13</span><br><span class="line">    lui	$t2, 0x8000</span><br><span class="line">    and	$t3, $k0, $t2</span><br><span class="line">    addi $t0, $t0, 4</span><br><span class="line">    bne	$t3, $t2, ades_nxt</span><br><span class="line">    nop</span><br><span class="line">    addi $t0, $t0, 4</span><br><span class="line">    ades_nxt:</span><br><span class="line">    mtc0 $t0, $14</span><br><span class="line">    jal	_restore_context</span><br><span class="line">    nop</span><br><span class="line"></span><br><span class="line"># 未知指令直接跳过</span><br><span class="line">ri_handler:</span><br><span class="line">    mfc0 $t0, $14</span><br><span class="line">    mfc0 $k0, $13</span><br><span class="line">    lui	$t2, 0x8000</span><br><span class="line">    and	$t3, $k0, $t2</span><br><span class="line">    addi $t0, $t0, 4</span><br><span class="line">    bne	$t3, $t2, ri_nxt</span><br><span class="line">    nop</span><br><span class="line">    addi $t0, $t0, 4</span><br><span class="line">    ri_nxt:</span><br><span class="line">    mtc0 $t0, $14</span><br><span class="line">    jal	_restore_context</span><br><span class="line">    nop</span><br><span class="line">    </span><br><span class="line"># 算术溢出直接跳过</span><br><span class="line">ov_handler:</span><br><span class="line">    mfc0 $t0, $14</span><br><span class="line">    mfc0 $k0, $13</span><br><span class="line">    lui	$t2, 0x8000</span><br><span class="line">    and	$t3, $k0, $t2</span><br><span class="line">    addi $t0, $t0, 4</span><br><span class="line">    bne	$t3, $t2, ov_nxt</span><br><span class="line">    nop</span><br><span class="line">    addi $t0, $t0, 4</span><br><span class="line">    ov_nxt:</span><br><span class="line">    mtc0 $t0, $14</span><br><span class="line">    jal	_restore_context</span><br><span class="line">    nop</span><br><span class="line"></span><br><span class="line"># 处理一下syscall直接跳过</span><br><span class="line">syscall_handler:</span><br><span class="line">    mfc0 $t0, $14</span><br><span class="line">    mfc0 $k0, $13</span><br><span class="line">    lui	$t2, 0x8000</span><br><span class="line">    and	$t3, $k0, $t2</span><br><span class="line">    addi $t0, $t0, 4</span><br><span class="line">    bne	$t3, $t2, syscall_nxt</span><br><span class="line">    nop</span><br><span class="line">    addi $t0, $t0, 4</span><br><span class="line">    syscall_nxt:</span><br><span class="line">    mtc0 $t0, $14</span><br><span class="line">    jal	_restore_context</span><br><span class="line">    nop</span><br><span class="line"></span><br><span class="line"># 返回</span><br><span class="line">_restore:</span><br><span class="line">    eret</span><br><span class="line">    ori $1, $0, 0x1234</span><br><span class="line">    </span><br><span class="line"># 保存上下文</span><br><span class="line">_save_context:</span><br><span class="line">    sw $2, 8($sp)    </span><br><span class="line">    sw $3, 12($sp)    </span><br><span class="line">    sw $4, 16($sp)    </span><br><span class="line">    sw $5, 20($sp)    </span><br><span class="line">    sw $6, 24($sp)    </span><br><span class="line">    sw $7, 28($sp)    </span><br><span class="line">    sw $8, 32($sp)    </span><br><span class="line">    sw $9, 36($sp)    </span><br><span class="line">    sw $10, 40($sp)   </span><br><span class="line">    sw $11, 44($sp)    </span><br><span class="line">    sw $12, 48($sp)   </span><br><span class="line">    sw $13, 52($sp)    </span><br><span class="line">    sw $14, 56($sp)   </span><br><span class="line">    sw $15, 60($sp)    </span><br><span class="line">    sw $16, 64($sp)   </span><br><span class="line">    sw $17, 68($sp)    </span><br><span class="line">    sw $18, 72($sp)   </span><br><span class="line">    sw $19, 76($sp)    </span><br><span class="line">    sw $20, 80($sp)   </span><br><span class="line">    sw $21, 84($sp)    </span><br><span class="line">    sw $22, 88($sp)   </span><br><span class="line">    sw $23, 92($sp)    </span><br><span class="line">    sw $24, 96($sp)   </span><br><span class="line">    sw $25, 100($sp)   </span><br><span class="line">    sw $28, 112($sp)   </span><br><span class="line">    sw $29, 116($sp)   </span><br><span class="line">    sw $30, 120($sp)   </span><br><span class="line">    sw $31, 124($sp)</span><br><span class="line">    mfhi $k0</span><br><span class="line">    sw $k0, 128($sp)</span><br><span class="line">    mflo $k0</span><br><span class="line">    sw $k0, 132($sp)</span><br><span class="line">    jal	_main_handler</span><br><span class="line">    nop</span><br><span class="line">    </span><br><span class="line"># 恢复上下文</span><br><span class="line">_restore_context:</span><br><span class="line">    addi $sp, $0, 0x1000</span><br><span class="line">    addi $sp, $sp, -256</span><br><span class="line">    lw $2, 8($sp)   </span><br><span class="line">    lw $3, 12($sp)   </span><br><span class="line">    lw $4, 16($sp)   </span><br><span class="line">    lw $5, 20($sp)   </span><br><span class="line">    lw $6, 24($sp)   </span><br><span class="line">    lw $7, 28($sp)   </span><br><span class="line">    lw $8, 32($sp)   </span><br><span class="line">    lw $9, 36($sp)   </span><br><span class="line">    lw $10, 40($sp)    </span><br><span class="line">    lw $11, 44($sp)   </span><br><span class="line">    lw $12, 48($sp)    </span><br><span class="line">    lw $13, 52($sp)   </span><br><span class="line">    lw $14, 56($sp)    </span><br><span class="line">    lw $15, 60($sp)   </span><br><span class="line">    lw $16, 64($sp)    </span><br><span class="line">    lw $17, 68($sp)   </span><br><span class="line">    lw $18, 72($sp)    </span><br><span class="line">    lw $19, 76($sp)   </span><br><span class="line">    lw $20, 80($sp)    </span><br><span class="line">    lw $21, 84($sp)   </span><br><span class="line">    lw $22, 88($sp)    </span><br><span class="line">    lw $23, 92($sp)   </span><br><span class="line">    lw $24, 96($sp)    </span><br><span class="line">    lw $25, 100($sp)    </span><br><span class="line">    lw $28, 112($sp)   </span><br><span class="line">    lw $30, 120($sp)   </span><br><span class="line">    lw $31, 124($sp)   </span><br><span class="line">    lw $k0, 128($sp)</span><br><span class="line">    mthi $k0</span><br><span class="line">    lw $k0, 132($sp)</span><br><span class="line">    mtlo $k0</span><br><span class="line">    lw $29, 116($sp)</span><br><span class="line">    ori $1,$0,1</span><br><span class="line">    beq $0, $0, _restore	</span><br><span class="line">    nop</span><br></pre></td></tr></table></figure>
</div></details>

<hr>
<h3 id="异常测试"><a href="#异常测试" class="headerlink" title="异常测试"></a>异常测试</h3><ul>
<li>忘了叠甲了，我说的异常是指内部指令出现了问题导致的异常，我们主要解决下面几个问题<ul>
<li>是否能正确响应各种异常<ul>
<li>把各种异常试一下就好了，我是按照我在handler的分类尝试的</li>
<li>注意不要一直异常，最好穿插一些正确的指令，否则万一这个CPU啥都判为异常呢（）</li>
</ul>
</li>
<li>是否能正确处理延迟槽(BD)<ul>
<li>比较easy，放在jal指令后面就好了</li>
</ul>
</li>
<li>是否能正确处理乘除槽<ul>
<li>这个我采取的是在异常指令前后随机插入<code>multu</code>或者<code>mtlo</code>什么的，异常处理程序中有专门读<code>HI LO</code>寄存器的，我们就不需要额外验证了</li>
</ul>
</li>
<li>是否能正确处理异常与阻塞<ul>
<li>这个主要和存取类指令有关，主要就存取类指令比较方便设计阻塞，例如后面放一条不会跳的beq指令，一劳永逸；前面就放一条load指令好了，尽可能地多阻塞一会，方便查出流水寄存器可能的错误</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="中断测试"><a href="#中断测试" class="headerlink" title="中断测试"></a>中断测试</h3><ul>
<li>嘿嘿，我的中断测试单独分开了，但是中断测试实际上也会涉及异常的处理</li>
<li>由于对于一个指令位置的中断有两种方案<ul>
<li>将需要中断指令的PC加入tb文件中。优点：优雅、方便；缺点：对测评机不友好（），无法测试中断和阻塞之间的耦合关系</li>
<li>使用计时器中断，几条指令过后自动触发中断。优点：测试更加灵活；缺点：不方便对拍（虽然我已经尽力保证中间不出现阻塞了，难保有人实现从P5就与我不一致）</li>
<li>注意力各位，就算使用计时器中断也不要和Mars对拍，中断要和自己的好兄弟们对拍哦，或者上github找一个学长的改一改（感谢FlyingLandlord学长orz）</li>
</ul>
</li>
<li>接下来测试数据主要解决下面几个问题<ul>
<li>是否能正确响应各种中断<ul>
<li>这个和上面异常一样，各种中断都试一下</li>
</ul>
</li>
<li>是否能正确处理跳转(尤其是延迟槽)时中断<ul>
<li>分别测试跳转指令时、跳转指令延迟槽内、刚从eret中返回时中断</li>
</ul>
</li>
<li>是否能正确处理阻塞和中断<ul>
<li>这里我利用了一下乘除槽，由于<code>div mflo</code>指令相隔很多周期仍然会阻塞，更加方便我们在中间发挥，<strong>尤其注意这个阻塞主要测试那条产生的nop</strong>，所以请务必保证传递正确与否会导致结果不同</li>
<li>例如在被阻塞的指令之前放一条会跳转的指令，这样BD位没实现好就会发生错误</li>
</ul>
</li>
<li>是否能正常处理异常和中断<ul>
<li>这个其实可以可以融合在其他环节中，当然随便拉一条异常指令给它设置断点即可</li>
</ul>
</li>
<li>是否能正常处理延迟槽<ul>
<li>为了防止有人异常和中断分开了，按理来说异常时候没问题这里也没问题，不过为了保险</li>
</ul>
</li>
<li>是否能正常处理乘除槽<ul>
<li>和上面一条同理，不过中断的延迟槽更方便了，生成一条乘除指令随机在这条指令前、这条指令、这条指令后生成中断点</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="关于数据生成器"><a href="#关于数据生成器" class="headerlink" title="关于数据生成器"></a>关于数据生成器</h3><ul>
<li>提示，没有加入P7新增指令的转发，不过异常处理程序已经很多变了吧（），各位还是自己测试一下转发什么的吧</li>
<li>因为很懒，所以我从P3~P7的数据生成器是一整个大型文件，因此很多函数需要传递各种参数限制生成的数据（），提供给大家，不过大概率很难调用吧，里面有几个外置的函数可供P7使用！<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">dataMaker = DataMaker()</span><br><span class="line">dataMaker.exc_test(<span class="number">500</span>, <span class="literal">True</span>, <span class="string">&quot;./test&quot;</span>)</span><br><span class="line"><span class="comment"># exc_test(times, forbidden=True, _dir=&quot;.&quot;)</span></span><br><span class="line"><span class="comment"># times生成指令最大长度，不建议超过1000条因为这里有中断程序</span></span><br><span class="line"><span class="comment"># forbidden是否禁止RI测试，方便和Mars对拍</span></span><br><span class="line"><span class="comment"># _dir设置好文件夹，生成的数据会在这个文件夹下</span></span><br><span class="line"></span><br><span class="line">dataMaker.int_test(<span class="number">500</span>, _<span class="built_in">dir</span>=<span class="string">&quot;./test&quot;</span>, tb_dir=<span class="string">&quot;./tbs&quot;</span>)</span><br><span class="line"><span class="comment"># int_test(times, noTimer=False, noInterrupt=False, _dir=&quot;.&quot;, tb_dir=&quot;.&quot;)</span></span><br><span class="line"><span class="comment"># times同上</span></span><br><span class="line"><span class="comment"># noTimer不使用计时器产生中断</span></span><br><span class="line"><span class="comment"># noInterrupt不使用tb产生中断</span></span><br><span class="line"><span class="comment"># _dir同上</span></span><br><span class="line"><span class="comment"># tb_dir如果需要tb的中断，生成的tb文件会在这个文件夹下</span></span><br></pre></td></tr></table></figure>
<a class="btn-beautify " href="https://kie-chi.github.io/files/DataMaker.py" 
  title="DataMaker源码"><span>DataMaker源码</span></a></li>
</ul>
<hr>
<h2 id="课上测试"><a href="#课上测试" class="headerlink" title="课上测试"></a>课上测试</h2><ul>
<li>这个课上是真的测试哦</li>
<li>首先大家手要快，拿到了之后立马提交前四个，否则会等得很煎熬，不过我19:00提交的，19:01前四道题就过了，过题最快的一集，看它转的时候有那么一点点小紧张，不过我相信我的测评机（如果没过我大概率也de不出来，已经想好用拉肚子作为逃跑的理由了）</li>
<li>最后一道题是一道抽象指令题，归为啥类都不合适哈</li>
<li><code>withdraw</code><ul>
<li><code>withdraw</code></li>
<li>将最近一条sw的行为撤销</li>
<li>首先在CP0中添加四个额外的寄存器<code>DomainLo</code>、<code>DomainHi</code>、<code>ChangeAddr</code>、<code>ChangeData</code><ul>
<li><code>ChangeAddr</code>: 最近一次sw修改值的地址</li>
<li><code>ChangeData</code>: 最近一次sw修改之前的值，用于恢复这个地址的值</li>
<li><code>DomainLo</code>: 允许撤销sw指令地址下界，低于这个值报<code>AdES</code>异常，保证在<code>0x0000 ~ 0x3000</code></li>
<li><code>DomainHi</code>: 允许撤销sw指令地址上界，超过这个值报<code>AdES</code>异常，保证在<code>0x0000 ~ 0x3000</code></li>
</ul>
</li>
<li>注意实现这些值，寄存器编号忘了；<code>mfc0</code>可以获取它们的值，<code>mtc0</code>只可以更改地址上下界两个寄存器，而且保证是字对齐</li>
<li>如果withdraw指令前面没有出现过sw，则忽略这条指令</li>
<li>如果withdraw发挥了作用，其效果相当于一条sw指令</li>
</ul>
</li>
<li>一道相当繁琐的指令题<ul>
<li>首先将四个寄存器加入CP0</li>
<li>CP0中设置一个符号位flag，标识是否已经有sw指令了</li>
<li>在CP0中多加一层ExcCode的判断<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//withdraw时判断是否有ExcCodePlus</span></span><br><span class="line"><span class="keyword">assign</span> newExcCode = (ExcCode != <span class="number">5&#x27;b0</span>) ? ExcCode :</span><br><span class="line">                    (ExcCodePlus != <span class="number">5&#x27;b0</span>) ? ExcCodePlus : <span class="number">5&#x27;b0</span>;</span><br></pre></td></tr></table></figure></li>
<li>建议传入ByteEn，通过是否位<code>4&#39;b1111</code>来判断是否为sw</li>
<li>遇到withdraw指令判断逻辑较为复杂<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//withdraw是外界传入的信号，标识withdraw指令 </span></span><br><span class="line"><span class="keyword">if</span> (withdraw &amp; flag) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(Addr &lt; DomainLo || Addr &gt;= DomainHi) <span class="keyword">begin</span></span><br><span class="line">        ExcCodePlus = `EXC_AdES;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!Req) <span class="keyword">begin</span></span><br><span class="line">        outByteEn = <span class="number">4&#x27;b1111</span>;</span><br><span class="line">        outAddr = ChangeAddr;</span><br><span class="line">        outData = ChangeData;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li>
<li>然后在M级把这些输出值接到DM即可<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> m_data_byteen = (withdraw) ? outByteEn :....</span><br><span class="line"><span class="keyword">assign</span> m_data_addr ...</span><br><span class="line"><span class="keyword">assign</span> m_data_wdata ...</span><br></pre></td></tr></table></figure></li>
<li>最后这条指令不需要转发和暂停，课程组还算有点人性，要我当助教我就这样(doge)<ul>
<li>变异load指令<code>lww $rt, offset($base)</code>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">addr &lt;- GPR[base] + offset</span><br><span class="line">vaddr &lt;- addr[31: 2]</span><br><span class="line">temp1 &lt;- Mem[vaddr]</span><br><span class="line">temp2 &lt;- CP0.ChangeData</span><br><span class="line">temp3 &lt;- temp2[4:0]</span><br><span class="line">if temp1 &gt; CP0.ChangeData:</span><br><span class="line">    withdraw                &lt;- 这个withdraw是原题的withdraw</span><br><span class="line">elif temp1 &lt; CP0.ChangeData:</span><br><span class="line">    GPR[rt] &lt;- temp1</span><br><span class="line">else:</span><br><span class="line">    GPR[temp3 ^ rt] &lt;- temp2</span><br></pre></td></tr></table></figure>
<ul>
<li>写完我自己都笑了，希望明年不会有这么阴间的（）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h2><ol>
<li>我的测评机有一个彩蛋噢</li>
<li>嘻嘻<br><img src="https://kie-chi.github.io/images/CO_P7/P7_image.png" alt="alt text"><br><img src="https://kie-chi.github.io/images/CO_P7/P7_image_1.png" alt="alt text"></li>
</ol>
]]></content>
      <categories>
        <category>计算机组成原理</category>
        <category>自动化测试</category>
        <category>课下复习</category>
        <category>课上考试</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础--字符串(二)</title>
    <url>/2024/09/26/Python_%E5%AD%97%E7%AC%A6%E4%B8%B2_2/</url>
    <content><![CDATA[<h1 id="Python基础–字符串-二"><a href="#Python基础–字符串-二" class="headerlink" title="Python基础–字符串(二)"></a>Python基础–字符串(二)</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>请确保你已经有一定的<code>Python</code>基础且对字符串有一定了解哦，今天我们依旧来探索字符串的秘密，发车了(<del>是因为笔者太懒才没有一次性写完的</del>)，完全不了解的小伙伴们也不用慌，移步<a href="/2024/09/21/Python_%E5%AD%97%E7%AC%A6%E4%B8%B2_1/" title="Python基础--字符串(一)">Python基础--字符串(一)</a></p>
<h2 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h2><h3 id="传统式"><a href="#传统式" class="headerlink" title="%传统式"></a><code>%</code>传统式</h3><ul>
<li>你是否看过这些特殊的字符串<code>%s</code>，<code>%d</code>呢，相信写过C语言的同学们一定不陌生了，如果没见过也没关系，他们都是一类特殊的字符串，我们称之为格式化字符串，常用于格式化我们的输出，那么我们就从最传统的<code>%</code>式格式化字符串讲解吧</li>
</ul>
<h4 id="常用的格式化字符串"><a href="#常用的格式化字符串" class="headerlink" title="常用的格式化字符串"></a>常用的格式化字符串</h4><ul>
<li><code>%s</code><ul>
<li>适用于为字符串占位，<del>我本来就是啊</del></li>
</ul>
</li>
<li><code>%d</code><ul>
<li>适用于为十进制数字占位，类似的还有<code>%x</code> <code>%o</code> <code>%b</code></li>
</ul>
</li>
<li><code>%f</code><ul>
<li>适用于为浮点数占位</li>
</ul>
</li>
<li><code>.precision</code><ul>
<li>适用于对浮点数精度控制，<code>%.2f</code>保留两位小数，默认是6位小数</li>
</ul>
</li>
<li><code>width</code><ul>
<li>指定占位符占据的宽度，<code>%5d</code>十进制整数至少占5个单位，不够补充</li>
</ul>
</li>
<li><code>flags</code><ul>
<li>指定填充位与对齐，与<code>width</code>位共同控制对齐问题</li>
<li><code>0</code>，补充前导0</li>
<li><code>-</code>，左对齐，默认是右对齐，将覆盖前导0</li>
<li><code> </code>，方便正数与负数对齐</li>
<li><code>+</code>，数字补齐符号</li>
</ul>
</li>
<li>可以搭配使用，例如<code>%-5.2f</code>等等</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;% d %+d&quot;</span> % (<span class="number">1234</span>, <span class="number">1234</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;% d %+d&quot;</span> % (-<span class="number">1234</span>, -<span class="number">1234</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%4d,%4d,%6.2f&quot;</span> % (<span class="number">12</span>, <span class="number">34</span>, <span class="number">3.1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%-4d,%-4d,%-6.2f&quot;</span> % (<span class="number">12</span>, <span class="number">34</span>, <span class="number">3.1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%04d,%04d,%06.2f&quot;</span> % (<span class="number">12</span>, <span class="number">234</span>, <span class="number">3.1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%0-4d,%0-4d,%0-6.2f&quot;</span> % (<span class="number">12</span>, <span class="number">234</span>, <span class="number">3.1</span>)) <span class="comment"># 产生覆盖行为</span></span><br></pre></td></tr></table></figure>

<pre><code> 1234 +1234
-1234 -1234
  12,  34,  3.10
12  ,34  ,3.10  
0012,0234,003.10
12  ,234 ,3.10  
</code></pre>
<h3 id="format"><a href="#format" class="headerlink" title="format"></a>format</h3><h4 id="默认格式化"><a href="#默认格式化" class="headerlink" title="默认格式化"></a>默认格式化</h4><ul>
<li>不再通过<code>%</code>的形式指定，而是默认形式填充，我们只需要负责哪些位置填充什么字符即可</li>
<li>大括号中默认格式填入我们指定的参数，默认顺序是依次填入<ul>
<li><code>&quot;&#123;&#125; &#123;&#125;&quot;.format(12, &quot;setdown&quot;)</code></li>
</ul>
</li>
<li>有需求可以在大括号中填入参数位置，可以多次使用，每个大括号都要填入位置<ul>
<li><code>&quot;&#123;0&#125; &#123;1&#125; &#123;1&#125; &#123;0&#125;&quot;.format(12, &quot;setdown&quot;)</code></li>
<li><code>&quot;&#123;0&#125; &#123;1&#125;&quot;.format(12, &quot;setdown&quot;)</code></li>
</ul>
</li>
<li>利用键值对传入参数，则括号中必须使用key值<ul>
<li><code>&quot;&#123;name&#125; &#123;age&#125;&quot;.format(name=&quot;setdown&quot;, age=12)</code></li>
<li><code>&quot;&#123;name&#125; &#123;age&#125; &#123;age&#125; &#123;name&#125;&quot;.format(name=&quot;setdown&quot;, age=12)</code></li>
</ul>
</li>
<li>利用键值对和位置进行复杂传参<ul>
<li><code>&quot;&#123;0[name]&#125; &#123;1[age]&#125; &#123;0[0]&#125; &#123;1[1]&#125;&quot;.format(&#123;&quot;name&quot;:&quot;setdown&quot;, &quot;age&quot;:12&#125;, [12, 34])</code></li>
</ul>
</li>
</ul>
<h4 id="format-spec"><a href="#format-spec" class="headerlink" title="format_spec"></a>format_spec</h4><ul>
<li>通过类似于<code>%</code>传统式格式化字符串规范要求</li>
<li><code>:[[fill] align][sign][0][width][.precision][type]</code></li>
<li><code>fill</code><ul>
<li>填充内容，对于指定宽度填充什么字符，需要显式指定对齐方式</li>
</ul>
</li>
<li><code>align</code><ul>
<li>对齐方式，<code>&lt;</code> <code>^</code> <code>&gt;</code>分别是强制左、居中、右对齐</li>
</ul>
</li>
<li><code>sign</code><ul>
<li>展示符号，<code>+</code>正负数都展示符号，<code> </code>负数展示符号正数留空对齐</li>
</ul>
</li>
<li><code>width</code><ul>
<li>最小宽度，默认为字符串长度</li>
</ul>
</li>
<li><code>precision</code><ul>
<li>控制小数的精度范围，默认是小数点后六位</li>
</ul>
</li>
<li><code>type</code><ul>
<li>常用类型有<code>d</code> <code>f</code> <code>s</code></li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;:_&lt;4&#125; &#123;:0&gt;6&#125; &#123;:$^10&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">11</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;:04&#125; &#123;:10&#125; &#123;:^10&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">12</span>, <span class="number">3</span>, <span class="number">34</span>))</span><br></pre></td></tr></table></figure>

<pre><code>1___ 000002 $$$$11$$$$
0012          3     34    
</code></pre>
<h2 id="f-string"><a href="#f-string" class="headerlink" title="f-string"></a>f-string</h2><ul>
<li>可以通过变量等方式直接转义进入字符串，经常使用，但是也可以使用<code>format_spec</code>来表达更加准确的字符串形式</li>
<li>简易使用方式为<code>f&quot;&#123;name&#125; is about &#123;value&#125;&quot;</code></li>
<li>使用占位的变量可以与<code>format_spec</code>嵌套使用更加灵活</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">line = <span class="string">&quot;this is a test string&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;line= &#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以起调试的作用</span></span><br><span class="line">a = <span class="number">1</span> + <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;a=&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">width = <span class="number">14</span></span><br><span class="line">align = <span class="string">&quot;^&quot;</span></span><br><span class="line">value = <span class="number">123.34</span></span><br><span class="line">precision = <span class="number">5</span></span><br><span class="line">fill = <span class="string">&quot;_&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;value:&#123;fill&#125;</span><span class="subst">&#123;align&#125;</span><span class="subst">&#123;width&#125;</span>.<span class="subst">&#123;precision&#125;</span>f&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<pre><code>line= &#39;this is a test string&#39;
a=3
__123.34000___
</code></pre>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象u1</title>
    <url>/2025/03/19/OO_u1/</url>
    <content><![CDATA[<h1 id="北航2025面向对象第一单元"><a href="#北航2025面向对象第一单元" class="headerlink" title="北航2025面向对象第一单元"></a>北航2025面向对象第一单元</h1><p>[toc]</p>
<h2 id="第一次作业"><a href="#第一次作业" class="headerlink" title="第一次作业"></a>第一次作业</h2><h3 id="1-代码架构分析"><a href="#1-代码架构分析" class="headerlink" title="1.代码架构分析"></a>1.代码架构分析</h3><p>在阅读往届学长的博客（以及尝试使用正则表达式解析嵌套括号）后，最后决定了使用递归下降算法。最最主要的是今年oop中也出现了递归下降方法，课程写的文档挺不错的，通俗易懂。找了一下，发现居然也是一位<a href="https://zhhangbian.github.io/2024/04/02/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-Unit1-%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D/">学长的博客</a></p>
<p>虽然只学了一年多编程，但是苯人对递归式的函数还是有较深的体会的，主要针对一下两点来写递归函数即可</p>
<ul>
<li>函数的职责：即明确一个函数返回值或者是函数调用的时机，实际上就是牢记函数初衷（<strong>parseExpr就返回表达式，在解析表达式时调用</strong>），当描述一个递归函数的递归调用过程中卡壳了，不妨回到这个函数被设计之初的职责，跳出细节才能看到全局。</li>
<li>函数终止的条件：尤其是自调用的递归函数，常常会陷入无限调用的套娃中。使用一个具体的例子往往能够更加好地理解什么时候函数递归到达终点了。</li>
</ul>
<p><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/oo_images/class.png" alt="alt text"></p>
<h3 id="2-流程分析"><a href="#2-流程分析" class="headerlink" title="2.流程分析"></a>2.流程分析</h3><p>我将整个流程分为四个模块，**<code>预处理 -&gt; 解析 -&gt; 合并项 -&gt; 生成字符串</code>**</p>
<ul>
<li>虽然在本次作业中，生成和优化字符串同隶属于最后一个模块，随着基项复杂度的增加，二者的分开也是在所难免</li>
</ul>
<h4 id="i-预处理"><a href="#i-预处理" class="headerlink" title="i.预处理"></a>i.预处理</h4><p>由于题目给出的原字符串无用信息过多，并不能很好的划分为清晰的<code>Token</code>，所以需要先对表达式进行一些处理</p>
<ul>
<li>去除空白字符：<code>.replaceAll(&quot;[ \t]&quot;, &quot;&quot;)</code> &#x2F; <code>.replaceAll(&quot;\\s+&quot;, &quot;&quot;)</code></li>
<li>合并连续的加减号<ul>
<li>使用正则表达式循环替换<code>++ +- -+ --</code>，直到字符串长度不再改变</li>
<li>顺序遍历字符串，记录连续的符号，手动消除</li>
</ul>
</li>
</ul>
<p>还可以进行的操作，比如去除正号与前导零<code>replaceAll(&quot;^\+?0*([0-9]+)$&quot;, &quot;$1&quot;)</code>好像也不需要其他操作了，当然我没有在预处理阶段处理符号和前导零</p>
<h4 id="ii-解析"><a href="#ii-解析" class="headerlink" title="ii.解析"></a>ii.解析</h4><p>按照<code>parseExpr -&gt; parseTerm -&gt; parseFactor</code></p>
<ul>
<li>当然，在其中还可以适当封装一些其他方法，降低方法的复杂度</li>
<li>如，三种不同的因子分别使用方法识别<code>parseXXXFactor</code></li>
<li>识别指数（或缺省）<code>parseExp</code></li>
<li>总之，方法在保证结构完整、功能集中的情况下复杂度尽可能低</li>
</ul>
<p>使用递归下降即可，最后得到一个<code>Expr</code>的表达式对象</p>
<ul>
<li>注意<code>+/-</code>分割，由于我没有在识别<code>Token</code>时将符号与数字一起判断，<code>+/-</code>可能作为项之间的分割也可以作为符号，只要注意在<code>parseTerm</code>、<code>parseFactor</code>注意它们不同的含义即可</li>
<li><code>BigInteger</code>支持解析前导零的字符串，所以这里不用在意了</li>
</ul>
<h4 id="iii-合并项"><a href="#iii-合并项" class="headerlink" title="iii.合并项"></a>iii.合并项</h4><p>在语法树的层面上，我们解析的操作实际是建立了一个庞大的树结构，接下来该应该根据语法树来还原多项式</p>
<ul>
<li><p>边建树边返回多项式边化简，此时<code>parse</code>方法的返回值直接改为多项&#x2F;单项式。优点是效率更高，缺点是依托于强大的算法基础，而且容易错。以<code>Poly</code>、<code>Mono</code>举例</p>
<ul>
<li><code>parseExpr/parseTerm/parseFactor: Poly</code>：返回表达式&#x2F;项&#x2F;因子对应多项式</li>
<li><code>parseExpr</code>将所有<code>parseTerm</code>得到的多项式加起来</li>
<li><code>parseTerm</code>将所有<code>parseFactor</code>得到的多项式乘起来</li>
<li><code>parseNumFactor</code>: 返回纯数字组成的多项式，但是只有一个项<code>[coe * x ^ 0]</code></li>
<li><code>parseVarFactor</code>: 返回纯自变量组成的多项式，但是只有一个项<code>[1 * x ^ exp]</code></li>
<li><code>parseExprFactor/parseExpr</code>: 返回表达式因子组成的多项式，但是只有一个项<code>[coe1 * x ^ exp1, coe2 * x ^ exp2, ...]</code></li>
</ul>
</li>
<li><p>建树之后后序遍历，为每一种类设置一个返回多项式的函数<code>toPoly</code>作为<em>遍历函数</em></p>
<ul>
<li>对于<code>Expr</code>类，先遍历所有子结点也就是<code>Term</code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Expr.java</span></span><br><span class="line"><span class="keyword">public</span> Poly <span class="title function_">toPoly</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Poly</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Poly</span>();</span><br><span class="line">    <span class="keyword">for</span> (Term term : <span class="built_in">this</span>.terms) &#123;</span><br><span class="line">        res.addPoly(term.toPoly());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>对于<code>Term</code>类，也先遍历所有子结点也就是<code>Factor</code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Term.java</span></span><br><span class="line"><span class="keyword">public</span> Poly <span class="title function_">toPoly</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Poly</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Poly</span>();</span><br><span class="line">    <span class="keyword">for</span> (Factor factor : <span class="built_in">this</span>.factors) &#123;</span><br><span class="line">        res.mulPoly(factor.toPoly());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>其他所有细节都同上</li>
</ul>
</li>
</ul>
<h5 id="防御性编程"><a href="#防御性编程" class="headerlink" title="防御性编程"></a>防御性编程</h5><h6 id="a-“不可变类”"><a href="#a-“不可变类”" class="headerlink" title="a.“不可变类”"></a>a.“不可变类”</h6><p>java中有专门的一种类，被称为不可变类，这种类一旦被创建内部属性无法更改。利用了java的机制维护了类内属性的安全性，例如<code>BigInteger</code>或是<code>Integer</code>类都是不可变类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">tmp</span> <span class="operator">=</span> BigInteger.valueOf(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 创建一个存储2的大数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现int类型的自加操作</span></span><br><span class="line"><span class="comment">// tmp++ ???</span></span><br><span class="line">tmp.add(BigInteger.ONE)</span><br><span class="line"><span class="comment">// 发现tmp的值并没有发生改变</span></span><br><span class="line"></span><br><span class="line">tmp = tmp.add(BigInteger.ONE)</span><br><span class="line"><span class="comment">// tmp顺利加1，但是tmp并非原来的存储2的对象</span></span><br></pre></td></tr></table></figure>

<p>而我采用的“不可变类”实际为可变类型，即在创建后是可以被改变的，但是我在编写代码时遵循“协议”（欸欸欸，就是这么高级），人工维护类的不可变性</p>
<ul>
<li>&#x3D;&#x3D;类创建的对象在投入使用后属性不可以被改变&#x3D;&#x3D;，被使用前随意</li>
<li>此处被使用可以理解为参与合并同类项，以Poly对象的使用为例<br><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/oo_images/poly.png" alt="合并同类项示意图"><ul>
<li>这里以<code>poly3</code>对象为例，在第一次合并同类项之前，<code>poly3</code>已经被创建，作为接受合并同类项的容器，&#x3D;&#x3D;此时poly3的内部属性显然在一直改变&#x3D;&#x3D;（因为单项式一直被加入这个容器）</li>
<li>直到合并同类项完成后一直到使用前<code>poly3</code>都保持一个稳定的状态（&#x3D;&#x3D;但是此时修改poly3的属性我认为仍然符合我的定义&#x3D;&#x3D;）</li>
<li>最后当<code>poly3</code>投入合并同类项时，其已经在&#x2F;被使用了，&#x3D;&#x3D;此后应该保证poly3属性永远不再改变&#x3D;&#x3D;</li>
</ul>
</li>
</ul>
<h6 id="b-克隆"><a href="#b-克隆" class="headerlink" title="b.克隆"></a>b.克隆</h6><table>
<thead>
<tr>
<th align="center">传递方式</th>
<th align="center">描述</th>
<th align="center">使用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">值传递</td>
<td align="center">实例对象栈上开辟空间，栈存储内容为值，传递时将存储的值给出</td>
<td align="center">简单类型(int char…)</td>
</tr>
<tr>
<td align="center">引用传递</td>
<td align="center">实例对象堆上开辟空间，栈存储内容为地址，传递时传递将地址给出</td>
<td align="center">复杂类型(一般JavaBin类)</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">克隆方式</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">浅克隆</td>
<td align="center">地址与原对象不同，实例对象内简单类型重新创建，复杂类型传递引用</td>
</tr>
<tr>
<td align="center">深克隆</td>
<td align="center">地址与原对象不同，实例对象内简单类型重新创建，复杂类型递归创建新的实例</td>
</tr>
</tbody></table>
<p>发现往年有许多学长提出遇到深浅克隆的问题，但是他们大都采取了深克隆的方式较为保险的操作。但是若Poly类与Var类深度耦合，你中有我，我中有你。深克隆该如何进行？<br>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Poly.java</span></span><br><span class="line"><span class="comment">//HashMap&lt;Var, BigInteger&gt; varMap</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">Poly</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Poly</span>();</span><br><span class="line">  <span class="keyword">for</span> (Var <span class="keyword">var</span> : varMap.keySet()) &#123;</span><br><span class="line">    res.addVar((Var) <span class="keyword">var</span>.clone());  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Var.java</span></span><br><span class="line"><span class="comment">//BigInteger coe</span></span><br><span class="line"><span class="comment">//BigInteger exp</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Var</span>(coe, exp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>将深克隆实现为递归形式，在后续迭代过程中也可以很好的解决<code>Poly</code>与<code>Var</code>之间的耦合关系。例如，为<code>Var</code>类新加一个<code>Poly</code>的属性，我们只需要微调即可。分析可以发现，这并不是一个无限递归的函数，在<code>varMap</code>为空时整个递归达到底部。<br>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Var.java</span></span><br><span class="line"><span class="comment">//+ Poly expPoly</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Var</span>(coe, exp, (Poly) expPoly.clone());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>但是递归的终点实在是太长了，深克隆是一笔巨大的开销。故而我们不能困于此，我们更多的程序开销应该用来卷性能（），得益于我们类的设计理念，深克隆实际是可以完全规避的</p>
<p>之所以使用深克隆是为了保护数据的一直性，尤其是在引用这种前提下，一个对象可能有多个引用。此时通过某一个引用的修改可能导致其他引用获取到错误的数据。为此可以将将要修改的对象从里到外复制一遍再使用。</p>
<p>回顾我们的设计，我们的Poly类与Var类在投入使用后属于不可改变的状态，自然不存在内部数据被修改而导致的若干现象，省下一大笔性能开销</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Poly.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Poly</span><span class="params">(HashMap&lt;Var, BigInteger&gt; varMap)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.varMap = varMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// HashMap克隆方式也是浅克隆，键值对是引用</span></span><br><span class="line">  HashMap&lt;Var, BigInteger&gt; newVarMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>(<span class="built_in">this</span>.varMap);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Poly</span>(newVarMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="c-多项式存储"><a href="#c-多项式存储" class="headerlink" title="c.多项式存储"></a>c.多项式存储</h6><p>因为我们时常需要合并同类项，因此能否快速找到同类项十分重要。使用<code>HashSet</code>、<code>HashMap</code>这类使用哈希索引的数据结构十分方便，但是需要重写<code>hashCode</code>和<code>equals</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Var.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> Objects.hash(exp);</span><br><span class="line">  <span class="comment">//不需要比较系数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (o == <span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Var)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">Var</span> <span class="variable">var</span> <span class="operator">=</span> (Var) o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">var</span>.getExp() == exp;</span><br><span class="line">  <span class="comment">//同样只需要判断指数，不需要系数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对于<code>Var</code>类型实现了以后，使用<code>HashSet&lt;Var&gt;</code>就十分方便了，之所以使用<code>HashMap</code>主要时考虑到判断<code>Poly</code>是否相等时需要考虑系数<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Poly.java</span></span><br><span class="line"><span class="comment">//HashSet&lt;Var&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (o == <span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Poly)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">Poly</span> <span class="variable">var</span> <span class="operator">=</span> (Poly) o;</span><br><span class="line">  <span class="keyword">return</span> Objects.equals(varSet, <span class="keyword">var</span>.getVarSet());</span><br><span class="line">  <span class="comment">//此方法比较两个Set中的元素是否能满足equals方法</span></span><br><span class="line">  <span class="comment">//根据我们重写的Var的equals方法，其只考虑了指数</span></span><br><span class="line">  <span class="comment">//即2*x+3*x^2与1*x-3*x^2会被判断为相等</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//改为HashMap&lt;Var, BigInteger&gt; </span></span><br><span class="line"><span class="comment">//var &lt;-&gt; coe</span></span><br><span class="line"><span class="keyword">return</span> Objects.equals(varMap, <span class="keyword">var</span>.getVarMap());</span><br><span class="line"><span class="comment">//比较键值对，所以系数作为值被考虑在内</span></span><br><span class="line"><span class="comment">//即2*x+3*x^2与1*x-3*x^2不同</span></span><br></pre></td></tr></table></figure>
<font color=red><em>tips：</em></font>由于我们设计的<code>Poly</code>与<code>Var</code>具有投入使用后不可改变的特性，故而我们可以尝试缓存对应的<code>hash</code>值，这样可以减少调用<code>hashCode()</code>的性能开销</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">//cached hashCode</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> hash;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hasCode</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (hash == <span class="number">0</span>) &#123;</span><br><span class="line">    hash = Objects.hash(......);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-复杂度分析"><a href="#3-复杂度分析" class="headerlink" title="3.复杂度分析"></a>3.复杂度分析</h3><p><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/oo_images/hw_1_com_1.png" alt="alt text"><br><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/oo_images/hw_1_com_2.png" alt="alt text"><br>这里只列出来爆红的几个方法</p>
<ul>
<li><code>preProcess</code>里面放了一个合并正负号的循环，复杂度很高</li>
<li><code>Lexer</code>构造方法因为有很多条件分支，导致所有都爆红</li>
<li><code>Poly.toString</code>由于也是有将<strong>正数项</strong>提前，导致复杂度偏高</li>
</ul>
<h3 id="4-bug分析"><a href="#4-bug分析" class="headerlink" title="4.bug分析"></a>4.bug分析</h3><p>本次作业强测、互测均为出现bug<br>由于本次作业是第一次迭代作业，主要搭好解析表达式的框架，作业中要求的多项式、单项式的结构也并不复杂，且显然存在最优解，故本次作业细心就不会出现任何问题</p>
<ul>
<li>构造数据后可以直接使用sympy对拍，对于多项式的处理sympy还是比较擅长的</li>
</ul>
<hr>
<h2 id="第二次作业"><a href="#第二次作业" class="headerlink" title="第二次作业"></a>第二次作业</h2><h3 id="1-架构设计"><a href="#1-架构设计" class="headerlink" title="1.架构设计"></a>1.架构设计</h3><p>就上次作业而言，本次作业新加入<code>递推函数</code>与<code>三角函数因子</code>，难度跨度相较前几年应该是较大，大概是从<code>hw1</code>跳转<code>hw3</code>左右。递推函数实则原先自定义函数+嵌套调用，三角函数内因子类型不限制，化简难度较大<br><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/oo_images/class_2.png" alt="alt-text"><br>(.p.s虽然说<del>字符串替换是陋习</del>，但是在语法树层面的替换容易出现一些神奇的问题，比如形参的实参是形参。。。，除了递归搜索替换也没有其他好的方法)<br><code>funcDefiner类</code></p>
<ul>
<li>定义为工具类，内部全为静态方法</li>
<li>存储所有递推函数信息（预防迭代）<ul>
<li><p><strong><code>funcMap: HashMap&lt;String, HashMap&lt;String, String&gt;&gt;</code></strong></p>
<ul>
<li>将函数名，与调用信息存起来</li>
<li>第一步映射<code>函数名 -&gt; 函数体</code>，为了防止多个递推函数，使用<code>HashMap</code>存储</li>
<li>第二步，针对不同情况下<code>n</code>的取值确定函数体，同样使用<code>HashMap</code>存储</li>
<li><code>f&#123;1&#125;(x...) = ...</code>，递推的基础<ul>
<li><code>&quot;1&quot; -&gt; ...</code></li>
</ul>
</li>
<li><code>f&#123;0&#125;(x...) = ...</code>，递推的基础<ul>
<li><code>&quot;0&quot; -&gt; ...</code></li>
</ul>
</li>
<li><code>f&#123;n&#125;(x...) = f&#123;n-1&#125;(x...) + f&#123;n-2&#125;(x...)</code>，递推公式<ul>
<li><code>&quot;n&quot; -&gt; f&#123;n-1&#125;(x...) + f&#123;n-2&#125;(x...)</code></li>
</ul>
</li>
<li>获取函数<code>f</code>的递推公式 -&gt; <code>funcMap.get(&quot;f&quot;).get(&quot;n&quot;)</code></li>
<li>获取函数<code>g</code>的0的值 -&gt; <code>funcMap.get(&quot;g&quot;).get(&quot;0&quot;)</code></li>
</ul>
</li>
<li><p><strong><code>paraMap: HashMap&lt;String, ArrayList&lt;String&gt;&gt;</code></strong></p>
<ul>
<li>将函数名，与形参列表存起来</li>
<li><code>函数名 -&gt; 形参列表</code></li>
</ul>
</li>
<li><p><strong><code>setFunc(Scanner)</code></strong></p>
<ul>
<li>根据传入的<code>n</code>、三个递推式子，收集函数信息</li>
<li>记得预处理，去除空白符号以及可能的连续正负号</li>
</ul>
</li>
<li><p><strong><code>callFunc(funcName, n, Actualparas)</code></strong></p>
<ul>
<li><code>funcName</code>传入此次需要调用的函数</li>
<li><code>n</code>传入此次递归函数的索引值<code>f&#123;3&#125;... -&gt; &quot;3&quot;...</code></li>
<li>若<code>n</code>不为<code>0 or 1</code>，否则直接使用函数体即可<ul>
<li>找到函数体中所有<code>n</code>的位置，根据<code>n</code>位置后的符号与数字替换</li>
<li><code>n=3</code>,<code>f&#123;n-1&#125;(x,y^2)+f&#123;n-2&#125;(x^2,y)</code><ul>
<li><code>f&#123;2&#125;(x,y^2)+f&#123;1&#125;(x^2,y)</code></li>
</ul>
</li>
</ul>
</li>
<li>将形参替换为实参<ul>
<li><code>ActualParas = [Factor1, Factor2]</code> 使用表达式因子，原因在后面，<strong>使用Poly对象的<code>toString()</code>，因为有些情况可以化简，如果直接输出可能会卡爆堆</strong></li>
</ul>
</li>
<li><font color=red>记忆化递归：</font>这里的递归我们<code>funcMap</code>没有存储<code>0,1,n</code>之外的值，事实上我们计算一个表达式的函数体可以先查表例如<code>3</code>，显然不在表内，所以根据<code>f&#123;n&#125;...</code>的递推式计算出<code>f&#123;3&#125;</code>对应的函数体，<strong>然后把3加入表内，这样我们的表就变为<code>0,1,3,n</code>了</strong>，下次需要使用<code>f&#123;3&#125;</code>时只需要查表即可，不需要重复替换</li>
</ul>
</li>
<li><p><strong><code>parseFuncFactor</code></strong></p>
<ul>
<li>读入函数名、还有此次的n值</li>
<li>读入实参列表时，请使用<code>parseExpr</code>后封装为<code>ExprFactor</code>，因为原有形参可能是幂函数，被替换一次后将不再是因子</li>
<li><code>f&#123;n&#125;(x, y) = f&#123;n-1&#125;(x^2, y) + f&#123;n-2&#125;(x, y^2)</code></li>
<li>求<code>f&#123;3&#125;((x+1), x)</code>时</li>
<li><code>n=3: (x+1), x</code>实参为表达式因子</li>
<li><code>n=2: (x+1)^2, x; (x+1), x^2</code>出现非因子项，只能使用表达式表示</li>
</ul>
</li>
<li><p><strong><code>ParaFactor</code></strong></p>
<ul>
<li>为了提高封装性，可以新建类代表实参因子，其他同理</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-流程分析-1"><a href="#2-流程分析-1" class="headerlink" title="2.流程分析"></a>2.流程分析</h3><p>大部分内容和第一次作业是一致的，此处不再赘述，此次作业唯一不同的在于三角函数的化简内容。</p>
<h4 id="三角函数化简"><a href="#三角函数化简" class="headerlink" title="三角函数化简"></a>三角函数化简</h4><blockquote>
<p><code>Poly</code>代表多项式类，形如<code>Var1 + Var2 + Var3...</code><br><code>Var</code>代表单项式类，形如$coe\times x^{exp}\times\prod_{i&#x3D;1}^n{sin(expr_i)^{a_i}}\times\prod_{j&#x3D;1}^n{cos(expr_j)^{b_j}}$</p>
</blockquote>
<p>基于同类项的三角函数化简</p>
<h5 id="什么是同类项"><a href="#什么是同类项" class="headerlink" title="什么是同类项"></a>什么是同类项</h5><p>在第一次作业中，单项式的形式极为简单，我们可以认为除去系数，<strong>指数相等的单项式就是同类项</strong>，即<code>coe1 * x^exp</code>&#x2F;<code>coe2 * x^exp</code><br>在第二次作业中我们引入了三角函数因子，单项式的复杂度急剧上升，甚至由于<strong>三角函数本身可以向内或向外传递负号</strong>，同类项甚至很难以一种形式化的方式表述出。例如，<code>x*sin(x)</code>与<code>3*x*sin(x)</code>显然是同类项，但是<code>x*sin(x)</code>与<code>3*x*sin((-x))</code>实际上也是同类项，二者同样可以合并。此时判断除系数外的部分相同已经不奏效了，故定义&#x3D;&#x3D;可加&#x3D;&#x3D;作为同类项的标准</p>
<ul>
<li>对于<code>Var</code>类，&#x3D;&#x3D;可加&#x3D;&#x3D;意味<strong>指数相等</strong>，二者的三角函数部分组成的集合（<code>sin</code>、<code>cos</code>）需要满足某种双射，使得双射的两方<ul>
<li><strong>三角函数种类相等</strong>(同为<code>sin</code>或<code>cos</code>)</li>
<li><strong>三角函数因子的指数相等</strong></li>
<li><strong>三角函数内部的<code>Poly</code>满足可加</strong></li>
</ul>
</li>
<li>对于<code>Poly</code>类，<strong>可加</strong>意味着，其中的单项式集合满足某种双射，使得双射的两方<ul>
<li><strong>可加</strong></li>
<li>将所有<strong>可加的Var</strong>通过正负号变换为相同格式后，对应的所有<code>Var</code>的<strong>系数相同或者互为相反数</strong></li>
</ul>
</li>
<li>举例·<ul>
<li><code>x</code>与<code>-2*x</code>是可加的</li>
<li><code>x + sin(x)</code>与<code>-x + sin((-x))</code>是可加的</li>
<li><code>x + sin(x)</code>与<code>-x - sin((-x))</code>不是可加的</li>
<li><code>2*sin((x-1))^2</code>与<code>3*sin((1-x))^2</code>是可加的</li>
<li><code>x + 2*sin((x-1))^2</code>与<code>x + 3*sin((1-x))^2</code>是不可加的</li>
<li><code>sin((cos((x-1))+1))</code>与<code>-sin((-1-cos((1-x))))</code>是可加的</li>
<li><code>sin((x^2-cos((x-sin((1-x))))^3-cos((x-sin((1-x))))^1+1-sin((cos((x^2-2*x+1))^2-x+1))^2-sin((cos((x^2-2*x+1))^2-x+1))^3))</code>与<code>sin((x^2-cos((-x-sin((x-1))))^3-cos((-x-sin((x-1))))^1+1-sin((-cos((-x^2+2*x-1))^2+x-1))^2+sin((-cos((-x^2+2*x-1))^2+x-1))^3))</code>是可加的</li>
</ul>
</li>
</ul>
<p>可以比较容易地看出来，&#x3D;&#x3D;可加&#x3D;&#x3D;的定义满足一种递归的形式，这主要是因为<code>Poly</code>和<code>Var</code>内部是深度耦合的，其对应的数据结构是递归形式的，所以我们设计的某种算法也应该遵循其结构，体现为递归形式</p>
<h5 id="如何识别同类项"><a href="#如何识别同类项" class="headerlink" title="如何识别同类项"></a>如何识别同类项</h5><p>如果觉得递归麻烦的话可以参考后面的<a href="#%E8%AF%86%E5%88%AB%E5%90%8C%E7%B1%BB%E9%A1%B9%E5%8A%A0%E9%80%9F">近似算法</a></p>
<p>也许现在我们已经明晰了什么样的结构是&#x3D;&#x3D;可加&#x3D;&#x3D;的，是同类项。但是重要的是我们还需要代码能够知道什么样的结构是&#x3D;&#x3D;可加&#x3D;&#x3D;的，为此我们专门在优化类中定义两个方法</p>
<ul>
<li><code>public static boolean canAddVar(Var var1, Var var2)</code></li>
<li><code>public static boolean canAddPoly(Poly poly1, Poly poly2)</code></li>
</ul>
<p>具体实现可以参考以下结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1代表两项可加，且数学意义上同号</span></span><br><span class="line"><span class="comment">// -1代表两项可加，且数学意义上异号</span></span><br><span class="line"><span class="comment">// 0代表两项不可加</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">canAddVar</span><span class="params">(Var var1, Var var2)</span> &#123;</span><br><span class="line">    <span class="comment">//若指数不同直接返回</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//若sin集合数目不等直接返回</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//若cos集合数目不等直接返回</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断双射只能使用循环了</span></span><br><span class="line">    <span class="keyword">for</span> (Poly poly : var1.sinMap) &#123;</span><br><span class="line">        <span class="comment">//判断var2中sinMap是否有与poly可加的项</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sign</span> <span class="operator">=</span> contains(var2.sinMap, poly)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不含则直接返回</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同理判断cosMap中是否有</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">containsPoly</span><span class="params">(HashMap&lt;?,?&gt;sinMap, Poly poly)</span> &#123;</span><br><span class="line">    <span class="comment">//首先可以检测sinMap中是否含有key</span></span><br><span class="line">    sinMap.containsKey(poly)</span><br><span class="line">    <span class="comment">//还可以判断是否有poly.negate()</span></span><br><span class="line">    sinMap.containsKey(poly.negate())</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若都不存在则可以循环判断是否可加</span></span><br><span class="line">    <span class="keyword">for</span> (Poly other : sinMap) &#123;</span><br><span class="line">        <span class="comment">//适当剪枝</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="type">int</span> <span class="variable">sign</span> <span class="operator">=</span> canAddPoly(poly, other)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">canAddPoly</span><span class="params">(Poly poly1, Poly poly2)</span> &#123;</span><br><span class="line">    <span class="comment">//判别个数等剪枝</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">allSign</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">first</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (Var <span class="keyword">var</span> : poly1.varMap) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">sign</span> <span class="operator">=</span> containsVar(poly2, <span class="keyword">var</span>)</span><br><span class="line">        <span class="comment">//若不含则直接返回</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//若符号不符则立即返回</span></span><br><span class="line">        <span class="keyword">if</span> (fisrt) &#123;</span><br><span class="line">            allSign = sign;</span><br><span class="line">            first = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (allSign != sign) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">containsVar</span><span class="params">(Poly poly, Var <span class="keyword">var</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//适当剪枝</span></span><br><span class="line">    <span class="keyword">for</span> (Var other : poly.varMap) &#123;</span><br><span class="line">        <span class="comment">//适当剪枝</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="type">int</span> <span class="variable">sign</span> <span class="operator">=</span> canAddVar(other, <span class="keyword">var</span>)</span><br><span class="line">        <span class="comment">//不可加返回</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="识别同类项加速"><a href="#识别同类项加速" class="headerlink" title="识别同类项加速"></a>识别同类项加速</h5><p>由于我们识别同类项的式子是一个递归式，最坏的情况可能接近$O(n)$(还是在剪枝相当不错，可以尽早发现两个式子不是同类项的时候，否则大概是$O(n^{n^{n^{…}}})$，这为我们的程序性能带来了极大的打击。为此我们可以通过一些预处理的手段加速我们识别同类项的速度————<strong>尽可能地规定一个范式</strong>，因为我们无法判定含三角函数的一大难点就是同类项可能差异巨大，难以通过一般方式识别</p>
<p>对于三角函数内可以提出负号的情况例如<code>sin((-x-1))</code>和<code>sin((-x))</code>，我们可以化简为<code>-sin((x+1))</code>和<code>-sin(x)</code>。而且可以看出这样的提出方式显然是有利无害的</p>
<p>接下来对于有正有负的情况我们到底是提负号还是不提负号呢，答案是比较<code>hash</code>值，其实这样想到主要是因为三角函数内部是<code>Poly</code>，而<code>Poly</code>内部天生的缓存了<code>hash</code>。所以我们可以判断一下<code>Poly</code>和<code>Poly.negate()</code>两个对象那个hash比较大&#x2F;小（规则统一即可），这样我们可以递归地证明大部分情况下是可以正确处理好同类项的</p>
<p>最后还有一种极为特殊的情况，<code>Poly</code>与<code>Poly.negate()</code>的<code>hash</code>值相等怎么办，那我到底取反还是不取反呢。例如我自己测试时发现<code>cos((x^2-2*x+1))</code>与<code>cos((-x^2+2*x-1))</code>的<code>hash</code>值是相等的，那么此时可以</p>
<ul>
<li>使用之前的递归判断方式，增大耗时以求最最最准确的答案</li>
<li>放弃优化，认为这种情况出现的概率实在是太低了，前面的方案已经足以应对绝大部分情况而且性能极佳<blockquote>
<p>如何选择全凭个人，但是追求性能的同时不要忽视正确性和程序运行性能，顾此失彼、因小失大并不是明智的选择<br>就像我是选择了最求最最最准确的答案，并对一些极端情况做了测试，效果并不差</p>
</blockquote>
</li>
</ul>
<h5 id="如何利用可加项化简"><a href="#如何利用可加项化简" class="headerlink" title="如何利用可加项化简"></a>如何利用可加项化简</h5><blockquote>
<p>若知道<code>expr1</code>与<code>expr2</code>可加，<code>expr3</code>与<code>expr4</code>可加且同号</p>
</blockquote>
<ul>
<li><code>c * 2^i * sin(expr1)^i * cos(expr2)^i</code> (sin二倍角公式)<ul>
<li><code>c * sin(2*expr1)^i</code></li>
</ul>
</li>
<li><code>c1 * expr3 * sin(expr1)^2 + c2 * expr4 * cos(expr2)^2</code> (平方和公式变形) <ul>
<li>若<code>c1 == c2</code>，<code>c1/c2 * expr3</code></li>
<li>若<code>c1 &gt; c2</code>，<code>c2 * expr3 + (c1 - c2) * expr4 * sin(expr1)^2</code></li>
<li>若<code>c2 &lt; c2</code>，<code>c1 * expr3 + (c2 - c1) * expr4 * cos(expr2)^2</code></li>
</ul>
</li>
<li><code>c1 * expr3 * sin(expr1)^2 - c2 * expr4 * cos(expr2)^2</code> (cos二倍角公式)<ul>
<li>若<code>c1 == c2</code>，<code>- c2 * expr4 * cos(2*expr2)</code></li>
</ul>
</li>
</ul>
<h3 id="3-复杂度分析-1"><a href="#3-复杂度分析-1" class="headerlink" title="3.复杂度分析"></a>3.复杂度分析</h3><p><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/oo_images/hw_2_com.png" alt="alt text"></p>
<ul>
<li>本次作业的重灾区在三角函数化简部分，由于有大量的剪枝，导致复杂度特别高，看起来较难进一步减少复杂度</li>
<li>其余上次作业的部分有所改善</li>
</ul>
<h3 id="4-bug分析-1"><a href="#4-bug分析-1" class="headerlink" title="4.bug分析"></a>4.bug分析</h3><p>本次作业强测、互测均未出现bug</p>
<p>值得一提的是，由于本次作业跨度过大，导致就算是A房也是血流成河。房间里大致发现了9个bug左右。有些人的bug太过简单导致经常输出，最后有效刀16刀，总结一下出现的各类bug</p>
<ul>
<li>自定义递推函数形参替换问题，使用<strong>replace替换两遍</strong>，这对于<code>f(x, y)</code>是没有问题的，但是对于<code>f(y, x)</code>会导致形参<code>y</code>的实参中的<code>x</code>再次被错误替换</li>
<li>错误判等条件，有同学的<code>Poly</code>类相等方法是<code>return hashCode() == poly.hashCode()</code>，这个错误是显然的，这位同学并没有考虑<code>hash</code>冲突的情况</li>
<li>输出调试信息，有一位同学在三角函数化简时会输出<code>extra ....</code>的调试信息</li>
<li>格式问题，有同学在化简括号过程中<code>sin(-2*x)</code>必要括号未保留</li>
<li>符号处理不到位，有位同学一边建树一边化简，由于保留符号的地方太多而混淆，导致识别正负号有问题</li>
</ul>
<p>惨烈的<code>hw2</code>（），有点可惜的是在周六上午还想到了可以和差化积化简，但是最后由于下午做志愿打消了这个想法，没想到最后强测性能中真的出现了。故在第三次作业中实现了和差化积</p>
<hr>
<h2 id="第三次作业"><a href="#第三次作业" class="headerlink" title="第三次作业"></a>第三次作业</h2><h3 id="1-代码架构分析-1"><a href="#1-代码架构分析-1" class="headerlink" title="1.代码架构分析"></a>1.代码架构分析</h3><p><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/oo_images/class_3.png" alt="alt-text"><br>本次作业加入了求导因子和自定义函数因子</p>
<p>针对自定义函数，可以单纯理解为一个自定义递推函数，这个自定义递推函数只有初始化的函数体，其他直接套用自定义递推函数</p>
<p>针对求导因子，我将其设置在<code>Poly</code>与<code>Var</code>对象中，因为<code>Poly</code>与<code>Var</code>中已经实现了大部分的化简操作，这样直接对化简完的<code>Poly</code>对象进行求导操作复杂度更低一些，举一个不符合互测限制的例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">h(y) = cos(cos(cos(cos(cos(cos(cos(y)))))))</span><br><span class="line">g(x) = sin(sin(sin(sin(sin(sin(sin(h(x))))))))</span><br><span class="line">1</span><br><span class="line">f&#123;0&#125;(x) = cos(cos(cos(cos(cos(cos(x))))))</span><br><span class="line">f&#123;1&#125;(x) = sin(sin(sin(sin(sin(sin(x))))))</span><br><span class="line">f&#123;n&#125;(x) = 1*f&#123;n-1&#125;(h(x)) + 1*f&#123;n-2&#125;(g(x))</span><br><span class="line">dx(f&#123;5&#125;(x) - f&#123;5&#125;(x) + f&#123;5&#125;(x) - f&#123;5&#125;(x) + f&#123;5&#125;(x) - f&#123;5&#125;(x))</span><br><span class="line">&gt;&gt;&gt; 0</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果求导因子最后返回表达式的话，大概中间会得到一个特别长的式子，大概率会爆堆。但是如果先对内部进行化简会发现里面实际是0，这样可以减少空间占用</p>
</blockquote>
<p>将<code>Poly</code>理解为若干<code>Var</code>相加，<code>Var</code>是由多个基本项相乘</p>
<ul>
<li><code>Poly.derive()</code>方法就很简单了，调用<code>Var.derive()</code>相加即可</li>
<li><code>Var.derive()</code>的实现略显复杂，考虑将<code>Var</code>分为三份<code>x ^ exp</code>、<code>sinMap</code>、<code>cosMap</code>，分别对其求导再运用乘法原则<ul>
<li>同理对于<code>sinMap</code>和<code>cosMap</code>内部的<code>Poly</code>运用链式法则即可</li>
</ul>
</li>
</ul>
<h3 id="2-流程分析-2"><a href="#2-流程分析-2" class="headerlink" title="2.流程分析"></a>2.流程分析</h3><p>因为第二次作业中化简表达式不彻底，有三个点性能分为0（），早知道就早点实现和差化积了。所以本次作业加入了如下的化简，并且优化了一下平方和公式的变形</p>
<h5 id="如何利用可加项化简-续"><a href="#如何利用可加项化简-续" class="headerlink" title="如何利用可加项化简(续)"></a>如何利用可加项化简(续)</h5><blockquote>
<p>若知道<code>expr1</code>与<code>expr2</code>可加，<code>expr3</code>与<code>expr4</code>可加且同号<br><code>expr5、expr6</code>满足可加，<code>expr7、expr8</code>满足可加</p>
</blockquote>
<ul>
<li><code>c * 2^i * sin(expr1)^i * cos(expr2)^i</code> (sin二倍角公式)<ul>
<li><code>c * sin(2*expr1)^i</code></li>
</ul>
</li>
<li><code>c1 * expr3 * sin(expr1)^2 + c2 * expr4 * cos(expr2)^2</code> (平方和公式变形 + cos二倍角公式) <ul>
<li>若<code>c1 == c2</code>，<code>c1/c2 * expr3/expr4</code>(.p.s这个其实是第三种情况的一种剪枝。。。)</li>
<li>若<code>c1 == -c2</code>， <code>c2 * expr4 * cos(2*expr2/2*expr1)^2</code></li>
<li>否则<code>c2 * expr4 * cos(expr2)^2 --&gt; c2 * expr4 - c2 * expr4 * sin(expr2)^2</code>然后就可以合并同类项了</li>
</ul>
</li>
<li><code>expr1 * sin(expr5) * cos(expr7) +- expr2 * sin(expr6) * cos(expr8)</code> (sin加减)<ul>
<li><code>expr1 * sin(expr5 +- expr7)</code></li>
</ul>
</li>
<li><code>expr1 * cos(expr5) * cos(expr7) +- expr2 * sin(expr6) * sin(expr8)</code> (cos加减)<ul>
<li><code>expr1 * cos(expr5 +- expr7)</code></li>
</ul>
</li>
</ul>
<h3 id="3-复杂度分析-2"><a href="#3-复杂度分析-2" class="headerlink" title="3.复杂度分析"></a>3.复杂度分析</h3><p><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/oo_images/hw_3_com.png" alt="alt text"></p>
<ul>
<li>同上次，因为三角函数化简需要剪枝的部分实在是太多，导致整片地方都是爆红区。这部分内容极难优化，纯粹是因为三角函数化简操作实在是过分复杂</li>
</ul>
<h3 id="4-bug分析-2"><a href="#4-bug分析-2" class="headerlink" title="4.bug分析"></a>4.bug分析</h3><p>本次作业强测、互测均为出现bug<br>首先值得一提的是，测评机出现了bug，导致无法判别化简式与原式是否相等，本人在互测中因此被砍了两刀，不过最后还是撤刀了。其实这也体现出大家自己搭的测评机判等也是有点问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cos((cos(x) - sin(x))^3)</span><br><span class="line">cos(cos(x)+2*sin(x)^2*cos(x)-sin(x)-2*sin(x)*cos(x)^2)</span><br></pre></td></tr></table></figure>
<p>不过我认为这是情有可原的，含有三角函数的式子判等本来就相当艰难，在第二次作业的测评机中，我和室友讨论最后决定使用<strong>多次随机点数值计算+误差判断</strong>的方式判断。且使用了相对误差（避免因为计算数值过大导致的绝对误差过大）、<code>1e-7</code>左右的误差是较好的</p>
<p>但是在第三次作业中发现了一些缺陷，对于部分在0附近突变的函数值，随机点无法很好地去除这些极端点，导致即使是相对误差也会有极大的缺陷。这时陷入了两难的境地，相对误差和绝对误差的效果都很差，所以最后使用的方案是<strong>特高精度随机点数值计算+相对误差&#x2F;绝对误差同时使用</strong></p>
<ul>
<li>使用了<code>mpmath</code>库，精度到达了小数点后50位（此处<code>dps</code>和下面的<code>1e-15</code>需要互相配合，否则还是会出现误判的情况）</li>
<li>对于函数值小于<code>1e-15</code>的值，误差使用绝对误差</li>
<li>其余使用相对误差</li>
</ul>
<p>咳咳，还是说说同房同学的bug，本次找到的bug较少（大家都没啥bug加上被刀了心情不太好（差点破金身了）</p>
<ul>
<li>有同学求导对于负号的处理出现问题，反转多次导致bug</li>
<li>有同学没有考虑到出现<code>h(x, y) = x...</code>这种只出现一个自变量表达式的情况</li>
<li>有同学深拷贝耗时太多，被sin、cos串卡T了（拿一个房间其他人提交上去的样例），我也整了一个，不过因为cost没交上去，后来想回来改的时候发现被刀了:sob:，所以就结束了悲伤的互测环节（<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">h(x)=cos(cos(cos(cos(x))))</span><br><span class="line">g(x)=cos(cos(cos(cos(h(x)))))</span><br><span class="line">0</span><br><span class="line">cos(cos(cos(cos(cos(cos(g(g(g(x)))))))))</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>OO</category>
      </categories>
      <tags>
        <tag>OO</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础--字符串(一)</title>
    <url>/2024/09/21/Python_%E5%AD%97%E7%AC%A6%E4%B8%B2_1/</url>
    <content><![CDATA[<h1 id="Python基础之字符串-一"><a href="#Python基础之字符串-一" class="headerlink" title="Python基础之字符串(一)"></a>Python基础之字符串(一)</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><font face="宋体">
&nbsp;&nbsp;随着计算机发展日益加快，就算对于非计算机专业人士也通过键盘、鼠标等IO组件与计算机进行沟通。我们手指的每一次敲击，都传送给计算机输入某个“字符”的信号，字符与字符串不仅是编程语言的基本组成元素，更是我们与计算机交流的桥梁
<br>
&nbsp;&nbsp;对于<mark class="hl-label blue">Python</mark> 这门现代编程语言，字符串的操作也是重中之重，接下来让我们一起学习有关字符串的内容吧
</font>

<h2 id="什么是字符串"><a href="#什么是字符串" class="headerlink" title="什么是字符串"></a>什么是字符串</h2><h3 id="字符串的创建"><a href="#字符串的创建" class="headerlink" title="字符串的创建"></a>字符串的创建</h3><ul>
<li>对于较早的C语言等，字符一般而言指<code>acsii</code>规定的128个字符，包括英文字母、数字、一些控制字符，而由这些字符组成的一串字符被形象地称作字符串<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">char</span> str[<span class="number">10</span>] = <span class="string">&quot;abcde&quot;</span>;</span><br></pre></td></tr></table></figure></li>
<li>而<code>Python3</code>采用了号称万国码的<code>Unicode</code>字符集，可以表示包括中文、阿拉伯文等多国文字在内的若干字符，当然通过<code>Python</code>内置的编码、解码函数可以实现<code>utf-8</code>、<code>ascii</code>等其他编码方式之间的互相转换，当然这是后话了<br><strong>这里放一个编码的链接</strong></li>
<li>在<code>Python</code>中没有字符和字符串的明显区别，字符串可以使用<code>&#39;</code>或者<code>&quot;</code>定义，甚至对于多行字符串，可以使用<code>&quot;&quot;&quot;</code>或者<code>&#39;&#39;&#39;</code>来包含多行文本而不用在字符串间换行位置使用换行符<code>\n</code>，甚至允许使用<code>\</code>来拼接多行字符串为一行<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python中没有字符和字符串的区分</span></span><br><span class="line">char_one = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">char_two = <span class="string">&quot;a&quot;</span></span><br><span class="line">chars = <span class="string">&#x27;abcde&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(char_one)</span><br><span class="line"><span class="built_in">print</span>(char_two)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多行字符串</span></span><br><span class="line">lines = <span class="string">&quot;&quot;&quot;this is a long string</span></span><br><span class="line"><span class="string">that spans multiple lines&quot;&quot;&quot;</span></span><br><span class="line">lines_single = <span class="string">&#x27;&#x27;&#x27;this is also a long </span></span><br><span class="line"><span class="string">string</span></span><br><span class="line"><span class="string">that spans mutiple lines too&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(lines)</span><br><span class="line"><span class="built_in">print</span>(lines_single)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拼接多行字符</span></span><br><span class="line">new_lines = <span class="string">&quot;this is a long string&quot;</span>\</span><br><span class="line">            <span class="string">&quot;that over&quot;</span>\</span><br><span class="line">            <span class="string">&quot;multiple lines&quot;</span></span><br><span class="line"><span class="built_in">print</span>(new_lines)</span><br></pre></td></tr></table></figure>
<details class="toggle" ><summary class="toggle-button" style="">输出内容</summary><div class="toggle-content"><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line">a</span><br><span class="line">this is a long string</span><br><span class="line">that spans multiple lines</span><br><span class="line">this is also a long string</span><br><span class="line">that spans multiple lines</span><br><span class="line">this is a long string that over multiple lines</span><br></pre></td></tr></table></figure>
</div></details></li>
</ul>
<hr>
<h3 id="字符串不可变性"><a href="#字符串不可变性" class="headerlink" title="字符串不可变性"></a>字符串不可变性</h3><ul>
<li>在<code>Python</code>中所有数据都是通过引用传递与使用的，这意味着我们一般只管理指向数据的引用（<del>大概是Python不用写数据类型的原因之一</del>），传递数据一般也只是传递数据的引用而非数据本身(除深浅拷贝外) <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 简单数据类型</span></span><br><span class="line">a = <span class="number">12</span></span><br><span class="line">b = a <span class="comment"># b接收的是a的引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复杂数据类型</span></span><br><span class="line">str_a = <span class="string">&quot;1234&quot;</span></span><br><span class="line">str_b = str_a <span class="comment"># 同理接收的是引用 </span></span><br></pre></td></tr></table></figure></li>
<li>这时，小熊饼干突然想修改<code>str_b</code>的值便加入了一系列指令<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;展示修改前地址:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(str_a))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(str_b))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;展示修改前值:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(str_a)</span><br><span class="line"><span class="built_in">print</span>(str_b)</span><br><span class="line"></span><br><span class="line">str_b += <span class="string">&quot;5&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;展示修改后地址:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(str_a))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(str_b))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;展示修改后值:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(str_a)</span><br><span class="line"><span class="built_in">print</span>(str_b)</span><br></pre></td></tr></table></figure>
<details class="toggle" ><summary class="toggle-button" style="">运行结果</summary><div class="toggle-content"><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">展示修改前地址:</span><br><span class="line">140123456789056</span><br><span class="line">140123456789056</span><br><span class="line">展示修改前值:</span><br><span class="line">1234</span><br><span class="line">1234</span><br><span class="line">展示修改后地址:</span><br><span class="line">140123456789056</span><br><span class="line">342453543545131</span><br><span class="line">1234</span><br><span class="line">12345</span><br></pre></td></tr></table></figure></div></details>
我们惊奇地发现<code>str_b</code>指向的地址在修改前后发生了变化，这是因为字符串是一种<mark class="hl-label red">不可变类型</mark> ，任何针对字符串<strong>内容</strong>的改变都是不被允许的，所以我们进行修改<code>str_b</code>的操作<code>str_b += &quot;5&quot;</code>时，<code>Python</code>直接创建了一个新的变量<code>&quot;12345&quot;</code>然后将这个变量的地址赋给<code>str_b</code><details class="toggle" ><summary class="toggle-button" style="">什么是可变类型呢</summary><div class="toggle-content"><p>对于<code>str</code>、<code>tuple</code>、<code>byte</code>等<strong>不可变类型</strong>数据，一旦创立就无法修改其内容，而对于<code>list</code>、<code>dict</code>等<strong>可变类型</strong>我们允许在创立后继续修改其内容，如下</p>
<ul>
<li>甲方要求小熊饼干写一个复制一份<code>list</code>的Python文件，于是他写下如下代码<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">list_a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">list_b = list_a</span><br></pre></td></tr></table></figure>
就在他写完时，甲方要求他在复制的副本中加入其他几个元素，睡眼朦胧的小熊饼干草草地写完了代码，没想到第二天代码出了问题，原始数据<code>list</code>遭到篡改，小熊饼干因此下岗了，呜呜呜<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;打印修改前地址:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(list_a))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(list_b))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;打印修改前值:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(list_a)</span><br><span class="line"><span class="built_in">print</span>(list_b)</span><br><span class="line"></span><br><span class="line">list_b.append(<span class="number">5</span>)</span><br><span class="line">list_b.append(<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;打印修改后地址:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(list_a))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(list_b))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;打印修改后值:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(list_a)</span><br><span class="line"><span class="built_in">print</span>(list_b)</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">打印修改前地址:</span><br><span class="line">140123456789056</span><br><span class="line">140123456789056</span><br><span class="line">打印修改前值:</span><br><span class="line">[1, 2, 3, 4]</span><br><span class="line">[1, 2, 3, 4]</span><br><span class="line">打印修改后地址:</span><br><span class="line">140123456789056</span><br><span class="line">140123456789056</span><br><span class="line">打印修改后值:</span><br><span class="line">[1, 2, 3, 4, 5, 6]</span><br><span class="line">[1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure>
<font color = red>$Attention:$</font>小熊饼干通过赋值手段使<code>list_a</code>和<code>list_b</code>指向同一对象，又因为<code>list</code>类型是<strong>可变类型</strong>，所以对于其内容的修改是被允许的，这时我们可以通过<code>list_a</code>或者<code>list_b</code>中的某一个引用修改原对象内容，也就导致指向该对象的所有引用的“值”同时变化</li>
</ul>
</div></details></li>
</ul>
<hr>
<h3 id="字符串的简单操作"><a href="#字符串的简单操作" class="headerlink" title="字符串的简单操作"></a>字符串的简单操作</h3><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>如果你曾经学习过C语言，一定记得字符串(字符数组)使用下标索引的场景（<del>熟悉而美好</del>，那么当然，<code>Python</code>提供了更为强大的索引功能</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">chars = <span class="string">&quot;abcdefg&quot;</span></span><br><span class="line">char = chars[<span class="number">0</span>] <span class="comment"># a</span></span><br><span class="line">char = chars[<span class="number">4</span>] <span class="comment"># d</span></span><br><span class="line">char = chars[-<span class="number">1</span>] <span class="comment"># g</span></span><br><span class="line">char = chars[-<span class="number">2</span>] <span class="comment"># f</span></span><br></pre></td></tr></table></figure>
<p>不仅提供了正向索引还有反向的，以后获得尾部的某些字符就轻松多了</p>
<h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><p>Python中提供的一种相较于一般索引更加高级的索引方式，可以灵活地处理字符串一般格式为<code>str[start:end:step]</code></p>
<ul>
<li><code>start</code>：切片的起始索引值，缺省为字符串开头</li>
<li><code>end</code>：切片的结束索引值（不包括），缺省为字符串结束后（即包括字符串最后一个字符）</li>
<li><code>step</code>：切片的步长，默认为1  <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 正向索引</span></span><br><span class="line">test_str = <span class="string">&quot;人生苦短,我用Python&quot;</span></span><br><span class="line">chars = test_str[<span class="number">1</span>:<span class="number">3</span>] <span class="comment"># &quot;生苦&quot;</span></span><br><span class="line">chars = test_str[:<span class="number">6</span>] <span class="comment"># &quot;人生苦短,我&quot;</span></span><br><span class="line">chars = test_str[<span class="number">6</span>:] <span class="comment"># &quot;用Python&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 整段切片</span></span><br><span class="line">chars = test_str[:] <span class="comment"># &quot;人生苦短,我用Python&quot;</span></span><br><span class="line">chars = test_str[::<span class="number">2</span>] <span class="comment"># &quot;人苦，用yhn&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 倒排索引(雾</span></span><br><span class="line">chars = test_str[::-<span class="number">1</span>] <span class="comment"># &quot;nohtyP用我,短苦生人&quot;</span></span><br><span class="line">chars = test_str[<span class="number">5</span>:<span class="number">1</span>:-<span class="number">1</span>] <span class="comment"># &quot;我,短苦&quot;</span></span><br><span class="line">chars = test_str[:-<span class="number">7</span>:-<span class="number">1</span>] <span class="comment"># ”nohtyP“</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="str类"><a href="#str类" class="headerlink" title="str类"></a>str类</h2><p>相信学习过任何一门具有面向对象特性的编程语言的同学对这个词都不会陌生，简而言之，在面向对象设计中，万物都为“对象”；具有相同属性和行为的一群对象分为一个“类”，这个类抽象出对象群体共同的特性（属性）和行为（方法）</p>
<ul>
<li>在这里，各种不同的字符串都是对象，他们共同构成了类<code>str</code>，因为他们有某些共同的特性，如编码方式，有可以对所有字符串对象使用的方法，如查找子串，请你跟随小熊饼干，一起学习blog中讲解的第一个类<code>str</code></li>
<li>因为某些原因，我们将构造方法和一些魔术方法放在后续内容中介绍，敬请关注</li>
</ul>
<h3 id="内置方法（普通）"><a href="#内置方法（普通）" class="headerlink" title="内置方法（普通）"></a>内置方法（普通）</h3><h4 id="去除字符-熟练掌握"><a href="#去除字符-熟练掌握" class="headerlink" title="去除字符(熟练掌握)"></a>去除字符(熟练掌握)</h4><ul>
<li><code>str.strip(sub_string)</code><ul>
<li>从字符串左右去除所给字符串中的所有字符，缺省为空去除空白字符</li>
</ul>
</li>
<li><code>str.rstrip(sub_string)</code><ul>
<li>从字符串右去除所给字符串中的所有字符，缺省为空去除空白字符</li>
</ul>
</li>
<li><code>str.lstrip(sub_string)</code><ul>
<li>从字符串左去除所给字符串中的所有字符，缺省为空去除空白字符</li>
</ul>
</li>
<li>都只会去除连续匹配的字符，若有不匹配，则立即停止<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;  hello  &quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.strip())  </span><br><span class="line"><span class="built_in">print</span>(s.strip(<span class="string">&quot; h&quot;</span>))  </span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;  hello  &quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.lstrip()) </span><br><span class="line"><span class="built_in">print</span>(s.lstrip(<span class="string">&quot; h&quot;</span>)) </span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;  hello  &quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.rstrip()) </span><br><span class="line"><span class="built_in">print</span>(s.rstrip(<span class="string">&quot; o&quot;</span>))  </span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;abc123cba&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.strip(<span class="string">&quot;abc&quot;</span>))</span><br></pre></td></tr></table></figure>
<div class="hide-block"><button type="button" class="hide-button" style="">查看输出内容
    </button><div class="hide-content"><p>空格使用下滑线表示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hello</span><br><span class="line">ello</span><br><span class="line">hello____</span><br><span class="line">ello___</span><br><span class="line">___hello</span><br><span class="line">___hell</span><br><span class="line">123   </span><br></pre></td></tr></table></figure>
</div></div></li>
</ul>
<hr>
<h4 id="查找与计数-熟练掌握"><a href="#查找与计数-熟练掌握" class="headerlink" title="查找与计数(熟练掌握)"></a>查找与计数(熟练掌握)</h4><ul>
<li><code>str.find(sub_string)</code><ul>
<li>从字符串<strong>左端</strong>开始查找，返回第一个匹配子串的索引值，没有<strong>返回-1</strong></li>
</ul>
</li>
<li><code>str.rfind(sub_string)</code><ul>
<li>从字符串<strong>右端</strong>开始查找，返回第一个匹配子串的索引值，没有<strong>返回-1</strong></li>
</ul>
</li>
<li><code>str.index(sub_string)</code><ul>
<li>从字符串<strong>左端</strong>开始查找，返回第一个匹配子串的索引值，没有<strong>抛出异常</strong></li>
</ul>
</li>
<li><code>str.rindex(sub_string)</code><ul>
<li>从字符串<strong>右端</strong>开始查找，返回第一个匹配子串的索引值，没有<strong>抛出异常</strong></li>
</ul>
</li>
<li><code>str.count(sub_string, [start, end])</code><ul>
<li><code>[]</code>在函数注解中代表可有可无的参数</li>
<li>计算子串在这个字符串中出现的次数，可指定计数区间</li>
</ul>
</li>
<li><code>in &amp;&amp; not in</code><ul>
<li>对于字符串这种可迭代对象可以使用<code>Python</code>内置的操作符判断一个元素是否在这个对象中<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">chars = <span class="string">&quot;hello, Python! I love Python ! We all use Python&quot;</span></span><br><span class="line"><span class="built_in">print</span>(chars.find(<span class="string">&quot;Python&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(chars.rfind(<span class="string">&quot;Python&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(chars.index(<span class="string">&quot;Python&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(chars.index(<span class="string">&quot;Python&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(chars.count(<span class="string">&quot;Python&quot;</span>, <span class="number">0</span>, <span class="built_in">len</span>(chars)))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Python&quot;</span> <span class="keyword">in</span> chars)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Chi&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> chars)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(chars.index(<span class="string">&quot;Chi&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(chars.find(<span class="string">&quot;Chi&quot;</span>))</span><br></pre></td></tr></table></figure>
<div class="hide-block"><button type="button" class="hide-button" style="">查看输出内容
    </button><div class="hide-content"><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">42</span><br><span class="line">7</span><br><span class="line">7</span><br><span class="line">3</span><br><span class="line">True</span><br><span class="line">True</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;D:\Pycharm_code\math_and_\test.py&quot;</span>, line 8, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="built_in">print</span>(chars.index(<span class="string">&quot;Chi&quot;</span>))</span><br><span class="line">ValueError: substring not found</span><br></pre></td></tr></table></figure>
</div></div></li>
</ul>
</li>
</ul>
<hr>
<h4 id="实用-熟练掌握"><a href="#实用-熟练掌握" class="headerlink" title="实用(熟练掌握)"></a>实用(熟练掌握)</h4><ul>
<li><code>str.replace(string1, string2)</code><ul>
<li>将字符串中的全部<code>string1</code>都替换为<code>string2</code></li>
</ul>
</li>
<li><code>str.split(base, [count])</code><ul>
<li>将字符串按照<code>base</code>为基准分为不同的字符串，分割的次数可以显式地给出，优先从左到右，返回一个字符串列表</li>
</ul>
</li>
<li><code>str.join(itereable)</code><ul>
<li>将可迭代对象(可以先理解为数组、元组这些有基本元素的类型，字符串也是了)，将其中的元素直接使用<code>str</code>连接拼接为一个更长的字符串<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">chars = <span class="string">&quot;Python and language C&quot;</span></span><br><span class="line"><span class="built_in">print</span>(chars.replace(<span class="string">&quot;language C&quot;</span>, <span class="string">&quot;Python&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(chars.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(chars.split(<span class="string">&quot; &quot;</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>.join(chars))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&amp;&quot;</span>.join(chars.split(<span class="string">&quot; &quot;</span>)))</span><br></pre></td></tr></table></figure>
<div class="hide-block"><button type="button" class="hide-button" style="">查看输出内容
    </button><div class="hide-content"><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Python and Python</span><br><span class="line">[<span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;and&#x27;</span>, <span class="string">&#x27;language&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;and&#x27;</span>, <span class="string">&#x27;language C&#x27;</span>]</span><br><span class="line">P*y*t*h*o*n* *a*n*d* *l*a*n*g*u*a*g*e* *C</span><br><span class="line">Python&amp;and&amp;language&amp;C</span><br></pre></td></tr></table></figure>
</div></div>
<div class="note info simple"><p>字符串不可修改，所以如果需要对字符串进行操作记得用变量接收哦</p>
</div>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">chars = chars.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">new_chars = chars.split(<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h4 id="大小写转换-了解即可"><a href="#大小写转换-了解即可" class="headerlink" title="大小写转换(了解即可)"></a>大小写转换(了解即可)</h4><ul>
<li><code>str.upper()</code><ul>
<li>将字符串内所有字符转为大写</li>
</ul>
</li>
<li><code>str.lower()</code><ul>
<li>将字符串内所有字符转为小写</li>
</ul>
</li>
<li><code>str.capitalize()</code><ul>
<li>将字符串首字母大写</li>
</ul>
</li>
<li><code>str.title()</code><ul>
<li>将字符串每个单词首字母大写<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">chars = <span class="string">&quot;hello, world&quot;</span></span><br><span class="line">chars_upper = chars.upper()</span><br><span class="line">chars_lower = chars.lower()</span><br><span class="line">chars_cap = chars.capitalize()</span><br><span class="line">chars_title = chars.title()</span><br><span class="line"><span class="built_in">print</span>(chars_upper)</span><br><span class="line"><span class="built_in">print</span>(chars_lower)</span><br><span class="line"><span class="built_in">print</span>(chars_cap)</span><br><span class="line"><span class="built_in">print</span>(chars_title)</span><br></pre></td></tr></table></figure>
<div class="hide-block"><button type="button" class="hide-button" style="">查看输出内容
    </button><div class="hide-content"><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">HELLO, WORLD</span><br><span class="line">hello, world</span><br><span class="line">Hello, world</span><br><span class="line">Hello, World</span><br></pre></td></tr></table></figure>
</div></div></li>
</ul>
</li>
</ul>
<hr>
<h4 id="特判-了解即可"><a href="#特判-了解即可" class="headerlink" title="特判(了解即可)"></a>特判(了解即可)</h4><ul>
<li>不咋用，因为我都有正则了还要什么自行车？</li>
<li><code>str.isalpha()</code><ul>
<li>是否全是英文字母</li>
</ul>
</li>
<li><code>str.isspace()</code><ul>
<li>是否全为空白符</li>
</ul>
</li>
<li><code>str.isupper()</code><ul>
<li>是否全为大写字母</li>
</ul>
</li>
<li><code>str.islower()</code><ul>
<li>是否全为小写字母</li>
</ul>
</li>
<li><code>str.istitle()</code><ul>
<li>是否是标题格式，单词第一个大写</li>
</ul>
</li>
<li><code>str.isdecimal()</code><ul>
<li>是否是十进制阿拉伯数字，不包含其他任何形式的数字</li>
</ul>
</li>
<li><code>str.isdigit()</code><ul>
<li>比上面更广，可以包含上标数字、罗马数字、全角数字</li>
</ul>
</li>
<li><code>str.isnumeric()</code><ul>
<li>比上面更广，甚至可以识别中文数字和分数数字</li>
</ul>
</li>
<li><code>str.isalnum()</code><ul>
<li>是否全为字母和数字</li>
<li>字母不限于英文字母，还有各国语言字母</li>
<li>数字不识别分数</li>
</ul>
</li>
<li><code>str.startswith()</code><ul>
<li>以什么指定字符串开头</li>
</ul>
</li>
<li><code>str.endswith()</code><ul>
<li>以什么指定字符串结尾</li>
</ul>
</li>
</ul>
<hr>
<h4 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h4><ul>
<li>如果你希望想C语言一样通过码点的位置定位一个字符的话，就继续看吧<ul>
<li>例如<code>A</code>字符在ascii表中对于着65，所以<code>A</code>也可以写为<code>&#39;\x65&#39;</code><div class="hide-block"><button type="button" class="hide-button" style="">查看示例
    </button><div class="hide-content"><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">chars = <span class="string">&#x27;\x65&#x27;</span></span><br><span class="line">byte_string = char.encode(<span class="string">&#x27;latin1&#x27;</span>) <span class="comment"># 将chars理解为Byte串</span></span><br><span class="line">char = byte_string.decode() <span class="comment"># 进行utf-8解码</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(chars)</span><br><span class="line"><span class="built_in">print</span>(byte_string)</span><br><span class="line"><span class="built_in">print</span>(char)</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">A</span><br><span class="line">b<span class="string">&#x27;A&#x27;</span></span><br><span class="line">A</span><br></pre></td></tr></table></figure>
</div></div></li>
</ul>
</li>
<li>同理，对于unicode字符集（涵盖ascii）中的字符也可以进行转义，不过不能直接使用类似于上面的格式<ul>
<li>例如<code>中</code>字符在<code>utf-8</code>编码方式中的三个字节标识是<code>&#39;\xe4\xb8\xad&#39;</code>，就不可以直接打印转义字符串，Python会理解为三个在ascii码表中的字符<div class="hide-block"><button type="button" class="hide-button" style="">查看示例
    </button><div class="hide-content"><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">chars = <span class="string">&#x27;\xe4\xb8\xad&#x27;</span></span><br><span class="line">byte_string = chars.encode(<span class="string">&#x27;latin1&#x27;</span>) <span class="comment"># 将chars编码理解为Byte串</span></span><br><span class="line">char = byte_string.decode() <span class="comment"># 默认以utf-8来解码</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(chars)</span><br><span class="line"><span class="built_in">print</span>(byte_string)</span><br><span class="line"><span class="built_in">print</span>(char)</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ä¸­-</span><br><span class="line">b<span class="string">&#x27;\xe4\xb8\xad&#x27;</span></span><br><span class="line">中</span><br></pre></td></tr></table></figure>
</div></div></li>
</ul>
</li>
<li>最后，Python内置了提供字符码点的函数（<strong>非ascii码字符的码点</strong>与<strong>utf-8编码的标识</strong>是两个概念）</li>
<li><code>ord()</code><ul>
<li>由字符得到码点</li>
</ul>
</li>
<li><code>chr()</code><ul>
<li>由码点生成字符</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell脚本(1)</title>
    <url>/2025/02/08/Shell/</url>
    <content><![CDATA[<h1 id="Shell-1"><a href="#Shell-1" class="headerlink" title="Shell(1)"></a>Shell(1)</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>Bash脚本中变量可以分为字符串、数字、数组等等，较为常用的还是字符串</p>
<p>命名规范</p>
<ul>
<li>只包含字母、数字和下划线： **变量名可以包含字母（大小写敏感）、数字和下划线 _**，不能包含其他特殊字符。</li>
<li>不能以数字开头： <strong>变量名不能以数字开头</strong>，但可以包含数字。</li>
<li>避免使用 Shell 关键字： 不要使用Shell的关键字（例如 if、then、else、fi、for、while 等）作为变量名，以免引起混淆。</li>
<li>使用大写字母表示常量： 习惯上，常量的变量名通常使用大写字母，例如 PI&#x3D;3.14。</li>
<li>避免使用特殊符号： 尽量避免在变量名中使用特殊符号，因为它们可能与 Shell 的语法产生冲突。</li>
<li>避免使用空格： 变量名中不应该包含空格，因为空格通常用于分隔命令和参数。</li>
</ul>
<p>定义</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注意不能有空格</span></span><br><span class="line"><span class="comment"># str = &quot;abc&quot;是错误的写法</span></span><br><span class="line">str=<span class="string">&quot;abc&quot;</span></span><br><span class="line">str=<span class="string">&#x27;abc&#x27;</span></span><br><span class="line"></span><br><span class="line">digit=12</span><br><span class="line"><span class="built_in">declare</span> -i digit=12</span><br><span class="line"></span><br><span class="line">array=(1 2 3 4 5)</span><br><span class="line"><span class="built_in">declare</span> -A associate_array=([<span class="string">&quot;A&quot;</span>]=<span class="string">&quot;1&quot;</span> [<span class="string">&quot;B&quot;</span>]=<span class="string">&quot;2&quot;</span> [<span class="string">&quot;C&quot;</span>]=<span class="string">&quot;3&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>引用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">str=<span class="string">&quot;abc&quot;</span></span><br><span class="line">digit=12</span><br><span class="line">array=(1 2 3 4 5)</span><br><span class="line"><span class="comment"># 获得变量的值/引用变量需要使用$</span></span><br><span class="line"><span class="comment"># 字符串变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$str</span></span><br><span class="line"><span class="comment"># &gt;&gt;&gt; abc</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$digit</span></span><br><span class="line"><span class="comment"># &gt;&gt;&gt; 12</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[@]&#125;</span></span><br><span class="line"><span class="comment"># &gt;&gt;&gt; 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于可能有歧义的变量名字需要使用&#123;&#125;括起来</span></span><br><span class="line">str=<span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="comment"># 如果不使用&#123;&#125;将会把strabc识别为一个变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;str&#125;</span>abc&quot;</span></span><br><span class="line"><span class="comment"># &gt;&gt;&gt; abcabc</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$str</span></span><br><span class="line"><span class="comment"># &gt;&gt;&gt; abc</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>在Bash脚本中经常使用的一种变量，具有最主要的特征</p>
<p>单引号与双引号的区别</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.单引号中无法识别变量名</span></span><br><span class="line">name=<span class="string">&quot;yangman&quot;</span></span><br><span class="line">str1=<span class="string">&quot;I love <span class="variable">$&#123;name&#125;</span>&quot;</span></span><br><span class="line">str2=<span class="string">&#x27;I love $&#123;name&#125;&#x27;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$str1</span></span><br><span class="line"><span class="comment"># &gt;&gt;&gt; I love yangman</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$str2</span></span><br><span class="line"><span class="comment"># &gt;&gt;&gt; I love $&#123;name&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.单引号无法使用单引号（即使转义）</span></span><br><span class="line">str1=<span class="string">&quot;myname \&quot;\&#x27;&quot;</span></span><br><span class="line">str2=<span class="string">&#x27;myname \&quot;\&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">echo $str1 \&#x27;</span></span><br><span class="line"><span class="comment"># 显而易见，即使转义了单引号也会引起后续问题，必须只能成对出现</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.二者都可以使用拼接操作</span></span><br><span class="line">your_name=<span class="string">&quot;runoob&quot;</span></span><br><span class="line"><span class="comment"># 使用双引号拼接</span></span><br><span class="line">greeting=<span class="string">&quot;hello, &quot;</span><span class="variable">$your_name</span><span class="string">&quot; !&quot;</span></span><br><span class="line">greeting_1=<span class="string">&quot;hello, <span class="variable">$&#123;your_name&#125;</span> !&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$greeting</span>  <span class="variable">$greeting_1</span></span><br><span class="line"><span class="comment"># &gt;&gt;&gt; hello, runoob ! hello, runoob !</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用单引号拼接</span></span><br><span class="line">greeting_2=<span class="string">&#x27;hello, &#x27;</span><span class="variable">$your_name</span><span class="string">&#x27; !&#x27;</span></span><br><span class="line">greeting_3=<span class="string">&#x27;hello, $&#123;your_name&#125; !&#x27;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$greeting_2</span>  <span class="variable">$greeting_3</span></span><br><span class="line"><span class="comment"># &gt;&gt;&gt; hello, runoob ! hello, $&#123;your_name&#125; ! </span></span><br></pre></td></tr></table></figure>

<p>计算字符串长度</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">str=<span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#str&#125;</span></span><br><span class="line"><span class="comment"># &gt;&gt;&gt; 3</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#str[0]&#125;</span></span><br><span class="line"><span class="comment"># &gt;&gt;&gt; 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意这里虽然使用了索引</span></span><br><span class="line"><span class="comment"># 但是字符串实则为不可迭代/不可索引的对象！！！</span></span><br></pre></td></tr></table></figure>
<p>字符串切片操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">str=<span class="string">&quot;1234567&quot;</span></span><br><span class="line"><span class="comment"># string:index[:length]</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str:1&#125;</span></span><br><span class="line"><span class="comment"># &gt;&gt;&gt; 234567</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str:1:3&#125;</span></span><br><span class="line"><span class="comment"># &gt;&gt;&gt; 234</span></span><br></pre></td></tr></table></figure>
<p>查找子串</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> $(<span class="built_in">expr</span> index <span class="string">&quot;string&quot;</span> io)</span><br><span class="line"><span class="comment"># 找到string串中第一次出现i或者o的位置</span></span><br></pre></td></tr></table></figure>

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组由索引的类型分为两大类</p>
<ul>
<li>整数索引数组，顾名思义，索引都是整数的数组</li>
<li>关联数组，索引可以是字符串也可是整数</li>
</ul>
<p>数组定义</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 除了和一般变量定义外</span></span><br><span class="line"><span class="comment"># 数组支持直接通过下标赋值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 索引数组索引不要求连续</span></span><br><span class="line">new_array[0]=<span class="string">&quot;1&quot;</span></span><br><span class="line">new_array[1]=<span class="string">&quot;2&quot;</span></span><br><span class="line">new_array[6]=<span class="string">&quot;3&quot;</span></span><br><span class="line">new_array[10]=<span class="string">&quot;6&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关联数组需要声明</span></span><br><span class="line"><span class="built_in">declare</span> -A associ_array</span><br><span class="line">associ_array[<span class="string">&quot;A&quot;</span>]=<span class="string">&quot;1&quot;</span></span><br><span class="line">associ_array[<span class="string">&quot;B&quot;</span>]=<span class="string">&quot;1&quot;</span></span><br><span class="line">associ_array[<span class="string">&quot;D&quot;</span>]=<span class="string">&quot;1&quot;</span></span><br><span class="line">associ_array[<span class="string">&quot;SD&quot;</span>]=<span class="string">&quot;1&quot;</span></span><br></pre></td></tr></table></figure>

<p>数组索引</p>
<ul>
<li>正常语言的索引，通过下标取值  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[index]&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>计算数组长度</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 取得数组元素的个数</span></span><br><span class="line">length=<span class="variable">$&#123;#array_name[@]&#125;</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">length=<span class="variable">$&#123;#array_name[*]&#125;</span></span><br><span class="line"><span class="comment"># 取得数组单个元素的长度</span></span><br><span class="line">length=<span class="variable">$&#123;#array_name[n]&#125;</span></span><br></pre></td></tr></table></figure>

<p>列出所有元素</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">array=(1 2 3 4 5)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.列出所有的value</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[@]&#125;</span></span><br><span class="line"><span class="comment"># &gt;&gt;&gt; 1 2 3 4 5</span></span><br><span class="line"><span class="comment"># 实际表现为 &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[*]&#125;</span></span><br><span class="line"><span class="comment"># &gt;&gt;&gt; 1 2 3 4 5</span></span><br><span class="line"><span class="comment"># 实际表现为 &quot;1 2 3 4 5&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 意味着一个是可迭代的，一个不是可迭代的</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$&#123;array[@]&#125;</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment"># &gt;&gt;&gt; 1</span></span><br><span class="line"><span class="comment"># &gt;&gt;&gt; 2</span></span><br><span class="line"><span class="comment"># &gt;&gt;&gt; 3</span></span><br><span class="line"><span class="comment"># &gt;&gt;&gt; 4</span></span><br><span class="line"><span class="comment"># &gt;&gt;&gt; 5</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$&#123;array[*]&#125;</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment"># &gt;&gt;&gt; 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有的key</span></span><br><span class="line"><span class="comment"># 都是可迭代的</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;!array[@]&#125;</span></span><br><span class="line"><span class="comment"># &gt;&gt;&gt; 0 1 2 3 4 </span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;!array[*]&#125;</span></span><br><span class="line"><span class="comment"># &gt;&gt;&gt; 0 1 2 3 4 </span></span><br></pre></td></tr></table></figure>
<h2 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h2><h3 id="Shell类"><a href="#Shell类" class="headerlink" title="Shell类"></a>Shell类</h3><p><code>$()</code></p>
<ul>
<li>将其中的字符识别为shell命令，并将结果作为返回值<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> $(<span class="built_in">ls</span>)</span><br><span class="line">var=$(<span class="built_in">ls</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$var</span>;<span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<code>反引号</code></li>
<li>同上，转义为命令并返回结果<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> `<span class="built_in">ls</span>`</span><br><span class="line">var=`<span class="built_in">ls</span>`</span><br></pre></td></tr></table></figure>
<code>()</code></li>
<li>开启一个shell子进程，其内部变量不影响当前进程<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 子 Shell</span></span><br><span class="line">(a=10; <span class="built_in">echo</span> <span class="variable">$a</span>)  <span class="comment"># 输出 10</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span>          <span class="comment"># 输出空，因为子 Shell 中的变量不影响父 Shell</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数组</span></span><br><span class="line">arr=(1 2 3)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;arr[1]&#125;</span>   <span class="comment"># 输出 2</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="算术类"><a href="#算术类" class="headerlink" title="算术类"></a>算术类</h3><ul>
<li>对于整数类型或者<strong>纯数字的字符串</strong></li>
</ul>
<p><code>(())</code></p>
<ul>
<li>支持所有c语言支持的运算符</li>
<li>算术拓展，在其中可以直接使用各种运算符并且不需要引用变量<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a=5</span><br><span class="line">b=10</span><br><span class="line">((a++))          </span><br><span class="line">((c = a + b))   </span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$c</span>         </span><br><span class="line"><span class="comment"># &gt;&gt;&gt; 16</span></span><br></pre></td></tr></table></figure></li>
<li>支持运算符<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>+</code></td>
<td>加法</td>
<td><code>(( a = 5 + 3 ))</code></td>
</tr>
<tr>
<td><code>-</code></td>
<td>减法</td>
<td><code>(( a = 5 - 3 ))</code></td>
</tr>
<tr>
<td><code>*</code></td>
<td>乘法</td>
<td><code>(( a = 5 * 3 ))</code></td>
</tr>
<tr>
<td><code>/</code></td>
<td>整数除法（只返回整数部分）</td>
<td><code>(( a = 5 / 2 ))</code> （结果 <code>2</code>）</td>
</tr>
<tr>
<td><code>%</code></td>
<td>取模</td>
<td><code>(( a = 5 % 2 ))</code> （结果 <code>1</code>）</td>
</tr>
<tr>
<td><code>**</code></td>
<td>幂运算</td>
<td><code>(( a = 2 ** 3 ))</code> （结果 <code>8</code>）</td>
</tr>
<tr>
<td><code>++</code></td>
<td>自增</td>
<td><code>(( a++ ))</code> 或 <code>(( ++a ))</code></td>
</tr>
<tr>
<td><code>--</code></td>
<td>自减</td>
<td><code>(( a-- ))</code> 或 <code>(( --a ))</code></td>
</tr>
<tr>
<td><code>=</code></td>
<td>赋值</td>
<td><code>(( a = 10 ))</code></td>
</tr>
<tr>
<td><code>+=</code></td>
<td>加法赋值</td>
<td><code>(( a += 2 ))</code></td>
</tr>
<tr>
<td><code>-=</code></td>
<td>减法赋值</td>
<td><code>(( a -= 2 ))</code></td>
</tr>
<tr>
<td><code>*=</code></td>
<td>乘法赋值</td>
<td><code>(( a *= 2 ))</code></td>
</tr>
<tr>
<td><code>/=</code></td>
<td>除法赋值</td>
<td><code>(( a /= 2 ))</code></td>
</tr>
<tr>
<td><code>%=</code></td>
<td>取模赋值</td>
<td><code>(( a %= 2 ))</code></td>
</tr>
<tr>
<td><code>==</code></td>
<td>等于</td>
<td><code>(( a == b ))</code></td>
</tr>
<tr>
<td><code>!=</code></td>
<td>不等于</td>
<td><code>(( a != b ))</code></td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>大于</td>
<td><code>(( a &gt; b ))</code></td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>小于</td>
<td><code>(( a &lt; b ))</code></td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>大于等于</td>
<td><code>(( a &gt;= b ))</code></td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>小于等于</td>
<td><code>(( a &lt;= b ))</code></td>
</tr>
<tr>
<td><code>&amp;&amp;</code></td>
<td>逻辑与</td>
<td><code>(( a &gt; 3 &amp;&amp; b &lt; 5 ))</code></td>
</tr>
<tr>
<td><code>||</code></td>
<td>逻辑或</td>
<td><code>(( a &gt; 3 || b &lt; 5 ))</code></td>
</tr>
<tr>
<td><code>!</code></td>
<td>逻辑非</td>
<td><code>(( !a ))</code></td>
</tr>
<tr>
<td><code>&amp;</code></td>
<td>按位与</td>
<td><code>(( a &amp; b ))</code></td>
</tr>
<tr>
<td><code>|</code></td>
<td>按位或</td>
<td><code>(( a | b ))</code></td>
</tr>
<tr>
<td><code>^</code></td>
<td>按位异或</td>
<td><code>(( a ^ b ))</code></td>
</tr>
<tr>
<td><code>&lt;&lt;</code></td>
<td>左移</td>
<td><code>(( a &lt;&lt; 1 ))</code></td>
</tr>
<tr>
<td><code>&gt;&gt;</code></td>
<td>右移</td>
<td><code>(( a &gt;&gt; 1 ))</code></td>
</tr>
</tbody></table>
</li>
</ul>
<p><code>$(())</code></p>
<ul>
<li>也是算术拓展，但是这里是返回了值，不能像上面一样内部赋值<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a=5</span><br><span class="line">b=10</span><br><span class="line">a=$((a + <span class="number">1</span>))</span><br><span class="line">c=$((a + b))</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$c</span></span><br><span class="line"><span class="comment"># &gt;&gt;&gt; 16</span></span><br></pre></td></tr></table></figure>
<code>$[]</code></li>
<li>同上，但是已经过时，尽量补药使用</li>
</ul>
<h3 id="比较类"><a href="#比较类" class="headerlink" title="比较类"></a>比较类</h3><p><code>[]</code></p>
<ul>
<li>test比较方法的简写</li>
<li>对于数字比较（纯数字的字符串）<ul>
<li>支持<code>==</code>、<code>!=</code></li>
<li>支持<code>-gt</code>、<code>-lt</code>、<code>-eq</code>、<code>-ne</code>、<code>-ge</code>、<code>le</code></li>
<li>支持<code>!</code>、<code>-o</code>、<code>-a</code>，不能直接支持<code>&amp;&amp;</code>、<code>||</code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> != <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$a</span> != <span class="variable">$b</span> : a 不等于 b&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$a</span> == <span class="variable">$b</span>: a 等于 b&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># if [ $a -lt 100 ] &amp;&amp; [ $b -gt 15 ]</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> -lt 100 -a <span class="variable">$b</span> -gt 15 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$a</span> 小于 100 且 <span class="variable">$b</span> 大于 15 : 返回 true&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$a</span> 小于 100 且 <span class="variable">$b</span> 大于 15 : 返回 false&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> -lt 100 -o <span class="variable">$b</span> -gt 100 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$a</span> 小于 100 或 <span class="variable">$b</span> 大于 100 : 返回 true&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$a</span> 小于 100 或 <span class="variable">$b</span> 大于 100 : 返回 false&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> -lt 5 -o <span class="variable">$b</span> -gt 100 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$a</span> 小于 5 或 <span class="variable">$b</span> 大于 100 : 返回 true&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$a</span> 小于 5 或 <span class="variable">$b</span> 大于 100 : 返回 false&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>对于字符串比较<ul>
<li>支持<code>=</code>、<code>!=</code> <strong>!!!!!!!此处只有一个&#x3D;</strong></li>
<li>支持<code>-z</code>、<code>-n</code>、<code>$</code></li>
<li>支持<code>\&gt;</code>、<code>\&lt;</code>字符串排序</li>
<li>需要注意<strong>比较时字符串会默认去除引号，所以保险起见需要加上引号</strong><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a=<span class="string">&quot;abc&quot;</span></span><br><span class="line">b=<span class="string">&quot;efg&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$a</span>&quot;</span> = <span class="string">&quot;<span class="variable">$b</span>&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$a</span> = <span class="variable">$b</span> : a 等于 b&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$a</span> = <span class="variable">$b</span>: a 不等于 b&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$a</span>&quot;</span> != <span class="string">&quot;<span class="variable">$b</span>&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$a</span> != <span class="variable">$b</span> : a 不等于 b&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$a</span> != <span class="variable">$b</span>: a 等于 b&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$a</span>&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;-z <span class="variable">$a</span> : 字符串长度为 0&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;-z <span class="variable">$a</span> : 字符串长度不为 0&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$a</span>&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;-n <span class="variable">$a</span> : 字符串长度不为 0&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;-n <span class="variable">$a</span> : 字符串长度为 0&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$a</span>&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$a</span> : 字符串存在且不为空&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$a</span> : 字符串为空/不存在&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>文件测试<ul>
<li><code>-e</code> <code>-r</code> <code>-x</code> <code>-w</code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">file=<span class="string">&quot;/var/www/runoob/test.sh&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -r <span class="variable">$file</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;文件可读&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;文件不可读&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -w <span class="variable">$file</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;文件可写&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;文件不可写&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -x <span class="variable">$file</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;文件可执行&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;文件不可执行&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -f <span class="variable">$file</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;文件为普通文件&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;文件为特殊文件&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="variable">$file</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;文件是个目录&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;文件不是个目录&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -s <span class="variable">$file</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;文件不为空&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;文件为空&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -e <span class="variable">$file</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;文件存在&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;文件不存在&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><code>[[]]</code> </p>
<ul>
<li><strong>替代<code>[]</code>，在字符串、文件、正则方面</strong></li>
<li>扩展条件测试是 <strong>Bash 的扩展测试命令</strong>，用于 <strong>字符串比较</strong>、<strong>文件测试</strong> 和 <strong>逻辑运算</strong>，比 <code>[]</code> 更强大。</li>
<li>支持运算符(包含<code>[]</code>)<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>==</code></td>
<td>字符串相等</td>
<td><code>[[ $str == &quot;hello&quot; ]]</code></td>
</tr>
<tr>
<td><code>&amp;&amp;</code></td>
<td>逻辑与</td>
<td><code>[[ $a -gt 3 &amp;&amp; $b -lt 5 ]]</code></td>
</tr>
<tr>
<td><code>||</code></td>
<td>逻辑或</td>
<td><code>[[ $a -gt 3 || $b -lt 5 ]]</code></td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>字典序</td>
<td><code>[[ &quot;b&quot; &gt; &quot;a&quot; ]]</code></td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>字典序</td>
<td><code>[[ &quot;a&quot; &lt; &quot;b&quot; ]]</code></td>
</tr>
</tbody></table>
</li>
</ul>
<p><code>(())</code></p>
<ul>
<li><strong>替代<code>[]</code>，在数值比较方面</strong></li>
<li>用于数值比较</li>
</ul>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell脚本(2)</title>
    <url>/2025/02/09/Shell_2/</url>
    <content><![CDATA[<h1 id="Shell-2"><a href="#Shell-2" class="headerlink" title="Shell(2)"></a>Shell(2)</h1><h2 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h2><p>运行脚本时后续可以用空格传递若干参数</p>
<table>
<thead>
<tr>
<th align="center">变量</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>$0</code></td>
<td align="center">当前文件名</td>
</tr>
<tr>
<td align="center"><code>$1~$n</code></td>
<td align="center">第1~n个参数</td>
</tr>
<tr>
<td align="center"><code>$#</code></td>
<td align="center">参数数量</td>
</tr>
<tr>
<td align="center"><code>$*</code></td>
<td align="center">所有参数，不可迭代</td>
</tr>
<tr>
<td align="center"><code>$@</code></td>
<td align="center">所有参数，可迭代</td>
</tr>
</tbody></table>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p><code>for</code></p>
<ul>
<li>对于可迭代对象使用<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> iterable; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> item1 item2 item3 itemN; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>while</code></p>
<ul>
<li>满足循环条件时执行语句<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> condition; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">int=1</span><br><span class="line"><span class="keyword">while</span> ((int &lt;= <span class="number">5</span>)); <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$int</span></span><br><span class="line">  ((int++))</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>until</code></p>
<ul>
<li>不满足条件时执行语句<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int=1</span><br><span class="line"><span class="keyword">until</span> [ ! <span class="variable">$a</span> -lt 10 ]; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line">  a=`<span class="built_in">expr</span> <span class="variable">$a</span> + 1`</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>if-else</code></p>
<ul>
<li>分支控制语句<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">command</span></span><br><span class="line"><span class="keyword">elif</span> condition; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">command</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">command</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>case</code></p>
<ul>
<li>分支控制语句</li>
<li>需要使用<code>case esac包裹</code></li>
<li><code>;;</code>代表break操作</li>
<li><code>condition)</code>代表分支，可以同时有多个使用<code>|</code>隔开例如，<code>1|2|3)</code>，<code>*</code>代表剩余的结果<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="variable">$var</span> <span class="keyword">in</span></span><br><span class="line">  1) <span class="built_in">echo</span> $((var-<span class="number">1</span>))</span><br><span class="line">  ;;</span><br><span class="line">  2) <span class="built_in">echo</span> $((var-<span class="number">2</span>))</span><br><span class="line">  ;;</span><br><span class="line">  3) <span class="built_in">echo</span> $((var-<span class="number">3</span>))</span><br><span class="line">  ;;</span><br><span class="line">  *) <span class="built_in">echo</span> $((var))</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>break &amp; continue</code></p>
<ul>
<li>同C语言，在跳出循环时使用</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul>
<li>函数定义时可以省略<code>function</code></li>
<li>函数如果需要返回值必须是<code>0~255</code>，否则返回函数体内最后一句指令的结果  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[ <span class="keyword">function</span> ] funname [()]</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    action;</span><br><span class="line"></span><br><span class="line">    [<span class="built_in">return</span> int;]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在函数外使用<code>$?</code>来获得函数返回值</li>
<li>如果给函数传递参数，在函数内的操作同<a href="#%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0">传递参数</a>，尤其注意<code>$&#123;10&#125;</code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">funWithParam</span></span>()&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;第一个参数为 <span class="variable">$1</span> !&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;第二个参数为 <span class="variable">$2</span> !&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;第十个参数为 <span class="variable">$10</span> !&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;第十个参数为 <span class="variable">$&#123;10&#125;</span> !&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;第十一个参数为 <span class="variable">$&#123;11&#125;</span> !&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;参数总数有 <span class="variable">$#</span> 个!&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;作为一个字符串输出所有参数 $* !&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funWithParam 1 2 3 4 5 6 7 8 9 34 73</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>重定向命令  </p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">command &gt; file</td>
<td align="center">将命令的输出重定向到file中(覆盖)</td>
</tr>
<tr>
<td align="center">command &lt; file</td>
<td align="center">将命令的输入重定向到file中</td>
</tr>
<tr>
<td align="center">command &gt;&gt; file</td>
<td align="center">将命令的输出重定向到file中(追加)</td>
</tr>
<tr>
<td align="center">n&gt;file</td>
<td align="center">将文件描述符n的文件重定向到file中(覆盖)</td>
</tr>
<tr>
<td align="center">n&gt;&gt;file</td>
<td align="center">将文件描述符n的文件重定向到file中(追加)</td>
</tr>
<tr>
<td align="center">n&gt;&amp;m</td>
<td align="center">将输出文件n与m合并</td>
</tr>
<tr>
<td align="center">n&lt;&amp;m</td>
<td align="center">将输入文件n与m合并</td>
</tr>
</tbody></table>
<p>文件描述符</p>
<table>
<thead>
<tr>
<th align="center">文件描述符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">stdin</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">stdout</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">stderr</td>
</tr>
</tbody></table>
<p>常用操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hello.txt:</span></span><br><span class="line"><span class="comment"># test</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span> &gt; hello.txt</span><br><span class="line"><span class="comment"># hello.txt:</span></span><br><span class="line"><span class="comment"># hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># hello.txt:</span></span><br><span class="line"><span class="comment"># test</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span> &gt;&gt; hello.txt</span><br><span class="line"><span class="comment"># hello.txt:</span></span><br><span class="line"><span class="comment"># test</span></span><br><span class="line"><span class="comment"># hello</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span> &gt; hello.txt</span><br><span class="line"><span class="comment"># 等同于 echo &quot;hello&quot; 1&gt;hello.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果希望传递stderr到hello.txt中</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span> 2&gt;hello.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果希望同时传递stdout与stderr</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span> &gt; hello.txt 2&gt;&amp;1</span><br><span class="line"><span class="comment"># echo &quot;hello&quot; &gt;&gt; hello.txt 2&gt;&amp;1</span></span><br></pre></td></tr></table></figure>
<p>屏蔽</p>
<ul>
<li><code>/dev/null</code>是一个特殊文件，写入的内容会被丢弃，读出的内容为空</li>
<li>可以重定向到此文件来屏蔽输出<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">command</span> &gt; /dev/null</span><br><span class="line"><span class="comment"># 屏蔽stdout</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">command</span> 2&gt;/dev/null</span><br><span class="line"><span class="comment"># 屏蔽stderr</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">command</span> &gt; /dev/null 2&gt;&amp;1</span><br><span class="line"><span class="comment"># 屏蔽stdout和stderr</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2024/09/10/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>the information is here</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GA</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, gender, age</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.gender = gender</span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;name:<span class="subst">&#123;name&#125;</span>,gender:<span class="subst">&#123;gender&#125;</span>,age:<span class="subst">&#123;age&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> deap <span class="keyword">import</span> base,tools,algorithms,creator</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># import random</span></span><br><span class="line"></span><br><span class="line">IND_NUM = <span class="number">30</span> <span class="comment"># 30位编码，[-5,5]，精度是8位</span></span><br><span class="line">POP_NUM = <span class="number">100</span> <span class="comment"># 种群总个体数量</span></span><br><span class="line">OFS_MAX = <span class="number">50</span> <span class="comment"># 后代最大值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decode</span>(<span class="params">individual</span>):</span><br><span class="line">    num = <span class="built_in">int</span>(<span class="string">&#x27;&#x27;</span>.join([<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> individual]),<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> (-<span class="number">5</span> + (<span class="number">10</span> * num)/(<span class="number">2</span>**<span class="number">30</span> - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">eval</span>(<span class="params">individual</span>):</span><br><span class="line">    x = decode(individual)</span><br><span class="line">    <span class="keyword">return</span> ((np.square(x) + x) * np.cos(<span class="number">2</span> * x) + np.square(x) + x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">creator.create(<span class="string">&quot;FitnessMin&quot;</span>,base.Fitness,weights=(-<span class="number">1.0</span>,))</span><br><span class="line">creator.create(<span class="string">&quot;Individual&quot;</span>,<span class="built_in">list</span>,fitness = creator.FitnessMin)</span><br><span class="line"></span><br><span class="line">toolbox = base.Toolbox()</span><br><span class="line">toolbox.register(<span class="string">&quot;attribute&quot;</span>,np.random.randint,<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">toolbox.register(<span class="string">&quot;individual&quot;</span>, tools.initRepeat, creator.Individual, toolbox.attribute, n=IND_NUM)</span><br><span class="line">toolbox.register(<span class="string">&quot;population&quot;</span>, tools.initRepeat, <span class="built_in">list</span>, toolbox.individual)</span><br><span class="line">pop = toolbox.population(n=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">toolbox.register(<span class="string">&quot;evaluate&quot;</span>, <span class="built_in">eval</span>)</span><br><span class="line">toolbox.register(<span class="string">&quot;select&quot;</span>, tools.selTournament, <span class="number">3</span>)</span><br><span class="line">toolbox.register(<span class="string">&quot;mate&quot;</span>, tools.cxUniform, indpb=<span class="number">0.5</span>)</span><br><span class="line">toolbox.register(<span class="string">&quot;mutate&quot;</span>, tools.mutFlipBit, indpb=<span class="number">0.5</span>)</span><br><span class="line"><span class="comment"># tools.mutFlipBit()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stats = tools.Statistics(key=<span class="keyword">lambda</span> x: x.fitness.values)</span><br><span class="line">stats.register(<span class="string">&quot;avg&quot;</span>, np.mean)</span><br><span class="line">stats.register(<span class="string">&quot;std&quot;</span>, np.std)</span><br><span class="line">stats.register(<span class="string">&quot;min&quot;</span>, np.<span class="built_in">min</span>)</span><br><span class="line">stats.register(<span class="string">&quot;max&quot;</span>, np.<span class="built_in">max</span>)</span><br><span class="line"></span><br><span class="line">resultPop, logbook = algorithms.eaSimple(pop, toolbox, cxpb=<span class="number">0.5</span>, mutpb=<span class="number">0.2</span>, ngen=POP_NUM, stats=stats, verbose=<span class="literal">False</span>)</span><br><span class="line">logbook.header = <span class="string">&#x27;gen&#x27;</span>,<span class="string">&#x27;nevals&#x27;</span>,<span class="string">&#x27;avg&#x27;</span>,<span class="string">&#x27;std&#x27;</span>,<span class="string">&#x27;min&#x27;</span>,<span class="string">&#x27;max&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(logbook)    </span><br></pre></td></tr></table></figure>

<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  pie
    title Key elements in Product X
    &quot;Calcium&quot; : 42.96
    &quot;Potassium&quot; : 50.05
    &quot;Magnesium&quot; : 10.01
    &quot;Iron&quot; :  5
  </pre></div>


<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><ul>
<li>我有一个好点子<div class="tabs" id="test4-"><ul class="nav-tabs no-default"><button type="button" class="tab " data-href="test4--1">第一个Tab</button><button type="button" class="tab " data-href="test4--2"><i class="fab fa-apple-pay" style="text-align: center;"></i></button><button type="button" class="tab " data-href="test4--3"><i class="fas fa-bomb"></i>炸弹</button></ul><div class="tab-contents"><div class="tab-item-content" id="test4--1"><p><strong>tab名字为第一个Tab</strong></p></div><div class="tab-item-content" id="test4--2"><p><strong>只有图标 没有Tab名字</strong></p></div><div class="tab-item-content" id="test4--3"><p><strong>名字+icon</strong></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></li>
</ul>
<p>作者: Jerry<br>連結: <a href="https://butterfly.js.org/posts/4aa8abbe/">https://butterfly.js.org/posts/4aa8abbe/</a><br>來源: Butterfly<br>著作權歸作者所有。商業轉載請聯繫作者獲得授權，非商業轉載請註明出處。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<div class="flink"><div class="flink-name">友情链接</div><div class="flink-desc">那些人，那些事</div> <div class="flink-list">
          <div class="flink-list-item">
            <a href="https://jerryc.me/" title="JerryC" target="_blank">
              <div class="flink-item-icon">
                <img class="no-lightbox" src="https://jerryc.me/img/avatar.png" onerror='this.onerror=null;this.src="/img/friend_404.gif"' alt="JerryC" />
              </div>
              <div class="flink-item-name">JerryC</div> 
              <div class="flink-item-desc" title="今日事,今日毕">今日事,今日毕</div>
            </a>
          </div>
          <div class="flink-list-item">
            <a href="https://hexo.io/zh-tw/" title="Hexo" target="_blank">
              <div class="flink-item-icon">
                <img class="no-lightbox" src="https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg" onerror='this.onerror=null;this.src="/img/friend_404.gif"' alt="Hexo" />
              </div>
              <div class="flink-item-name">Hexo</div> 
              <div class="flink-item-desc" title="快速、简单且强大的网志框架">快速、简单且强大的网志框架</div>
            </a>
          </div></div><div class="flink-name">网站</div><div class="flink-desc">值得推荐的网站</div> <div class="flink-list">
          <div class="flink-list-item">
            <a href="https://www.youtube.com/" title="Youtube" target="_blank">
              <div class="flink-item-icon">
                <img class="no-lightbox" src="https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png" onerror='this.onerror=null;this.src="/img/friend_404.gif"' alt="Youtube" />
              </div>
              <div class="flink-item-name">Youtube</div> 
              <div class="flink-item-desc" title="视频网站">视频网站</div>
            </a>
          </div>
          <div class="flink-list-item">
            <a href="https://www.weibo.com/" title="Weibo" target="_blank">
              <div class="flink-item-icon">
                <img class="no-lightbox" src="https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png" onerror='this.onerror=null;this.src="/img/friend_404.gif"' alt="Weibo" />
              </div>
              <div class="flink-item-name">Weibo</div> 
              <div class="flink-item-desc" title="中国最大社交分享平台">中国最大社交分享平台</div>
            </a>
          </div>
          <div class="flink-list-item">
            <a href="https://twitter.com/" title="Twitter" target="_blank">
              <div class="flink-item-icon">
                <img class="no-lightbox" src="https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png" onerror='this.onerror=null;this.src="/img/friend_404.gif"' alt="Twitter" />
              </div>
              <div class="flink-item-name">Twitter</div> 
              <div class="flink-item-desc" title="社交分享平台">社交分享平台</div>
            </a>
          </div></div></div>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
