<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>面向对象u2-pre | Trash Bin for Chi</title><meta name="author" content="Chi,23371265@buaa.edu.cn"><meta name="copyright" content="Chi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="OO_u2 pre现在刚好在U1与U2衔接的空档期，笔者正好写完了作业没事干，所以决定看看U2的内容。说实话虽然老早就知道多线程、多进程这样概念，平常写代码需要多线程最多就是直接使用进程池（GPT把关版），这样深入地学习多线程还是第一次。 学习资料  B老师 C老师 D老师 王老师 java多线程  1.多线程是什么在古早时代，面对多个需要执行的程序&#x2F;作业，计算机无法做到同时运行他们。于">
<meta property="og:type" content="article">
<meta property="og:title" content="面向对象u2-pre">
<meta property="og:url" content="https://kie-chi.github.io/2025/03/20/OO_u2_pre/index.html">
<meta property="og:site_name" content="Trash Bin for Chi">
<meta property="og:description" content="OO_u2 pre现在刚好在U1与U2衔接的空档期，笔者正好写完了作业没事干，所以决定看看U2的内容。说实话虽然老早就知道多线程、多进程这样概念，平常写代码需要多线程最多就是直接使用进程池（GPT把关版），这样深入地学习多线程还是第一次。 学习资料  B老师 C老师 D老师 王老师 java多线程  1.多线程是什么在古早时代，面对多个需要执行的程序&#x2F;作业，计算机无法做到同时运行他们。于">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/oo_2.png">
<meta property="article:published_time" content="2025-03-20T14:00:00.000Z">
<meta property="article:modified_time" content="2025-03-20T14:36:08.528Z">
<meta property="article:author" content="Chi">
<meta property="article:tag" content="OO">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/oo_2.png"><link rel="shortcut icon" href="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/wifi_fav.ico"><link rel="canonical" href="https://kie-chi.github.io/2025/03/20/OO_u2_pre/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"LAX3O9LZW6","apiKey":"bf885597c6928e6be2e67de57f38f2bd","indexName":"my-hexo-blog","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: {"limitDay":730,"position":"top","messagePrev":"我已经","messageNext":"天没有更新这篇文章了,如果您觉得过时了可以看看主页哦~"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Chi","link":"链接: ","source":"来源: Trash Bin for Chi","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面向对象u2-pre',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-03-20 22:36:08'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 7 || hour >= 19
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (true) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/author.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fa-fw fas fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/oo_2.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Trash Bin for Chi"><img class="site-icon" src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/author.png"/><span class="site-name">Trash Bin for Chi</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fa-fw fas fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">面向对象u2-pre</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-20T14:00:00.000Z" title="发表于 2025-03-20 22:00:00">2025-03-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-20T14:36:08.528Z" title="更新于 2025-03-20 22:36:08">2025-03-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/OO/">OO</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="面向对象u2-pre"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="OO-u2-pre"><a href="#OO-u2-pre" class="headerlink" title="OO_u2 pre"></a>OO_u2 pre</h1><p>现在刚好在U1与U2衔接的空档期，笔者正好写完了作业没事干，所以决定看看U2的内容。说实话虽然老早就知道多线程、多进程这样概念，平常写代码需要多线程最多就是直接使用进程池（<del>GPT把关版</del>），这样深入地学习多线程还是第一次。</p>
<p>学习资料</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1yW4y1Y7Ms?spm_id_from=333.788.videopod.episodes&vd_source=485d89eda9f819b62d977d00a503da9d&p=135">B老师</a></li>
<li><a target="_blank" rel="noopener" href="https://chatgpt.com/">C老师</a></li>
<li><a target="_blank" rel="noopener" href="https://deepseek.com/">D老师</a></li>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1YE411D7nH?spm_id_from=333.788.videopod.episodes&vd_source=485d89eda9f819b62d977d00a503da9d&p=26">王老师</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44715943/article/details/116714584">java多线程</a></li>
</ul>
<h2 id="1-多线程是什么"><a href="#1-多线程是什么" class="headerlink" title="1.多线程是什么"></a>1.多线程是什么</h2><p>在古早时代，面对多个需要执行的程序&#x2F;作业，计算机无法做到同时运行他们。于是程序只能一个一个地运行，像一个糖葫芦串一样一个接一个（<del>好饿</del>），这是程序的<strong>串行</strong>。<br>后来科学家们发现某些程序在运行时总是频繁地等待交互响应（一会需要打印机啊、一会需要输入机啊…），占用CPU资源。俗话说占着**不拉*，聪明的科学家想出了一个好办法，趁程序拉*（交互）的时候，剥夺其对CPU的使用权，交由其他程序使用，等到它拉完了又可以继续使用CPU了。由于它们交换CPU使用权又快又频繁，看起来<strong>像多个程序在同时运行</strong>。这是程序的<strong>并发</strong>。<br>后来随着资源越来越丰富，科学家想到给一个电脑多装几个CPU，这样程序不就能真正地一起运行了吗。所以发展出了<strong>多核CPU</strong>，两个&#x2F;多个程序可以同时占用CPU资源，有<strong>不同的核(CPU)<strong>为它们提供服务。这是程序的</strong>并行</strong></p>
<p>所以科学家把这一个个<strong>并发&#x2F;并行</strong>的程序称为<strong>进程</strong>。在早期，进程既是系统分配资源的基本单位，也是执行的基本单元。后来，科学家们为了加大系统的并发度，又引入了<strong>线程</strong>，线程在进程之下，成为了<strong>执行的基本单元</strong>。而且由于线程的调度开销远小于进程，所以也得到了广泛的使用。多线程慢慢地不再是多进程的附庸，<del>跨越了jieji</del></p>
<p>总之，多线程可以让我们的CPU跑的更充分。它明明可以上七休零，你要让它上五休二，不行，得狠狠压榨它</p>
<h2 id="2-多线程-in-Java"><a href="#2-多线程-in-Java" class="headerlink" title="2.多线程 in Java"></a>2.多线程 in <code>Java</code></h2><p>作为流行的编程语言，<code>Java</code>自然也提供了原生的线程库<code>java.util.concurrent</code>简称<code>JUC</code>。我们可以调用其提供的<code>API</code>快速上手多线程编程</p>
<h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p>在<code>Java</code>中有若干种方法创建一个线程，这里只介绍几种较为常用的方法</p>
<h4 id="i-Thread"><a href="#i-Thread" class="headerlink" title="i. Thread"></a>i. Thread</h4><p><code>Thread</code>类是<code>JUC</code>中提前定义好的线程类，我们只需要继承此类并<strong>重写</strong><code>run</code>方法即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MyThread.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...需要这个线程执行的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Main.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>欸我们刚刚不是重写了<code>run</code>方法吗，为什么调用了<code>start</code>方法？</p>
<ul>
<li>虽然重写了<code>run</code>方法，但是如果直接调用的话，两个线程的执行实际上还是串行的，和我们之前写代码的逻辑是一样的</li>
<li>但是调用了<code>start</code>方法后，线程将接受线程调度，可以并发执行，<code>start</code>方法内部也是调用了<code>run</code>方法的<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Thread.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    group.add(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        start0();</span><br><span class="line">        started = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">start0</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * If this thread was constructed using a separate</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;Runnable&lt;/code&gt; run object, then that</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;Runnable&lt;/code&gt; object&#x27;s &lt;code&gt;run&lt;/code&gt; method is called;</span></span><br><span class="line"><span class="comment"> * otherwise, this method does nothing and returns.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Subclasses of &lt;code&gt;Thread&lt;/code&gt; should override this method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     #start()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     #stop()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     #Thread(ThreadGroup, Runnable, String)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
确实可以看到<code>start</code>方法内部调用了<code>start0</code>方法，其创建系统级进程并启动<code>run</code>方法，不过似乎<strong>调用<code>run</code>方法前</strong>还做了一些什么事，难道线程不是<code>start</code>就启动了吗？这里先卖个关子后面在说</li>
</ul>
<h4 id="ii-Runnable"><a href="#ii-Runnable" class="headerlink" title="ii. Runnable"></a>ii. Runnable</h4><p>看到上面的源码也说了，如果线程使用了额外的<code>Runnable</code>实例对象，那么就会调用实例对象的<code>run</code>方法。所以我们启动线程的第二个方法就是通过<code>Runnable</code>对象传递给线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MyRunnable.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Main.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MyRunnble</span> <span class="variable">mr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mr);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mr);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这第二种方法还是有些许不一样的，例如需要重写<strong>接口</strong>的方法，同时传递给不同<code>Thread</code>类可以是同一个<code>Runnable</code>实例对象，看起来很神奇，难道我不是不同的线程吗，为什么用同一个对象</p>
<ul>
<li>线程可以访问共有对象，线程共用堆空间</li>
<li>线程共用实例对象方法不会有影响，线程不共用栈空间，每个线程有独立的栈</li>
<li>所以实际上是不同线程<strong>复用了同一个实例对象中方法的逻辑</strong>，两个方法的执行实际上是独立的</li>
</ul>
<p>当然我们这里使用的多线程方法都没法返回值。如果希望多线程计算等等，有兴趣的同学可以了解<code>Callable</code>和<code>Future</code>的使用，这里不涉及我们的作业，就不在此展开了。</p>
<h4 id="iii-常用的属性与方法"><a href="#iii-常用的属性与方法" class="headerlink" title="iii. 常用的属性与方法"></a>iii. 常用的属性与方法</h4><p><code>setName(String) -&gt; void</code></p>
<ul>
<li>可以给你的线程取一个洋气的名字，默认是<code>Thread-x</code>（x是main线程开始后开启的线程序号0、1…）</li>
</ul>
<p><code>getName() -&gt; String</code></p>
<ul>
<li>同上，获取线程的名字</li>
</ul>
<p><code>Thread(String str)</code></p>
<ul>
<li>当然也可以在创建线程是直接给它一个名字</li>
</ul>
<p><code>&#123;static&#125; currentThread() -&gt; Thread</code></p>
<ul>
<li>执行到此语句时的线程对象，例如希望在<code>Runnable</code>对象中获取线程实例</li>
</ul>
<p><code>&#123;static&#125; sleep(int) -&gt; void</code></p>
<ul>
<li>让执行此条语句的线程陷入休眠（<code>TMIED_WATING</code>）状态</li>
</ul>
<p><code>setDaemon(Thread) -&gt; void</code></p>
<ul>
<li>为当前线程设置一个守护线程，当前线程结束，守护线程将逐步暂停</li>
</ul>
<p><code>setPriority(int) -&gt; void</code></p>
<ul>
<li>设置线程执行优先级，优先级越高，被执行的概率越大</li>
<li>三个值<code>MIN_PRIORITY: 1</code>、<code>NORM_PRIORITY: 5</code>、<code>MAX_PRIORITY: 10</code></li>
</ul>
<h3 id="线程闹鬼事件"><a href="#线程闹鬼事件" class="headerlink" title="线程闹鬼事件"></a>线程闹鬼事件</h3><p>CVBB引入了一个马戏团，准备在下周五表演，CVBBer对此都十分感兴趣。为了照顾同学们宝贵的课余时间，主办方拜托小熊写一个多窗口的售票平台，方便同学们抢票。共计3个窗口，100张门票。事不宜迟，我们赶紧开始吧</p>
<p>我们先浅浅地实现一个售票机</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//VendingMachine.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VendingMachine</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getTicket</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (canGetTicket()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">canGetTicket</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ticket &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            ticket++;</span><br><span class="line">            System.out.println(<span class="string">&quot;ticket@&quot;</span> + ticket + <span class="string">&quot; sold!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Main.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">VendingMachine</span> <span class="variable">vm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VendingMachine</span>();</span><br><span class="line">    vm.getTicket();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; ticket@<span class="number">1</span> sold!</span><br><span class="line">&gt;&gt;&gt; ticket@<span class="number">2</span> sold!</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; ticket@<span class="number">100</span> sold!</span><br></pre></td></tr></table></figure>
<p>测试一下，嗯，果然运行地很好。现在我们把它改为多线程吧，无非就是实现<code>Runnable</code>罢了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VendingMachine</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (canGetTicket()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Main.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">VendingMachine</span> <span class="variable">vm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VendingMachine</span>();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(vm);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(vm);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(vm);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t3.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; ticket@<span class="number">3</span> sold!</span><br><span class="line">&gt;&gt;&gt; ticket@<span class="number">3</span> sold!</span><br><span class="line">&gt;&gt;&gt; ticket@<span class="number">3</span> sold!</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; ticket@<span class="number">101</span> sold!</span><br><span class="line">&gt;&gt;&gt; ticket@<span class="number">102</span> sold!</span><br><span class="line">&gt;&gt;&gt; ticket@<span class="number">102</span> sold!</span><br></pre></td></tr></table></figure>
<p>aaa，完蛋了。不仅票卖重复了，甚至还卖出了假票（），这究竟是怎么回事呢<br>我们观察<code>canGetTicket</code>方法内部的逻辑，当三个线程同时进入该方法后，按如下顺序继续执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t1 -&gt; ticket++</span><br><span class="line">t2 -&gt; ticket++</span><br><span class="line">t3 -&gt; ticket++</span><br><span class="line">t1 -&gt; sout(...)</span><br><span class="line">t2 -&gt; sout(...)</span><br><span class="line">t3 -&gt; sout(...)</span><br></pre></td></tr></table></figure>
<p>啊，原来线程<code>t1</code>执行完票号加一操作没有立刻打印出来，CPU执行权被截胡了，最后导致了悲剧的发生。那我们到底应该如何解决这个问题呢</p>
<h3 id="数据安全"><a href="#数据安全" class="headerlink" title="数据安全"></a>数据安全</h3><p>刚刚讲到了线程引发的赛博闹鬼事件。那么我们应该如何避免这种现象的发生呢<br>观察我们刚刚发现的问题</p>
<ul>
<li>多个相同的票号是因为 <strong><code>ticket</code>自增与打印值</strong>两个操作并非一气呵成的，也就是非<strong>原子操作</strong></li>
<li>超出范围的票号是因为 <strong>判断<code>ticket</code>大小与<code>ticket</code>自增</strong>两个操作并非一气呵成的，也是因为非<strong>原子操作</strong></li>
</ul>
<p>我们当然很难去把这种操作实现为一个底层的汇编指令。虽然这样能从根本上解决什么原子、非原子问题。但是理论上我们需要的原子操作是无限的，但是指令集是有限的。<br>于是我们把原子操作放在某个对象上，对于这个对象的获取与释放是<strong>原子操作</strong>，这是互斥锁的一个简陋的描述</p>
<h4 id="synchronized关键词"><a href="#synchronized关键词" class="headerlink" title="synchronized关键词"></a><code>synchronized</code>关键词</h4><p>关于<code>synchronized</code>的底层实现是极为复杂的，因为Java8之后，<code>synchronized</code>的实现进行了大量的优化操作，其中涉及到锁的升级等等。但是我们可以简单地认为它是通过原子操作请求和释放锁的</p>
<h5 id="1-synchronized同步代码块解决互斥"><a href="#1-synchronized同步代码块解决互斥" class="headerlink" title="1. synchronized同步代码块解决互斥"></a>1. synchronized同步代码块解决互斥</h5><p>同一时间，只能有一个线程进入同步代码块执行操作，其余线程阻塞在外部<br>对于一个<strong>共有的变量</strong>上锁，通常可以使用<code>.class</code>文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">//synchronized (VendingMachine.class)</span></span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-synchronized同步方法解决互斥"><a href="#2-synchronized同步方法解决互斥" class="headerlink" title="2. synchronized同步方法解决互斥"></a>2. synchronized同步方法解决互斥</h5><p>和上面同步代码块实际是一致的</p>
<ul>
<li>对于非静态方法，默认锁住<code>this</code>实例对象，即同一时间一个<strong>实例对象</strong>中所有的<code>synchronized</code>修饰的<strong>非静态</strong>方法中只能<strong>有一个方法被一个线程使用</strong></li>
<li>对于静态方法，默认锁住<code>class</code>类对象，即同一时间一个<strong>类</strong>中所有<code>synchronized</code>修饰的<strong>静态</strong>方法只能<strong>有一个方法被一个线程使用</strong></li>
<li><code>class</code>类对象和<code>this</code>对象显然非同一对象，所以<code>synchronized</code>修饰的静态和非静态方法之间并没有限制</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (canGetTicket(...)) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">canGetTicket</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="wait、notify解决同步问题"><a href="#wait、notify解决同步问题" class="headerlink" title="wait、notify解决同步问题"></a>wait、notify解决同步问题</h5><p>在上述情况下，我们只关注对于<strong>共用资源</strong>的访问同一时刻只能由一个线程执行。但是在某些情况下，不仅这种资源的访问是互斥的，顺序也是需要依照一定的规律</p>
<p><strong>吃青提</strong><br>小明的妈妈给他买了一盒阳光青提。妈妈开始洗青提，每洗好一个青提就会放在盘子中，直到盘子装满了为止。小明同时开始吃青提，直到盘子为空为止。已知共有50个青提，盘子最多盛放3个青提。<br>我们可以比较容易地看出可以为小明和妈妈都设置一个线程，一个负责放一个负责吃。而且对于盘子这个资源的访问应该是互斥的。这样是否就足够了呢？？？如果刚开始小明进程开始执行，发现盘子中没有青提，小明应该怎么办？</p>
<ul>
<li>首先盘子是<strong>共用的资源</strong>（临界资源），所以对盘子的访问是互斥的</li>
<li>其次，线程结束的标志是青提洗完了？？？（真的是这个吗？）</li>
<li>小明吃完了青提，想要再次吃的时候必须要阻塞（如何阻塞），要去唤醒妈妈继续洗（如何唤醒）</li>
<li>盘子中装满了青提时，妈妈要是还想放也需要阻塞，要去通知小明吃青提</li>
</ul>
<p>首先是盘子，这个容器最好写了，不需要任何方法，定义一些属性即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Plate.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Plate</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">maxTimes</span> <span class="operator">=</span> <span class="number">50</span>; <span class="comment">//最多使用次数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> <span class="number">3</span>; <span class="comment">//最大容量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">now</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//当前容量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">//互斥锁对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其次就是妈妈，其实就是生产者，负责将东西放入盘子中</p>
<ul>
<li>生产者会一直尝试将东西放入盘子中，直到<strong>盘子放满则阻塞</strong>，<strong>次数耗尽则死亡</strong></li>
<li><code>wait</code>方法会将当前线程“挂”在锁下，并释放锁，线程进入阻塞（<code>BLOCKED</code>）状态</li>
<li><code>notifyAll</code>方法将唤醒所有被<strong>挂在该对象下的线程</strong>，但最终只能有一个线程获得执行权，其他线程继续进入阻塞状态，等待下一次唤醒抢夺CPU控制权</li>
<li><strong>attention</strong>：<code>wait</code>方法需要在<code>while</code>循环中使用，因为有时线程会被“虚假唤醒”，莫名地就会执行后面的语句，极不安全<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (produce()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">produce</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (Plate.lock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Plate.maxTimes == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (Plate.now &gt;= Plate.capacity) &#123;</span><br><span class="line">            Plate.lock.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        Plate.now++;</span><br><span class="line">        Plate.maxTimes--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; produce grape, with &quot;</span> + Plate.maxTimes + <span class="string">&quot; left&quot;</span>);</span><br><span class="line">        Plate.lock.notifyAll();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
最后是小明，第一次写还是有很多问题的（:sob:</li>
<li>消费者进程会一直尝试从盘子中拿出食物，直到<strong>盘为空则阻塞？？？</strong>，<strong>次数耗尽则死亡？？？</strong></li>
<li>结束的条件并不只是次数耗尽，次数耗尽指生产者已经全部生产完食物，但是消费者有没有消耗完呢？<ul>
<li>假设生产者线程结束时，所有消费者都在consume方法开始，那么接下来每个消费者线程发现<code>Plate.maxTimes == 0</code>即退出，那么生产者最后生产的物品并没有被消耗</li>
</ul>
</li>
<li>唤醒条件即当前盘是否为空，只有盘为空消费者才能继续执行下去吗？<ul>
<li>假设现在生产者线程已经结束，有若干消费者进程在等待，其中一个消费者消耗了生产者最后生产的若干物品并正常退出了，剩下的消费者怎么办？？？**即使它们被唤醒，但是检查发现<code>Plate.now == 0</code>**又会继续等待，程序将无法终止</li>
</ul>
</li>
<li>所以真正的条件应该如下，而非注释中的一般情况<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//run...</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// Thread.sleep(20);</span></span><br><span class="line">    <span class="keyword">synchronized</span> (Plate.lock) &#123;</span><br><span class="line">        <span class="comment">// if (Plate.maxTimes == 0) ???</span></span><br><span class="line">        <span class="keyword">if</span> (Plate.maxTimes == <span class="number">0</span> &amp;&amp; Plate.now == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// while (Plate.now &lt;= 0) ???</span></span><br><span class="line">        <span class="keyword">while</span> (Plate.now &lt;= <span class="number">0</span> &amp;&amp; Plate.maxTimes != <span class="number">0</span>) &#123;</span><br><span class="line">            Plate.lock.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Plate.now &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Plate.now--;</span><br><span class="line">            index++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; consume grape&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Plate.lock.notifyAll();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a><code>ReentrantLock</code></h4><p><code>Lock</code>对象是<code>JUC</code>中的显式锁，需要用户手动上锁&#x2F;关锁，但是是一个接口，我们需要使用它的一个实现类<code>ReetrantLock</code><br>例如将上面代码改写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Plate.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReetrantLock</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Consumer.java</span></span><br><span class="line"><span class="comment">//上锁</span></span><br><span class="line">Plate.lock.lock();</span><br><span class="line">    <span class="keyword">if</span> (Plate.maxTimes == <span class="number">0</span> &amp;&amp; Plate.now == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (Plate.now &lt;= <span class="number">0</span> &amp;&amp; Plate.maxTimes != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//阻塞进程</span></span><br><span class="line">        Plate.condition.await();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Plate.now &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Plate.now--;</span><br><span class="line">        index++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; consume grape&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//唤醒阻塞进程</span></span><br><span class="line">    Plate.condition.signalAll();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line">Plate.lock.unlock();</span><br></pre></td></tr></table></figure>
<p>再次运行程序，发现了神奇的一幕，程序无法结束了。这是为什么呢？</p>
<ul>
<li>我们查看刚刚改过的代码，发现<code>return true;</code>时没有<strong>把锁打开</strong>，导致了锁一直处于关闭状态</li>
<li>我们应该使用<code>finally</code>块，使得无论如何都要将锁打开<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Plate.lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    Plate.lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a><code>ReadWriteLock</code></h4><h5 id="读写锁手动实现"><a href="#读写锁手动实现" class="headerlink" title="读写锁手动实现"></a>读写锁手动实现</h5><p>读写锁，这个涉及到另一个经典的多线程问题————“读者与写者问题”</p>
<ul>
<li>对于一个文件的操作可以分为读、写两种线程</li>
<li>读线程可以有多个同时一起读文件</li>
<li>写线程必须与读线程和其他写线程互斥</li>
</ul>
<p>这个问题最有意思的一点在于，我们应该如何让多个读线程不互斥</p>
<ul>
<li>这个问题和刚刚的盘子容量有些类似，只是这次盘子的容量是无限大的，所以我们可以这样考虑：<strong>永远只给第一个读线程上锁，永远只给最后一个读线程解锁</strong><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//read</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReetrantLock</span>(); <span class="comment">//读写锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 记录所有的读进程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">&#125;</span><br><span class="line">count++;</span><br><span class="line">read();<span class="comment">// 真正的读操作</span></span><br><span class="line">count--;</span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
但是这样还有问题，因为<code>count == 0</code>与<code>count++</code>不是原子操作，可能导致多个读者线程进入<code>if</code>区域尝试获取锁，导致读者们相互阻塞，并不是我们希望看到的。同理下方的<code>count</code>也需要保护<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//read</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReetrantLock</span>(); <span class="comment">//读写锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">mutex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReetrantLock</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 记录所有的读进程</span></span><br><span class="line"></span><br><span class="line">mutex.lock();</span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">&#125;</span><br><span class="line">count++;</span><br><span class="line">mutex.unlock();</span><br><span class="line">read();<span class="comment">// 真正的读操作</span></span><br><span class="line">mutex.lock();</span><br><span class="line">count--;</span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">mutex.unlock();</span><br></pre></td></tr></table></figure>
写进程也是同理了<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lock.lock();</span><br><span class="line">write(); <span class="comment">// 真正的写操作</span></span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure>
最后观察发现，我们实现的锁是非公平锁，甚至有些太不公平了。如果一直有读线程到来，写线程最终可能会饿死。所以我们可以多设置一个锁，保持公平。但是于此同时，程序的性能会受到一些影响。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="type">Lock</span> <span class="variable">priority</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReetrantLock</span>();</span><br><span class="line"></span><br><span class="line">priority.lock();</span><br><span class="line"><span class="comment">//写线程原有代码</span></span><br><span class="line">priority.unlock();</span><br><span class="line"></span><br><span class="line">priority.lock();</span><br><span class="line"><span class="comment">//读线程前半段获取读写锁内容</span></span><br><span class="line">priority.unlock();</span><br><span class="line">read(); <span class="comment">//真正的读线程</span></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure></li>
<li>这样保证了如果在读者们读文件时，写者先到来，那么接下来会轮到写者执行，<code>priority</code>锁保证了读写操作的公平性。但是实际读写锁常用于读操作显著高于写操作频率时。</li>
</ul>
<h5 id="ReetrantReadWriteLock"><a href="#ReetrantReadWriteLock" class="headerlink" title="ReetrantReadWriteLock"></a><code>ReetrantReadWriteLock</code></h5><p>当然<code>JUC</code>已经实现了我们刚刚说的读写锁。而且性能、稳定性各方面都是碾压我们手写的（毕竟它底层实现不仅有众多原子操作优化、锁优化，还能享受到<code>JVM</code>级的一些优化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ReedWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"><span class="type">Lock</span> <span class="variable">rLock</span> <span class="operator">=</span> lock.readLock();</span><br><span class="line"><span class="type">Lock</span> <span class="variable">wLock</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line"></span><br><span class="line">rLock.lock();</span><br><span class="line">read();</span><br><span class="line">rLock.unlock();</span><br><span class="line"></span><br><span class="line">wLock.lock();</span><br><span class="line">write();</span><br><span class="line">wLock.unlock();</span><br></pre></td></tr></table></figure>
<p>锁<del>升级</del>与降级<br>如果一个线程写完了之后发现自己还想读该怎么办，写锁降级为读锁</p>
<ul>
<li><code>ReetrantReadWriteLock</code>支持重入，一个获取到写锁的线程再去获取读锁并不会阻塞自己，而是可以正常地获取<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">wLock.lock();</span><br><span class="line">write();</span><br><span class="line"><span class="comment">//还想读</span></span><br><span class="line">rLock.lock();</span><br><span class="line">wLock.unlock();</span><br><span class="line">read();</span><br><span class="line">rLock.unlock();</span><br></pre></td></tr></table></figure>
如果一个线程读完之后发现自己还想写该怎么办，读锁升级为写锁？？？</li>
<li>错误的，获取到读锁的同时不允许同时再去获取写锁，这样可能导致同时在读取的线程发生数据不一致错误，必须先释放读锁然后再尝试获取写锁<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">rLock.lock();</span><br><span class="line">read();</span><br><span class="line">rLock.unlock();</span><br><span class="line">wLock.lock();</span><br><span class="line">write();</span><br><span class="line">wLock.unlock();</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a><code>Semaphore</code></h4><p>信号量是一个伟大的发明，<code>JUC</code>的信号量实际上就是记录型自变量。信号量声明了一个资源的多少，允许多个线程去获取这种资源，但是超过拥有资源的限制后，线程将被“挂”在信号量下，等待资源被其他线程释放。</p>
<ul>
<li>听着好熟悉，感觉和小明吃青提的问题很像。</li>
<li>是的，其实解决生产者消费者问题的代码实现，是我手动模拟了一个信号量。还是那句话，既然<code>Java</code>已经实现好了我们用就是了</li>
</ul>
<p>思考一下信号量实现同步问题，因为获取信号量时如果没有默认会进入<code>wait</code>状态，而释放信号量时也默认会去通知被阻塞的进程。我们的代码实际可以写的更加简洁li</p>
<ul>
<li>细细分析一下生产者与消费者的同步关系，下面的“生产”、“消耗”对应着信号量的意义，是对于资源而言的</li>
<li>消费者消耗完食物 -&gt; 通知生产者生产（消费者生产“空资源”， 生产者消耗“空资源”）</li>
<li>生产者生产食物过剩 -&gt; 通知消费者消费（生产者生产“食物资源”，消费者消耗“食物资源”）</li>
<li>所以我们不妨设置两个意义相反的信号量用于指代资源。那理所应当的，起始时空资源大小应该等于盘子的大小，食物资源的大小应该为0<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Plate</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">maxTimes</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">//总的生产次数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Semaphore</span> <span class="variable">full</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">0</span>); <span class="comment">//食物资源，这里为了反义词</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; foods = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">//盘子</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Semaphore</span> <span class="variable">empty</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>); <span class="comment">//空资源</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Consumer</span></span><br><span class="line"><span class="comment">//消耗食物资源</span></span><br><span class="line">Plate.full.acquire();</span><br><span class="line"><span class="keyword">synchronized</span> (Plate.class) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Plate.maxTimes == <span class="number">0</span> &amp;&amp; Plate.foods.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//既然没用就归还资源</span></span><br><span class="line">        Plate.full.release();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Plate.foods.remove(<span class="number">0</span>);</span><br><span class="line">    consumed.add(index);</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; consume grape@&quot;</span> + index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生产空资源</span></span><br><span class="line">Plate.empty.release();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Producer</span></span><br><span class="line"><span class="comment">//获取空资源</span></span><br><span class="line">Plate.empty.acquire();</span><br><span class="line"><span class="keyword">synchronized</span> (Plate.class) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Plate.maxTimes == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//既然没用就归还资源</span></span><br><span class="line">        Plate.empty.release();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Plate.maxTimes--;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">100</span> - Plate.maxTimes;</span><br><span class="line">    Plate.foods.add(index);</span><br><span class="line">    produced.add(index);</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; produce grape@&quot;</span> + index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生产食物资源</span></span><br><span class="line">Plate.full.release();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
接下来我们运行发现，消费者消费完之后程序停不下来了。看看结束的情况，感觉也没问题啊，没用的资源还回去怎么会出问题呢</li>
<li>这里还是假设生产者生成了最后三个食物资源后死亡。接下来有三个消费者线程分别消耗一个食物资源。此时刚好所有食物也消耗完了，是时候结束进程了。这是某一个消费者线程希望通过<code>if (Plate.maxTimes == 0 &amp;&amp; foods.isEmpty())</code>返回，但是它必须先获得一个食物资源<code>Plate.full.acquire</code>，此时生产者线程已经全部死亡，而我们分析食物资源也已经耗尽，程序陷入死锁状态</li>
<li>解决方案<ul>
<li>先判断一遍是否可以提前返回再获取资源（缺点：麻烦，在多个地方返回写同样的语句）<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (Plate.class) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Plate.maxTimes == <span class="number">0</span> &amp;&amp; foods.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Plate.full.acquire();</span><br><span class="line"><span class="keyword">synchronized</span> (Plate.class) &#123;</span><br><span class="line">    <span class="keyword">if</span> (...) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>让生产者线程死亡前<strong>多留一个食物资源用于退出</strong>，使用<code>finally</code>即可<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Plate.empty.acquire();</span><br><span class="line">    <span class="keyword">synchronized</span> (Plate.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (...) &#123;</span><br><span class="line">            ....</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    Plate.full.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
我们显然可以证明，多留出多少个食物资源都不会影响消费者消耗的数量，因为<strong>正常情况下生产者还会将生产的食物放入<code>foods</code>中</strong>。所以前面的食物资源将最后的<code>food</code>消耗了之后，剩余的食物资源则被用于退出，而且退出前还会归还这个多余的食物资源，就算只有一个食物资源剩余，所有的消费者进程都是可以正常退出的不会受到任何影响！</li>
</ul>
</li>
</ul>
<p>最后还有一个小小的问题，为什么不能将获取资源的操作放在<strong>互斥锁</strong>内部</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (Plate.class) &#123;</span><br><span class="line">    Plate.full.acquire();</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>acquire()</code>、<code>release()</code>方法使用原子操作，线程安全不需要上锁</li>
<li>放在内部会造成死锁现象，我们需要遵循额反正是一条避免死锁的原则，一个对象我们保证其先获得所有执行使用的资源再给他执行的机会，而不是一边给他资源，一边让他等其他资源。<ul>
<li>假设现在消费者先拿到<strong>互斥锁</strong>，然后请求<strong>食物资源</strong>。食物资源没有了，于是消费者主动放弃了CPU执行权给生产者，希望生产者生产食物资源。但是因为生产者<strong>拿不到互斥锁</strong>，导致无法生产<strong>食物资源</strong>，二者陷入了死锁困境。</li>
</ul>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Java</code>多线程远不止这些:sob:，还有各种千奇百怪的锁(<code>自旋锁</code>等等)，<code>JUC</code>也提供了若干优化的策略，例如无锁原子操作<code>CompareAndSwap</code>、<code>TestAndSet</code>等等，还有锁使用策略例如轻量锁、自旋锁、重量锁等等。多线程永无止境！</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://Kie-Chi.github.io">Chi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://kie-chi.github.io/2025/03/20/OO_u2_pre/">https://kie-chi.github.io/2025/03/20/OO_u2_pre/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Kie-Chi.github.io" target="_blank">Trash Bin for Chi</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/OO/">OO</a></div><div class="post_share"><div class="social-share" data-image="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/oo_2.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助一杯咖啡</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/whechat.jpg" target="_blank"><img class="post-qr-code-img" src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/whechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2025/03/19/OO_u1/" title="面向对象u1"><img class="cover" src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/oo_3.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">面向对象u1</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2025/03/19/OO_u1/" title="面向对象u1"><img class="cover" src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/oo_3.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-19</div><div class="title">面向对象u1</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/author.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Chi</div><div class="author-info__description">这个人很懒，这里什么都没有留下</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Kie-Chi"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Kie-Chi" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:xchi_xikai@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://github.com/Kie-Chi/my_co_repo" target="_blank" title="Code"><i class="fa-solid fa-code" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">懒人刷新处</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#OO-u2-pre"><span class="toc-number">1.</span> <span class="toc-text">OO_u2 pre</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.1.</span> <span class="toc-text">1.多线程是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%A4%9A%E7%BA%BF%E7%A8%8B-in-Java"><span class="toc-number">1.2.</span> <span class="toc-text">2.多线程 in Java</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">创建线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#i-Thread"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">i. Thread</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ii-Runnable"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">ii. Runnable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#iii-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">iii. 常用的属性与方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B9%E9%AC%BC%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.2.2.</span> <span class="toc-text">线程闹鬼事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8"><span class="toc-number">1.2.3.</span> <span class="toc-text">数据安全</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized%E5%85%B3%E9%94%AE%E8%AF%8D"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">synchronized关键词</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-synchronized%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97%E8%A7%A3%E5%86%B3%E4%BA%92%E6%96%A5"><span class="toc-number">1.2.3.1.1.</span> <span class="toc-text">1. synchronized同步代码块解决互斥</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-synchronized%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E8%A7%A3%E5%86%B3%E4%BA%92%E6%96%A5"><span class="toc-number">1.2.3.1.2.</span> <span class="toc-text">2. synchronized同步方法解决互斥</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#wait%E3%80%81notify%E8%A7%A3%E5%86%B3%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.3.1.3.</span> <span class="toc-text">wait、notify解决同步问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ReentrantLock"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">ReentrantLock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ReadWriteLock"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">ReadWriteLock</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.3.3.1.</span> <span class="toc-text">读写锁手动实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ReetrantReadWriteLock"><span class="toc-number">1.2.3.3.2.</span> <span class="toc-text">ReetrantReadWriteLock</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Semaphore"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">Semaphore</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.3.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/03/20/OO_u2_pre/" title="面向对象u2-pre"><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/oo_2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面向对象u2-pre"/></a><div class="content"><a class="title" href="/2025/03/20/OO_u2_pre/" title="面向对象u2-pre">面向对象u2-pre</a><time datetime="2025-03-20T14:00:00.000Z" title="发表于 2025-03-20 22:00:00">2025-03-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/19/OO_u1/" title="面向对象u1"><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/oo_3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面向对象u1"/></a><div class="content"><a class="title" href="/2025/03/19/OO_u1/" title="面向对象u1">面向对象u1</a><time datetime="2025-03-19T08:00:00.000Z" title="发表于 2025-03-19 16:00:00">2025-03-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/02/09/Shell_2/" title="Shell脚本(2)"><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/LINUX_3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Shell脚本(2)"/></a><div class="content"><a class="title" href="/2025/02/09/Shell_2/" title="Shell脚本(2)">Shell脚本(2)</a><time datetime="2025-02-09T08:00:00.000Z" title="发表于 2025-02-09 16:00:00">2025-02-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/02/08/Shell/" title="Shell脚本(1)"><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/LINUX_1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Shell脚本(1)"/></a><div class="content"><a class="title" href="/2025/02/08/Shell/" title="Shell脚本(1)">Shell脚本(1)</a><time datetime="2025-02-08T10:00:00.000Z" title="发表于 2025-02-08 18:00:00">2025-02-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/08/CO_P6/" title="北航计算机组成P6"><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CO_2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="北航计算机组成P6"/></a><div class="content"><a class="title" href="/2024/12/08/CO_P6/" title="北航计算机组成P6">北航计算机组成P6</a><time datetime="2024-12-08T14:00:00.000Z" title="发表于 2024-12-08 22:00:00">2024-12-08</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/oo_2.png')"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By Chi</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid@10.8.0/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const initGitalk = () => {
    const gitalk = new Gitalk(Object.assign({
      clientID: 'Ov23liTVvzPE9besvps5',
      clientSecret: 'c1345a196978f719c699170e2f7a04939333916e',
      repo: 'kie-chi.github.io',
      owner: 'kie-chi',
      admin: ['kie-chi'],
      id: 'b3f17f722b213e4fc93a1a6ebb4de4fe',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async() => {
    if (typeof Gitalk === 'function') initGitalk()
    else {
      await getCSS('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.css')
      await getScript('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js')
      initGitalk()
    }
  }
  
  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  if ('Gitalk' === 'Gitalk' || !true) {
    if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const findTrueUrl = (array) => {
    Promise.all(array.map(item =>
      fetch(item.url).then(resp => resp.json()).then(data => {
        let urlArray = data.body ? data.body.match(/(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?/ig) : []
        if (!Array.isArray(urlArray) || urlArray.length === 0) {
          urlArray = [`${data.html_url}`]
        }
        if (data.user.login === 'utterances-bot') {
          return urlArray.pop()
        } else {
          return urlArray.shift()
        }
      })
    )).then(res => {
        array = array.map((i,index)=> {
          return {
            ...i,
            url: res[index]
          }
        })

        saveToLocal.set('github-newest-comments', JSON.stringify(array), 10/(60*24))
        generateHtml(array)
    });
  }

  const getComment = () => {
    fetch('https://api.github.com/repos/kie-chi/kie-chi.github.io/issues/comments?sort=updated&direction=desc&per_page=6&page=1',{
      "headers": {
        Accept: 'application/vnd.github.v3.html+json'
      }
    })
      .then(response => response.json())
      .then(data => {
        const githubArray = data.map(item => {
          return {
            'avatar': item.user.avatar_url,
            'content': changeContent(item.body_html || item.body),
            'nick': item.user.login,
            'url': item.issue_url,
            'date': item.updated_at,
            'githubUrl': item.html_url
          }
        })
        findTrueUrl(githubArray)
      }).catch(e => {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('github-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-show-text.min.js" data-mobile="true" data-text="Ok!,Good!,Great!,Amazing!,Excellent!,Crazy!,Unbelievable" data-fontsize="15px" data-random="false" async="async"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.22.1/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4.65.0/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js?v=4.13.0"></script></div></div></body></html>