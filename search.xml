<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>计算机网络--物理层</title>
    <url>/2024/10/06/CN_u2/</url>
    <content><![CDATA[<h1 id="计算机网络物理层"><a class="markdownIt-Anchor" href="#计算机网络物理层"></a> 计算机网络–物理层</h1>
<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<ul>
<li>在上一次的 blog 中我们对于计算机网络的结构功能等基础内容，从这一节开始我们将要学习的是计算机网络模型的第一层–物理层，通过物理层我们可以将需要传递的数据变为真实的物理信号，由此通过信息通路(也就是第零层)传递出去</li>
</ul>
<h2 id="通信基础"><a class="markdownIt-Anchor" href="#通信基础"></a> 通信基础</h2>
<ul>
<li>信源
<ul>
<li>信息的发送方</li>
</ul>
</li>
<li>信宿
<ul>
<li>信息的接收方</li>
</ul>
</li>
<li>信道
<ul>
<li>信息传输的通道</li>
</ul>
</li>
<li>信号
<ul>
<li>数字信号：信号是离散的</li>
<li>模拟信号：信号是连续的</li>
</ul>
</li>
</ul>
<hr />
<h3 id="信号"><a class="markdownIt-Anchor" href="#信号"></a> 信号</h3>
<ul>
<li>在计算机中，我们常常使用一位的二进制 0/1 来表示信号，但是这并不代表着信号只能是一位的二进制(两种)</li>
<li><strong>码元</strong>
<ul>
<li>每一个信号都是一个码元，每一个码元都对应一个二进制数</li>
<li>对于一位的信号只有两种码元，我们称为<strong>二进制码元</strong>；对于两位的信号会有四种码元，我们称为<strong>四进制码元</strong>。一个信号输出的整个周期被称为信号周期或者码元周期</li>
<li>优缺点
<ul>
<li>优点：每个信号周期可以携带更多信息，每个码元可以携带更多信息</li>
<li>缺点：需要加强信号功率，并且对信道的要求更高</li>
</ul>
</li>
</ul>
</li>
<li><strong>码元</strong>与<strong>比特</strong>的关系
<ul>
<li>一个码元可以携带多少比特，这取决于一个码元周期可以有多少种信号</li>
<li>$ X_{码元} = \log_2 K * X_{比特}<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo></mrow><annotation encoding="application/x-tex">(</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span></span></span></span>K$为信号的种类数量)</li>
</ul>
</li>
<li>速率
<ul>
<li>波特率：每秒钟传递多少码元</li>
<li>比特率：每秒钟传递多少比特信息</li>
</ul>
</li>
</ul>
<hr />
<h3 id="信道"><a class="markdownIt-Anchor" href="#信道"></a> 信道</h3>
<ul>
<li><strong>带宽</strong>
<ul>
<li>含义一：传输的最大速率</li>
<li>含义二：允许通过的信号频带范围<br />
<font color = red> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>t</mi><mi>t</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">Attention</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal">t</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span></span></span></span></font>:下面为了方便突出两者的联系，取<strong>最高传输速率</strong>表示带宽第一种含义，取<strong>带宽</strong>只表示第二种含义<br />
<br><br />
虽然带宽的两种含义看起来毫不相关，但是下面介绍的两个定理都揭示了这两种含义之间的内在联系，在这之前我们先介绍噪声，这个极易影响信息传输的坏家伙</li>
</ul>
</li>
<li><strong>噪声</strong>
<ul>
<li>对于在信道中传输的信号有干扰作用，会影响信道的数据传输速率<br />
这和我们在学习物理中声音的噪声概念几乎是一致的，都是干扰、妨碍的作用。</li>
</ul>
</li>
<li><strong>奈奎斯特定理</strong>(奈氏准则)
<ul>
<li>对于一个<strong>理想低通信道</strong>(没有噪声、带宽有限的信道)</li>
<li>$ V_{极限波特率} = 2 * X_{带宽}$</li>
<li>注意<strong>极限波特率</strong>与最高传输速率(默认比特率的转换<br />
奈氏准则向我们揭示了<strong>无噪声</strong>情况下最高传输速率与带宽之间的内在联系</li>
</ul>
</li>
<li><strong>香农定理</strong>
<ul>
<li>对于一个有噪声、带宽有限的信道</li>
<li>$ V_{极限比特率} = X_{带宽} * \log_2 (1 + S/N) $</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi mathvariant="normal">/</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">S/N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>是信噪比，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><msub><mi>W</mi><mtext>信号的功率</mtext></msub><msub><mi>W</mi><mtext>噪声的功率</mtext></msub></mfrac></mrow><annotation encoding="application/x-tex">\frac{W_{信号的功率}} {W_{噪声的功率}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3339409999999998em;vertical-align:-0.44530499999999995em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8886359999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3567071428571427em;margin-left:-0.13889em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">噪</span><span class="mord cjk_fallback mtight">声</span><span class="mord cjk_fallback mtight">的</span><span class="mord cjk_fallback mtight">功</span><span class="mord cjk_fallback mtight">率</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.14329285714285717em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.410305em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3567071428571427em;margin-left:-0.13889em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">信</span><span class="mord cjk_fallback mtight">号</span><span class="mord cjk_fallback mtight">的</span><span class="mord cjk_fallback mtight">功</span><span class="mord cjk_fallback mtight">率</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.14329285714285717em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.44530499999999995em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li>
<li>由于信噪比的值往往很大，所以我们采取另一种记录信噪比的记法，即$ N_{信噪比} = 10 * \log_{10} S/N $单位是<code>dB</code></li>
<li>注意是<strong>极限比特率</strong></li>
</ul>
</li>
</ul>
<hr />
<h3 id="信号变换"><a class="markdownIt-Anchor" href="#信号变换"></a> 信号变换</h3>
<ul>
<li>数字信号
<ul>
<li>对于二进制数据与数字信号之间的转换，我们称为<strong>编码与解码</strong></li>
</ul>
</li>
<li>模拟信号
<ul>
<li>对于二进制数据与模拟信号之间的转换，我们称之为<strong>调制与解调</strong><br />
<strong>变换器</strong>可以将二进制信号转换为物理信号，<strong>反变换器</strong>可以将物理信号转换为二进制信号</li>
</ul>
</li>
<li>变换器
<ul>
<li>有线网络适配器(网卡)：编码-解码器</li>
<li>光猫：调制-解调器</li>
</ul>
</li>
</ul>
<hr />
<h4 id="编码方式"><a class="markdownIt-Anchor" href="#编码方式"></a> 编码方式</h4>
<ul>
<li>不归零编码(Non-Return-to-Zero)
<ul>
<li>低 0 高 1，中不变</li>
<li>在每一个信号周期内信号始终不会归零，缺点是要给出时钟线</li>
</ul>
</li>
<li>归零编码(Return-to-Zero)
<ul>
<li>低 0 高 1，中归零</li>
<li>每一个信号周期中间信号归零，保持发送方与接收方的时间节奏，保持时钟信号</li>
</ul>
</li>
<li>反向非归零编码(Non-Return-to-Zero-Inverted)
<ul>
<li>起点跳 0 不跳 1，中不变</li>
<li>每一个信号周期始终不归零，但是看每一个周期的起点是否会发生跳变</li>
</ul>
</li>
<li>曼彻斯特编码
<ul>
<li>上跳 0 下跳 1，中必变</li>
<li>每个周期中间位置将发生信号的跳变，根据信号是向上跳变还是向下跳变来规定这个信号周期对应的到底是 0 还是 1</li>
</ul>
</li>
<li>差分曼彻斯特编码
<ul>
<li>起点跳 0 不跳 1，中必变</li>
<li>与<code>NRZI</code>的区别在于信号周期中间一定会发生跳变<br />
<img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CN_u2_1.jpg" alt="编码方式示意图" /><br />
| 编码方式 | 自同步能力 | 浪费带宽 | 抗干扰能力 |<br />
| :-----: | :-------: | :—😐 :-----: |<br />
| 非归零编码 | 无 | 不浪费 | 弱 |<br />
| 归零编码|有 | 浪费 | 弱 |<br />
| 反向非归零编码 | 增加冗余位可支持 | 浪费(浪费的是冗余位) | 弱 |<br />
| 曼彻斯特编码 | 有 | 浪费 | 强 |<br />
| 差分曼彻斯特编码 | 有 | 浪费 | 强 |</li>
</ul>
</li>
</ul>
<hr />
<h4 id="调制方式"><a class="markdownIt-Anchor" href="#调制方式"></a> 调制方式</h4>
<ul>
<li>调幅(<code>AM</code>) or 幅移键控(<code>ASK</code>)
<ul>
<li>根据振幅表示信号</li>
<li>有振幅为 1，无振幅为 0</li>
<li>不同码元的振幅不同</li>
</ul>
</li>
<li>调频(<code>FM</code>) or 频移键控(<code>FSK</code>)
<ul>
<li>根据频率表示信号</li>
<li>例如频率低为 0，频率高为 1</li>
<li>不同的码元频率不同</li>
</ul>
</li>
<li>调相(<code>PM</code>) or 相移键控(<code>PSK</code>)
<ul>
<li>根据相位表示信号</li>
<li>例如相位为 0 则为 0，相位为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span> 则为 1</li>
<li>不同的码元相位不同<br />
对于这些调制方式甚至可以采用复合的方式，产生不同的调制方式</li>
</ul>
</li>
<li>正交幅度调制(<code>QAM</code>)
<ul>
<li>例如有<code>m</code>种振幅大小与<code>n</code>种频率大小，则共同可以综合出<code>mn</code>种码元<br />
<img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CN_u2_2.jpg" alt="调制方式示意图" /></li>
</ul>
</li>
</ul>
<hr />
<h4 id="传输介质"><a class="markdownIt-Anchor" href="#传输介质"></a> 传输介质</h4>
<ul>
<li>导向型介质：即沿着特定的方向传播，一般而言，有线信号是使用导向型介质
<ul>
<li>双绞线(<code>Twisted Pair</code>)
<ul>
<li>主要构成：两根导线相互绞合而成</li>
<li>有屏蔽层：<code>Shielded Twisted Pair</code>，无屏蔽层：<code>Unshielded Twisted Pair</code></li>
<li>抗干扰能力：较好，因为导线绞合以及屏蔽层可以提升抗电磁干扰能力</li>
</ul>
</li>
<li>同轴电缆
<ul>
<li>主要构成：内导体(用于传输信号) + 外导体屏蔽层(用于抗电磁干扰)</li>
<li>抗干扰能力：好，因为外导体提供电磁屏蔽可以带来良好的抗干扰性</li>
</ul>
</li>
<li>光纤
<ul>
<li>主要构成：纤芯(高折射率) + 包层(低折射率)，利用光的全反射特性让光信号在纤芯内传播</li>
<li>单模光纤：一根光纤中只有一条光线传播，适合长距离的传播；多模光纤：一根光纤中有多条光线传播，适合短距离的传播</li>
<li>抗干扰能力：非常好，光信号对电磁干扰不敏感</li>
</ul>
</li>
</ul>
</li>
<li>非导向型介质：无特定方向传播，一般而言，无线信号是使用非导向型介质
<ul>
<li>无线电波
<ul>
<li>特点：穿透能力强、传播距离长、信号指向型弱</li>
<li>例如：手机、WIFI 信号</li>
</ul>
</li>
<li>微波
<ul>
<li>特点：频率带宽高、信号指向型强、保密性差(容易被窃听)</li>
<li>例如：卫星通信</li>
</ul>
</li>
<li>红外通信、激光通信</li>
</ul>
</li>
<li>以太网对有线介质的命名
<ul>
<li>速度 + <code>Base</code> + 介质信息
<ul>
<li><code>10Base5</code>：10<code>Mbps</code> + 同轴电缆 + 最远传输距离 500m</li>
<li><code>10Base2</code>：10<code>Mbps</code> + 同轴电缆 + 最远传输距离 200m</li>
<li><code>10BaseF*</code>：10<code>Mbps</code> + 光纤 + *某些其他信息</li>
<li><code>10BaseT*</code>：10<code>Mbps</code> + 双绞线 + *某些其他信息</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<h4 id="物理层设备"><a class="markdownIt-Anchor" href="#物理层设备"></a> 物理层设备</h4>
<ul>
<li>
<p>中继器(<code>Repeater</code>)</p>
<ul>
<li>若规定 0.5V～1V 是低电平，4.5V～5V 是高电平，不符合此标准的信号视为无效</li>
<li>如果中继器接收了有效的信号会将低电平整形为 1V，将高电平整形为 5V</li>
<li>仅支持<strong>半双工通信</strong>，中继器连接的两个端口不允许同时发送数据，会导致“冲突”</li>
</ul>
</li>
<li>
<p>集线器(<code>Hub</code>)</p>
<ul>
<li>本质上是多端中继器，集线器将其中一个端口接收到的信号整形再生后，转发到所有的端口中</li>
<li>集线器各端口连接的结点不可以同时发送数据，会导致“冲突”</li>
</ul>
</li>
<li>
<p>冲突域</p>
<ul>
<li>如果两台主机同时发送数据会导致冲突，则这两台主机处于同一<strong>冲突域</strong>中</li>
</ul>
</li>
<li>
<p>其他特性</p>
<ul>
<li>集线器、中继器不能**“无限串联”**
<ul>
<li><code>10Base5</code>遵循<code>5-4-3</code>原则，使用集线器连接<code>10Base5</code>网线时，最多只能串联<strong>5</strong>个网段，使用<strong>4</strong>台集线器，只有<strong>3</strong>个网段可以连接计算机</li>
</ul>
</li>
<li>集线器逻辑上是总线型拓扑结构
<ul>
<li>集线器连接的各个网段会“共享带宽”，集线器的总带宽被连接的各个主机平均分配</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络--概述</title>
    <url>/2024/10/04/CN_u1/</url>
    <content><![CDATA[<h1 id="计算机网络概述"><a class="markdownIt-Anchor" href="#计算机网络概述"></a> 计算机网络–概述</h1>
<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<ul>
<li>国庆好无聊啊，小熊饼干接待完朋友、过完生日之后实在是没有什么事了，但是又不想更新<code>Python</code>，所以他决定开始学习计网</li>
<li>本栏目仅仅是笔者自学内容，与北京航空航天大学的计网无关，我不是我没有</li>
</ul>
<h2 id="什么是计网"><a class="markdownIt-Anchor" href="#什么是计网"></a> 什么是计网</h2>
<ul>
<li>硬件
<ul>
<li><strong>主机</strong>,又称<strong>端系统</strong>可以简单理解我们日常使用的电脑、服务器、手机、各类智能嵌入式系统等，他们处于计算机网络的边缘，所以称为端系统</li>
<li><strong>通信链路</strong>，像网线、电缆、光纤等物理连接设备，例如可以将两台电脑使用网卡连接，就组成了一个简单的计算机网络</li>
<li><strong>通信设备</strong>，端系统向计算机网络核心传递信息的中转站，例如集线器、交换机、路由器，通过他们我们可以将若干简单的计算机网络组成复杂的计算机网络</li>
</ul>
</li>
<li>软件
<ul>
<li>可以是在主机运行的应用程序，例如微信、QQ、网盘等，方便用户使用，实现资源共享的程序</li>
<li>可以是在通信设备中的控制程序，用以控制通信设备传输信息</li>
</ul>
</li>
<li>协议
<ul>
<li>规定计算机网络中的通信规则，利用这种规则封装传递的信息或者解构信息</li>
</ul>
</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>t</mi><mi>t</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">Attention</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal">t</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span></span></span></span>
<ul>
<li>使用集线器可以简单连接某几台设备，缺点是可能导致发送信息之间的冲突</li>
<li>使用交换机则不会出现信息冲突，不过交换机一般用于构建较小的计算机网络</li>
<li>使用路由器可以构建计算机网络核心，即各种通路</li>
</ul>
</li>
</ul>
<p>举一个快递的例子(似乎所有教材都会有一个快递的例子)：快递相当于传递的信息；各个快递终点站、快递驿站相当于端系统；公路、高速、立交桥相当于各种通信链路；快递中转站及仓库可以理解为通信设备；快递公司的运行规则和交通规则相当于协议</p>
<hr />
<h2 id="计网的功能"><a class="markdownIt-Anchor" href="#计网的功能"></a> 计网的功能</h2>
<ul>
<li>数据通信
<ul>
<li>实现计算机（端系统）之间的数据传输，是最基本、最重要的功能</li>
</ul>
</li>
<li>资源共享
<ul>
<li>请求服务器处理、网盘、分享视频、应用商店等</li>
</ul>
</li>
<li>分布式处理
<ul>
<li>将某个复杂任务分配给网络中多台计算机处理，提高任务处理效率</li>
</ul>
</li>
<li>提高可靠性
<ul>
<li>网络中各台计算机互为替代，数据冗余备份等操作</li>
</ul>
</li>
<li>复杂均衡
<ul>
<li>网络中多台计算机共同分担繁杂工作，如游戏服务器</li>
</ul>
</li>
</ul>
<hr />
<h2 id="计网通信"><a class="markdownIt-Anchor" href="#计网通信"></a> 计网通信</h2>
<h3 id="计网通信方式"><a class="markdownIt-Anchor" href="#计网通信方式"></a> 计网通信方式</h3>
<ul>
<li>因为在计算机之前已经有电话与发报机等可以传递信息的工具，那么计算机通信方式是否可以参考“前辈”的经验呢？答案是肯定的</li>
</ul>
<h4 id="电路交换技术"><a class="markdownIt-Anchor" href="#电路交换技术"></a> 电路交换技术</h4>
<ul>
<li>曾经的固定电话是通过电话线连接到电路交换器上的，在指定通信方与被通信方之后通过人工或者机器的方式连接实际物理电路，传递消息
<ul>
<li>建立连接（尝试占用资源）</li>
<li>通信（持续占用通信资源）</li>
<li>断开连接（归还占用资源）<br />
<img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CN_u1_1.png" alt="电路交换示意图" /></li>
</ul>
</li>
<li>优缺点分析
<ul>
<li>优点
<ul>
<li>建立了专用的物理电路，两个用户始终占用线路资源，数据传输速度快</li>
</ul>
</li>
<li>缺点
<ul>
<li>建立/释放连接需要额外的时间开销，等待通信时间可能过长</li>
<li>线路被通信双方占用，利用率差</li>
<li>线路的分配灵活性差（线路单一）</li>
<li>不支持差错控制，无法更改或者发现通信的错误</li>
</ul>
</li>
</ul>
</li>
<li>由于电路交换技术适合少频次大量数据的场景，一般的计算机通信常常是高频次少量数据的传递，所以计算机通信方式不适合<strong>直接沿用</strong>电路交换技术（为什么是直接沿用呢？）</li>
</ul>
<h4 id="报文交换技术"><a class="markdownIt-Anchor" href="#报文交换技术"></a> 报文交换技术</h4>
<ul>
<li>发报机通过线路连接到报文转发机上，通过对信息头部加入地址信息，由转发机自动向目的地转发，而不需要实际地接线<br />
<img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CN_u1_2.png" alt="报文交换示意图" /></li>
<li>优缺点分析
<ul>
<li>优点
<ul>
<li>不用占用通信双方中地资源，利用率高</li>
<li>无需建立连接，线路可以灵活分配</li>
<li>交换节点时可以“差错控制”</li>
</ul>
</li>
<li>缺点
<ul>
<li>报文长度不定，报文交换机地存储空间难以规定大小</li>
<li>长报文存储转发的时间开销大，缓存开销大</li>
<li>长报文的纠错困难，重发的代价大</li>
</ul>
</li>
</ul>
</li>
<li>由于对长报文的传输支持困难，所以计算机通信方式也没有沿用报文交换技术，而是在报文交换技术的基础上改进而成的分组交换技术</li>
</ul>
<h4 id="分组交换技术"><a class="markdownIt-Anchor" href="#分组交换技术"></a> 分组交换技术</h4>
<ul>
<li>将长报文分为若干段，称为分组(Packet)然后我们的传递最小单位由报文变成分组<br />
<img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CN_u1_3.png" alt="分组交换示意图" /></li>
<li>优缺点分析
<ul>
<li>优点
<ul>
<li>同报文交换技术</li>
<li>存储转发的时间开销小，缓存开销小</li>
<li>不易出错，且重传的代价小</li>
</ul>
</li>
<li>缺点
<ul>
<li>控制信息占比增加</li>
<li>存储转发时延依旧存在</li>
<li>发送的各个分组存在顺序问题，可能导致混乱</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="虚电路交换技术"><a class="markdownIt-Anchor" href="#虚电路交换技术"></a> 虚电路交换技术</h4>
<ul>
<li>对于分组交换技术可能出现的顺序问题，虚电路技术提供了一种方式解决（沿用了电路交换技术的策略）
<ul>
<li>建立连接（没有实际电路，仅作规划路径使用）</li>
<li>通信（分组按照顺序以构建好的路线传递，通信双方不用占用线路）</li>
<li>释放连接<br />
<img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CN_u1_4.png" alt="虚电路交换示意图" /></li>
</ul>
</li>
<li>优缺点分析
<ul>
<li>优点
<ul>
<li>同分组交换技术优点</li>
</ul>
</li>
<li>缺点
<ul>
<li>同分组交换技术缺点</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<h3 id="性能分析"><a class="markdownIt-Anchor" href="#性能分析"></a> 性能分析</h3>
<ul>
<li>对于上述电路交换技术、报文交换技术、分组交换技术进行性能的分析<br />
<img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CN_u1_5.png" alt="时序图" /><br />
<img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CN_u1_6.png" alt="性能分析对比图" /></li>
</ul>
<hr />
<h2 id="计网分类"><a class="markdownIt-Anchor" href="#计网分类"></a> 计网分类</h2>
<h3 id="范围"><a class="markdownIt-Anchor" href="#范围"></a> 范围</h3>
<ul>
<li>广域网(Wide Area Network)
<ul>
<li>范围大，跨省、跨国、跨洲</li>
</ul>
</li>
<li>城域网(Metropolitan Area Network)
<ul>
<li>范围较大，一个或几个相邻的城市</li>
<li>通信技术采用“以太网技术”，常并入局域网范畴讨论</li>
</ul>
</li>
<li>局域网(Local Area Network)
<ul>
<li>范围稍小，学校/企业/家庭等</li>
<li>通信技术采用“以太网技术”</li>
</ul>
</li>
<li>个域网(Personal Area Network)
<ul>
<li>范围小，家庭/个人</li>
<li>常使用无线技术将个人设备连接起来的网络，因此也被称为无线个域网(WPAN)</li>
</ul>
</li>
</ul>
<h3 id="传输技术"><a class="markdownIt-Anchor" href="#传输技术"></a> 传输技术</h3>
<ul>
<li>广播式网络
<ul>
<li>计算机发送数据分组时，广播范围内的所有计算机都会收到该分组，通过检查分组地址决定是否接受分组</li>
</ul>
</li>
<li>点对点网络
<ul>
<li>精确地发向某个计算机</li>
</ul>
</li>
</ul>
<h3 id="拓扑结构"><a class="markdownIt-Anchor" href="#拓扑结构"></a> 拓扑结构</h3>
<ul>
<li>总线形结构
<ul>
<li>数据采取广播式技术，存在“总线争用”的现象</li>
<li>集线器连接的设备</li>
</ul>
</li>
<li>环形结构
<ul>
<li>数据广播式传播但是，可以通过“令牌”指定当前发送数据的计算机，即拿到“令牌”者可以控制总线的数据，从而解决“总线争用的问题”</li>
<li>令牌环网</li>
</ul>
</li>
<li>星形结构
<ul>
<li>由中央设备实现各个设备的“点对点”传输，不存在“总线争用”的现象</li>
<li>以太网交换机连接的设备</li>
</ul>
</li>
<li>网状结构
<ul>
<li>数据通过各个中间节点逐一存储转发，实现数据“点对点”的传输</li>
<li>由众多路由器构建的广域网</li>
</ul>
</li>
</ul>
<h3 id="使用者"><a class="markdownIt-Anchor" href="#使用者"></a> 使用者</h3>
<ul>
<li>公用网
<ul>
<li>公开的网络，只要向<code>ISP</code>付钱即可</li>
</ul>
</li>
<li>专用网
<ul>
<li>内部使用网络，例如，国家总局、银行等的内网</li>
</ul>
</li>
</ul>
<hr />
<h2 id="计网性能指标"><a class="markdownIt-Anchor" href="#计网性能指标"></a> 计网性能指标</h2>
<ul>
<li>信道
<ul>
<li>即信息传输的通道，一般而言我们所说的<strong>通信线路</strong>往往对应着一个发送信道和一个接收信道</li>
</ul>
</li>
<li>速度相关
<ul>
<li>速率，连接在网络的节点的数据沿着信道传输的速率，也称作<strong>数据传输速率</strong>，单位一般为(<code>bps</code> <code>Kbps</code> <code>Mbps</code>)，这里的<code>K</code>是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">10^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>，与计算机组成不同</li>
<li>带宽
<ul>
<li>含义一，表示一个信道所能传输数据的最大速率，即<strong>最高数据率</strong>，可以有上行带宽和下行带宽</li>
<li>含义二，表示某个信道允许通过的信号频带范围，单位是<code>Hz</code>，两个含义其实有某些关系哦</li>
<li>节点间通信的最高速率由带宽和节点性能共同限制</li>
</ul>
</li>
<li>吞吐量
<ul>
<li>单位时间通过某个网络的实际数量，所以要计算上行和下行速率</li>
</ul>
</li>
</ul>
</li>
<li>时延相关
<ul>
<li>各种时延
<ul>
<li>发送时延(传输时延)
<ul>
<li>将数据全部传入信道的时间($ \frac{M_{数据大小}} {V_{数据传输速率}} $)</li>
</ul>
</li>
<li>传播时延
<ul>
<li>数据在信道上传输的时间($ \frac{L_{信道长度}} {V_{信号传播速率}} $)</li>
</ul>
</li>
<li>处理时延
<ul>
<li>路由器处理数据的时间(分析首部、查找存储转发表)</li>
</ul>
</li>
<li>排队时延
<ul>
<li>数据入队和出队花费的时间<br />
<img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CN_u1_7.jpg" alt="加油站时延示意图" /></li>
</ul>
</li>
</ul>
</li>
<li>时延带宽积
<ul>
<li>$ X_{时延带宽积} = T_{传播时延} \times M_{带宽} $</li>
</ul>
</li>
<li>往返时延(Round-Trip Time)
<ul>
<li>从发送方<strong>发送完数据</strong>，到发送方<strong>收到来自接收方的确认</strong>总共经历的时间</li>
<li>例如，游戏时延即“手机-服务器”的往返时延<code>RTT</code></li>
</ul>
</li>
</ul>
</li>
<li>信道利用率
<ul>
<li>$ \frac{T_{有数据通过}} {T_{有数据通过} + T_{没有数据通过}} $</li>
<li>信道利用率不能太低，会浪费资源</li>
<li>信道利用率不能太高，容易导致网络拥塞</li>
</ul>
</li>
</ul>
<hr />
<h2 id="计网分层"><a class="markdownIt-Anchor" href="#计网分层"></a> 计网分层</h2>
<ul>
<li>就如快递链一样，计算机网络中实现传递数据也是需要实现许许多多的功能，例如封装数据、校验数据、解析数据等等各种复杂的功能</li>
<li>这里给出一些完整功能，可以先尝试理解
<ul>
<li>差错控制：确保数据在传输过程中不会出错</li>
<li>流量控制：发送端发送数据的速率必须比接收端的接收速率小，来得及接收</li>
<li>分段与重装：发送端将要发送的数据分解为更小的单位，并且在接收端将其还原</li>
<li>复用与分用：发送端几个高层会话共同使用一条低层的连接，然后在接收端进行分用</li>
<li>连接建立与释放：交换数据前先建立一条逻辑连接，数据传输结束后释放</li>
</ul>
</li>
<li>采取分层的策略可以将问题分为各种小问题，以局部实现的策略实现</li>
</ul>
<h3 id="常见分层结构"><a class="markdownIt-Anchor" href="#常见分层结构"></a> 常见分层结构</h3>
<ul>
<li><code>OSI</code>模型
<ul>
<li>考虑的功能更加全面，会出现统一功能出现在多个层面</li>
<li>法律上的标准</li>
</ul>
<ol>
<li>物理层</li>
<li>数据链路层</li>
<li>网络层</li>
<li>传输层</li>
<li>会话层</li>
<li>表示层</li>
<li>应用层</li>
</ol>
</li>
<li><code>TCP/IP</code>模型
<ul>
<li>结构更加简单，同一功能只会出现在某一个层面</li>
<li>事实上的标准</li>
</ul>
<ol>
<li>网络接口层</li>
<li>网络层</li>
<li>传输层</li>
<li>应用层</li>
</ol>
</li>
<li>教学模型
<ol>
<li>物理层</li>
<li>数据链路层</li>
<li>网络层</li>
<li>传输层</li>
<li>应用层<br />
<img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CN_u1_8.png" alt="各模型示意图" /></li>
</ol>
</li>
<li><strong>实体</strong>
<ul>
<li>同处于某一层的活动元素(硬件与软件)被称为第<code>n</code>层的实体，不同节点上的同一层被称为<strong>对等层</strong>，同一层的对应实体被称为<strong>对等实体</strong></li>
</ul>
</li>
<li><strong>协议</strong>
<ul>
<li>对等实体的通信规则，约束了对等实体之间的数据传输的要求</li>
</ul>
</li>
<li><strong>接口</strong>
<ul>
<li>同一节点相邻两层的实体交换信息的逻辑通道，又称为<strong>服务访问点</strong>(Service Access Point，SAP)</li>
</ul>
</li>
<li><strong>服务</strong>
<ul>
<li>同一节点相邻两层中下层为上层提供的功能调用(这里层数小的在下，层数大的在上)</li>
</ul>
</li>
</ul>
<h3 id="数据传输过程"><a class="markdownIt-Anchor" href="#数据传输过程"></a> 数据传输过程</h3>
<ul>
<li>原始数据通过多层处理为物理信号传输，在通过多层反处理转换回数据<br />
<img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CN_u1_9.jpg" alt="数据传输示意图" /></li>
<li>数据定义
<ul>
<li>协议数据单元(Protocol Data Unit)
<ul>
<li>对等层之间传递的消息，第<code>n</code>层的协议数据单元写作<code>n-PDU</code></li>
</ul>
</li>
<li>服务数据单元(Service Data Unit)
<ul>
<li>为完成这一层实体而从上一层传入的数据，第<code>n</code>层的服务数据单元写作<code>n-SDU</code></li>
</ul>
</li>
<li>协议控制信息(Protocol Control Infomation)
<ul>
<li>控制协议操作的信息，第<code>n</code>层的协议控制信息写作<code>n-PCI</code></li>
</ul>
</li>
<li>三者之间的关系
<ul>
<li><code>n-PDU</code> = <code>n-PCI</code> + <code>n-SDU</code></li>
<li><code>n-SDU</code> = <code>n-1-PDU</code></li>
</ul>
</li>
</ul>
</li>
<li>协议定义
<ul>
<li>语法
<ul>
<li>数据与控制信息的格式。例如协议控制信息部分占几个字节、每个字节是什么含义、协议的数据部分最多有多少字节</li>
</ul>
</li>
<li>语义
<ul>
<li>需要发送何种控制信息，完成何种动作及作出何种应答，例如发送完数据后接收方是否需要“应答”，以及应答的种类(传输成功、传输失败)</li>
</ul>
</li>
<li>时序
<ul>
<li>执行各种操作的条件、时序关系等，即事件实现顺序的详细说明，例如发送方发送数据后接收方需要立即应答，如果发送方在 10 秒内没有应答，发送方会再次发送数据</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<h3 id="osi与tcpip"><a class="markdownIt-Anchor" href="#osi与tcpip"></a> <code>OSI</code>与<code>TCP/IP</code></h3>
<h4 id="osi模型详述"><a class="markdownIt-Anchor" href="#osi模型详述"></a> <code>OSI</code>模型详述</h4>
<ul>
<li>常见网络设备功能层次
<ul>
<li>主机：<code>#1 ~ #7</code></li>
<li>集线器：<code>#1</code></li>
<li>交换机：<code>#1 ~ #2</code></li>
<li>路由器：<code>#1 ~ #3</code></li>
<li>物理传输媒体：<code>#0</code></li>
</ul>
</li>
<li>各层详解
<ol>
<li>物理层
<ul>
<li>实现相邻节点<code>bit</code>传输</li>
<li>定义电路接口参数，形状、尺寸、引脚数等</li>
<li>定义传输信号含义，例如 5v 代表 1，1v 代表 0，每<code>bit</code>传输的持续时间为 0.1ms</li>
</ul>
</li>
<li>数据链路层
<ul>
<li>保证相邻节点间的链路<strong>逻辑上无差错</strong></li>
<li>原始数据传入链路层，链路层对长信息<strong>拆分并添加校验位</strong>组成**帧(Frame)**含有多个<code>bit</code>，再将帧陆续传给物理层转化为实际的物理信号传输</li>
<li><strong>差错控制</strong>：检错+纠错或者检错+丢弃+重传</li>
<li><strong>流量控制</strong>：协调相邻节点的帧的传输速率</li>
</ul>
</li>
<li>网络层
<ul>
<li>将分组<strong>从源结点转发至目的结点</strong></li>
<li><strong>路由选择</strong>：构造并且维护路由表，选择从源结点转向目的结点的最佳路径</li>
<li><strong>分组转发</strong>：将分组从合适的端口传出</li>
<li><strong>拥塞控制</strong>：发现网络拥塞，并采取措施缓解拥塞</li>
<li><strong>网际互联</strong>：由于各个局域网可能采用不同的技术，通过网络层实现异构网络的互联</li>
<li><strong>差错控制</strong>：校验分组</li>
<li><strong>流量控制</strong>：协调分组的传输速率</li>
<li><strong>连接建立与释放</strong>：建立虚电路发送分组</li>
<li><strong>可靠传输管理</strong>：接收方返回分组确认消息</li>
</ul>
</li>
<li>传输层
<ul>
<li>端到端的通信，即实现<strong>进程到进程</strong>的通信</li>
<li>多个不同进程的数据通过传输层组合成<strong>报文段</strong>(Segment)</li>
<li><strong>复用与分用</strong>：发送端的几个高层实体例如微信、QQ 的数据共同组成报文段，复用接下来低层的路线；在接收端将报文段重新拆分为多个端口的数据传入</li>
<li><strong>差错控制</strong>：校验报文段</li>
<li><strong>流量控制</strong>：协调报文段段的传输速率</li>
<li><strong>建立连接与释放</strong>：建立虚电路发送报文段</li>
<li><strong>可靠传输管理</strong>：接收方返回报文段确认消息</li>
</ul>
</li>
<li>会话层
<ul>
<li>管理进程间的会话</li>
<li><strong>会话管理</strong>：采用检查点机制，当通信失效时从检查点继续恢复通信</li>
</ul>
</li>
<li>表示层
<ul>
<li>解决不同主机上编码方式不同，数据格式转换还有压缩、解密等</li>
</ul>
</li>
<li>应用层
<ul>
<li>实现特定的网络应用</li>
<li>各类数据以<strong>报文</strong>(Message)为单位传递</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="tcpip模型详述"><a class="markdownIt-Anchor" href="#tcpip模型详述"></a> <code>TCP/IP</code>模型详述</h4>
<ul>
<li><code>OSI</code>与<code>TCP/IP</code>模型的区别
<ul>
<li><code>OSI.#5~#7</code>与<code>TCP/IP.#4</code>
<ul>
<li>数据编码格式转换与会话管理功能并不是对于每个网络应用都需要的，所以可以并入应用层</li>
<li>对于某些需要这种特定功能的应用，可以采用具有特定功能的协议去完成</li>
</ul>
</li>
<li><code>OSI.#1~#2</code>与<code>TCP/IP.#1</code>
<ul>
<li>网络层将分组传递给网络接口层，但是不硬性规定处理或者传输分组的方式</li>
</ul>
</li>
<li><code>OSI.#3</code>与<code>TCP/IP.#2</code>
<ul>
<li><code>TCP/IP</code>模型的网络层取消了对于分组检查与控制协调的若干功能，如差错控制、流量控制、连接管理、可靠传输管理</li>
<li><code>TCP/IP</code>模型的网络层的传输数据不可靠</li>
<li><code>TCP/IP</code>模型中不需要中间路由器等计算机网络核心管理流量等行为而将各种功能施加在端系统中</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>北航计算机组成P0课下</title>
    <url>/2024/09/24/CO_P0/</url>
    <content><![CDATA[<h1 id="北航计算机组成原理p0课下"><a class="markdownIt-Anchor" href="#北航计算机组成原理p0课下"></a> 北航计算机组成原理P0课下</h1>
<h3 id="p0课下做题的一些分享思路不一定是最佳实现思路敬请大家斧正"><a class="markdownIt-Anchor" href="#p0课下做题的一些分享思路不一定是最佳实现思路敬请大家斧正"></a> P0课下做题的一些分享，思路不一定是最佳实现思路，敬请大家斧正</h3>
<div class="note warning simple"><p>注意<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>i</mi><mi>s</mi><mi>i</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">logisim</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal">m</span></span></span></span>的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>p</mi><mi>p</mi><mi>e</mi><mi>a</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Appearance</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal">p</span><span class="mord mathnormal">p</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal">n</span><span class="mord mathnormal">c</span><span class="mord mathnormal">e</span></span></span></span>调整</p>
</div>
<h2 id="p0q1-crc校验码"><a class="markdownIt-Anchor" href="#p0q1-crc校验码"></a> P0.Q1 CRC校验码</h2>
<ul>
<li><s>读完了题目感觉题目和校验没什么关系</s><br />
教程已经有了明显的提示，使用<strong>4位模2运算电路</strong>拼出11位的模2除法运算电路，考虑到本题应该是一个组合电路题，所以笔者使用了类似行波进位器的电路
<ul>
<li>子电路定义如下(😭英语不好轻喷 )
<table>
<thead>
<tr>
<th style="text-align:center">定义接口</th>
<th style="text-align:center">方向</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">div[2:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:center">上一次<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>o</mi><mi>d</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">mod2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord">2</span></span></span></span>运算留下的余数</td>
</tr>
<tr>
<td style="text-align:center">new</td>
<td style="text-align:center">I</td>
<td style="text-align:center">本次<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>o</mi><mi>d</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">mod2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord">2</span></span></span></span>运算放在尾端的数</td>
</tr>
<tr>
<td style="text-align:center">todiv[3:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:center">除数</td>
</tr>
<tr>
<td style="text-align:center">hi[2:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:center">余数</td>
</tr>
<tr>
<td style="text-align:center">lo</td>
<td style="text-align:center">O</td>
<td style="text-align:center">商</td>
</tr>
</tbody>
</table>
</li>
<li>有八次<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>o</mi><mi>d</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">mod2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord">2</span></span></span></span>运算所以实现了八个子电路<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mn>8</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M_i ( 1 \le i \le 8)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">8</span><span class="mclose">)</span></span></span></span></li>
<li>利用<code>Splitter</code>分出后五位和三位零依次传入子电路中</li>
<li>连接$M_i.hi $ 与$ M_{i+1}.div<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>，就构成了行波</mtext></mrow><annotation encoding="application/x-tex">，就构成了行波</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">就</span><span class="mord cjk_fallback">构</span><span class="mord cjk_fallback">成</span><span class="mord cjk_fallback">了</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">波</span></span></span></span>mod2$运算电路(<br />
<img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/image-8.png" alt="alt text" /></li>
</ul>
</li>
<li>其实本来看到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>o</mi><mi>d</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">mod2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord">2</span></span></span></span>除法运算第一个想到的是循环移位，但是不知道能不能用时序，应该是不行吧</li>
<li>最后的最后，记得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>p</mi><mi>p</mi><mi>e</mi><mi>a</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Appearance</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal">p</span><span class="mord mathnormal">p</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal">n</span><span class="mord mathnormal">c</span><span class="mord mathnormal">e</span></span></span></span>，记得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>p</mi><mi>p</mi><mi>e</mi><mi>a</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Appearance</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal">p</span><span class="mord mathnormal">p</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal">n</span><span class="mord mathnormal">c</span><span class="mord mathnormal">e</span></span></span></span>，记得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>p</mi><mi>p</mi><mi>e</mi><mi>a</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Appearance</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal">p</span><span class="mord mathnormal">p</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal">n</span><span class="mord mathnormal">c</span><span class="mord mathnormal">e</span></span></span></span>，重要的事情说三遍</li>
</ul>
<hr />
<h2 id="p0q2-实现grf"><a class="markdownIt-Anchor" href="#p0q2-实现grf"></a> P0.Q2 实现GRF</h2>
<ul>
<li>
<p><s>啊，是寄存器堆，我们完了</s><br />
整体思路不难，输入数据使用32位<code>DMX</code>分配到各个寄存器，读出操作将寄存器堆连接32位<code>MUX</code>得到输出，最后的使能端口我使用了主的使能端<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">We</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal">e</span></span></span></span>和各个寄存器的使能端<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><msub><mi>e</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">We_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的综合<br />
<img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/image.png" alt="alt text" /></p>
</li>
<li>
<p><font color = red><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>t</mi><mi>t</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">Attention</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal">t</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span></span></span></span>: </font>对于特殊寄存器<code>$0</code>，我没有单独实现为一个寄存器，而是将写入<code>$0</code>的数据线置空，读取<code>$0</code>的数据线恒置为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span><br />
其实主要是搭建大量的寄存器和连接像上图的<code>Tunnel</code>容易导致莫名的连线问题，不过你<s>可以CV</s>，但是既然助教们在logisim教程中写了自动化教程肯定有他们的道理，所以我们用<code>Python</code>自动化脚本帮助我们生成<code>GRF</code>，<s>感觉没我CV快是怎么回事</s></p>
</li>
<li>
<p>接下来构建<code>Python</code>自动化脚本</p>
<ul>
<li>首先，既然要使用脚本生成大量的寄存器，我们就需要找到<code>GRF</code>的最小单位，不然怎么愉快的for循环呢，大概是下面这样<br />
<img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/image-2.png" alt="alt text" /></li>
<li>但是，我们观察logisim的电路文件，发现连线的操作很麻烦，是从一个坐标点导向另一个坐标点，坐标点嘛，如果写入脚本中，不仅会耗费大量时间记录需要连线的位置而且更易错，这违背了我们<s>图方便、省事</s>的初衷</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">wire</span> <span class="attr">from</span>=<span class="string">&quot;(340,890)&quot;</span> <span class="attr">to</span>=<span class="string">&quot;(430,890)&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">wire</span> <span class="attr">from</span>=<span class="string">&quot;(70,1050)&quot;</span> <span class="attr">to</span>=<span class="string">&quot;(100,1050)&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">wire</span> <span class="attr">from</span>=<span class="string">&quot;(70,1070)&quot;</span> <span class="attr">to</span>=<span class="string">&quot;(100,1070)&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">wire</span> <span class="attr">from</span>=<span class="string">&quot;(70,250)&quot;</span> <span class="attr">to</span>=<span class="string">&quot;(130,250)&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>所以我们对上述电路进行如下改造，丑是丑了点，但是<code>XML</code>格式十分简洁，反正logisim文件不是给人看的，机器看得明白就行<br />
<img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/image-1.png" alt="alt text" /></p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">comp</span> <span class="attr">lib</span>=<span class="string">&quot;4&quot;</span> <span class="attr">loc</span>=<span class="string">&quot;(500,320)&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Register&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;width&quot;</span> <span class="attr">val</span>=<span class="string">&quot;32&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;label&quot;</span> <span class="attr">val</span>=<span class="string">&quot;$18&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">comp</span> <span class="attr">lib</span>=<span class="string">&quot;0&quot;</span> <span class="attr">loc</span>=<span class="string">&quot;(330,340)&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Tunnel&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;label&quot;</span> <span class="attr">val</span>=<span class="string">&quot;clk&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">comp</span> <span class="attr">lib</span>=<span class="string">&quot;0&quot;</span> <span class="attr">loc</span>=<span class="string">&quot;(480,340)&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Tunnel&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;label&quot;</span> <span class="attr">val</span>=<span class="string">&quot;clk&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">comp</span> <span class="attr">lib</span>=<span class="string">&quot;0&quot;</span> <span class="attr">loc</span>=<span class="string">&quot;(320,395)&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Tunnel&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;facing&quot;</span> <span class="attr">val</span>=<span class="string">&quot;east&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;width&quot;</span> <span class="attr">val</span>=<span class="string">&quot;32&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;label&quot;</span> <span class="attr">val</span>=<span class="string">&quot;write_11&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">comp</span> <span class="attr">lib</span>=<span class="string">&quot;0&quot;</span> <span class="attr">loc</span>=<span class="string">&quot;(500,620)&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Tunnel&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;width&quot;</span> <span class="attr">val</span>=<span class="string">&quot;32&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;label&quot;</span> <span class="attr">val</span>=<span class="string">&quot;rd_22&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">comp</span> <span class="attr">lib</span>=<span class="string">&quot;0&quot;</span> <span class="attr">loc</span>=<span class="string">&quot;(180,565)&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Tunnel&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;label&quot;</span> <span class="attr">val</span>=<span class="string">&quot;clk&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">comp</span> <span class="attr">lib</span>=<span class="string">&quot;0&quot;</span> <span class="attr">loc</span>=<span class="string">&quot;(500,395)&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Tunnel&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;width&quot;</span> <span class="attr">val</span>=<span class="string">&quot;32&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;label&quot;</span> <span class="attr">val</span>=<span class="string">&quot;rd_19&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">comp</span> <span class="attr">lib</span>=<span class="string">&quot;0&quot;</span> <span class="attr">loc</span>=<span class="string">&quot;(630,640)&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Tunnel&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;label&quot;</span> <span class="attr">val</span>=<span class="string">&quot;clk&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>因为原电路已经略显复杂，接下来我单开了一个circuit搭建了一个最小单位，然后就能比较方便地找到这个基本单位了，接下来就是使用Python生成xml文件了，我使用的源码如下<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">grf = <span class="string">&quot;&quot;&quot;   &lt;comp lib=&quot;4&quot; loc=&quot;%s&quot; name=&quot;Register&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;a name=&quot;width&quot; val=&quot;32&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;a name=&quot;label&quot; val=&quot;%s&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/comp&gt;</span></span><br><span class="line"><span class="string">    &lt;comp lib=&quot;0&quot; loc=&quot;%s&quot; name=&quot;Tunnel&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;a name=&quot;width&quot; val=&quot;32&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;a name=&quot;label&quot; val=&quot;%s&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/comp&gt;</span></span><br><span class="line"><span class="string">    &lt;comp lib=&quot;0&quot; loc=&quot;%s&quot; name=&quot;Tunnel&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;a name=&quot;facing&quot; val=&quot;east&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;a name=&quot;label&quot; val=&quot;%s&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/comp&gt;</span></span><br><span class="line"><span class="string">    &lt;comp lib=&quot;0&quot; loc=&quot;%s&quot; name=&quot;Tunnel&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;a name=&quot;label&quot; val=&quot;rst&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/comp&gt;</span></span><br><span class="line"><span class="string">    &lt;comp lib=&quot;0&quot; loc=&quot;%s&quot; name=&quot;Tunnel&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;a name=&quot;label&quot; val=&quot;clk&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/comp&gt;</span></span><br><span class="line"><span class="string">    &lt;comp lib=&quot;0&quot; loc=&quot;%s&quot; name=&quot;Tunnel&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;a name=&quot;facing&quot; val=&quot;east&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;a name=&quot;width&quot; val=&quot;32&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;a name=&quot;label&quot; val=&quot;%s&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/comp&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">row = <span class="number">150</span></span><br><span class="line">col = <span class="number">75</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;grf.xml&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">            reg_loc = [<span class="number">200</span> + i * row, <span class="number">170</span> + j * col]</span><br><span class="line">            grf_name = <span class="string">f&quot;$<span class="subst">&#123;i * <span class="number">8</span> + j &#125;</span>&quot;</span></span><br><span class="line">            rd_name = <span class="string">f&quot;rd_<span class="subst">&#123;i * <span class="number">8</span> + j &#125;</span>&quot;</span></span><br><span class="line">            rd_loc = reg_loc</span><br><span class="line">            we_loc = [reg_loc[<span class="number">0</span>] - <span class="number">30</span>, reg_loc[<span class="number">1</span>] + <span class="number">10</span>]</span><br><span class="line">            we_name = <span class="string">f&quot;we_<span class="subst">&#123;i * <span class="number">8</span> + j &#125;</span>&quot;</span></span><br><span class="line">            rst_loc = [reg_loc[<span class="number">0</span>] - <span class="number">10</span>, reg_loc[<span class="number">1</span>] + <span class="number">20</span>]</span><br><span class="line">            clk_loc = [reg_loc[<span class="number">0</span>] - <span class="number">20</span>, reg_loc[<span class="number">1</span>] + <span class="number">20</span>]</span><br><span class="line">            wri_loc = [reg_loc[<span class="number">0</span>] - <span class="number">30</span>, reg_loc[<span class="number">1</span>]]</span><br><span class="line">            wri_name = <span class="string">f&quot;write_<span class="subst">&#123;i * <span class="number">8</span> + j &#125;</span>&quot;</span></span><br><span class="line">            <span class="comment"># print(grf % (tuple(reg_loc), grf_name, tuple(rd_loc), rd_name, tuple(we_loc), we_name,tuple(rst_loc), tuple(clk_loc), tuple(wri_loc), wri_name))</span></span><br><span class="line">            file.write(grf % (<span class="built_in">tuple</span>(reg_loc), grf_name, <span class="built_in">tuple</span>(rd_loc), rd_name, <span class="built_in">tuple</span>(we_loc), we_name,<span class="built_in">tuple</span>(rst_loc), <span class="built_in">tuple</span>(clk_loc), <span class="built_in">tuple</span>(wri_loc), wri_name))</span><br></pre></td></tr></table></figure>
<img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/image-4.png" alt="alt text" /><br />
(大概是这样，间距还可以调整，修改代码中的<code>row</code>和<code>col</code>值即可)<br />
<br><br />
<br></li>
<li>对于连接<code>MUX</code>与<code>DMX</code>我们如法炮制，新开一个文件存放最小单位，这里的最小单位其实是就是自己，只是连接的32个<code>Tunnel</code>还是有规律的<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">comp</span> <span class="attr">lib</span>=<span class="string">&quot;2&quot;</span> <span class="attr">loc</span>=<span class="string">&quot;(560,250)&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Demultiplexer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;select&quot;</span> <span class="attr">val</span>=<span class="string">&quot;5&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;width&quot;</span> <span class="attr">val</span>=<span class="string">&quot;32&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;enable&quot;</span> <span class="attr">val</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">comp</span> <span class="attr">lib</span>=<span class="string">&quot;0&quot;</span> <span class="attr">loc</span>=<span class="string">&quot;(520,10)&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Tunnel&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;label&quot;</span> <span class="attr">val</span>=<span class="string">&quot;write_1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">comp</span> <span class="attr">lib</span>=<span class="string">&quot;0&quot;</span> <span class="attr">loc</span>=<span class="string">&quot;(520,20)&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Tunnel&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;label&quot;</span> <span class="attr">val</span>=<span class="string">&quot;write_2&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>发现在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mn>250</mn></mrow><annotation encoding="application/x-tex">y=250</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord">0</span></span></span></span>位置的DMX的第一个接口时从0开始的，每两个接口之间是10个单位，就可以使用for循环生成这些<code>Tunnel</code>了，源码如下<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">mux_1 = <span class="string">&quot;&quot;&quot;    </span></span><br><span class="line"><span class="string">    &lt;comp lib=&quot;2&quot; loc=&quot;(250,250)&quot; name=&quot;Multiplexer&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;a name=&quot;select&quot; val=&quot;5&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;a name=&quot;width&quot; val=&quot;32&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;a name=&quot;enable&quot; val=&quot;false&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/comp&gt;&quot;&quot;&quot;</span></span><br><span class="line">mux_2 = <span class="string">&quot;&quot;&quot;     </span></span><br><span class="line"><span class="string">    &lt;comp lib=&quot;2&quot; loc=&quot;(430,250)&quot; name=&quot;Multiplexer&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;a name=&quot;select&quot; val=&quot;5&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;a name=&quot;width&quot; val=&quot;32&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;a name=&quot;enable&quot; val=&quot;false&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/comp&gt;&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">mux_loc = [(<span class="number">250</span>, <span class="number">250</span>), (<span class="number">430</span>, <span class="number">250</span>)]</span><br><span class="line">tunnel_rd = <span class="string">&quot;&quot;&quot;    </span></span><br><span class="line"><span class="string">    &lt;comp lib=&quot;0&quot; loc=&quot;%s&quot; name=&quot;Tunnel&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;a name=&quot;facing&quot; val=&quot;east&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;a name=&quot;width&quot; val=&quot;32&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;a name=&quot;label&quot; val=&quot;%s&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/comp&gt;&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">dmx = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &lt;comp lib=&quot;2&quot; loc=&quot;(560,250)&quot; name=&quot;Demultiplexer&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;a name=&quot;select&quot; val=&quot;5&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;a name=&quot;enable&quot; val=&quot;false&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/comp&gt;&quot;&quot;&quot;</span></span><br><span class="line">dmx_loc = (<span class="number">560</span>, <span class="number">250</span>)</span><br><span class="line"></span><br><span class="line">tunnel_wr = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &lt;comp lib=&quot;0&quot; loc=&quot;%s&quot; name=&quot;Tunnel&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;a name=&quot;label&quot; val=&quot;%s&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/comp&gt;&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;mux.xml&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    <span class="keyword">for</span> z <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">            tun_loc = [mux_loc[z][<span class="number">0</span>] - <span class="number">40</span>, <span class="number">90</span> + <span class="number">10</span> * i]</span><br><span class="line">            tun_name = <span class="string">f&quot;rd_<span class="subst">&#123;i&#125;</span>&quot;</span></span><br><span class="line">            <span class="built_in">print</span>(tunnel_rd % (<span class="built_in">tuple</span>(tun_loc), tun_name))</span><br><span class="line">            file.write(tunnel_rd % (<span class="built_in">tuple</span>(tun_loc), tun_name))</span><br><span class="line">    file.write(mux_1)</span><br><span class="line">    file.write(mux_2)</span><br><span class="line">    file.write(dmx)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">        tun_loc = [dmx_loc[<span class="number">0</span>] + <span class="number">40</span>, <span class="number">90</span> + <span class="number">10</span> * i]</span><br><span class="line">        tun_name = <span class="string">f&quot;we_<span class="subst">&#123;i&#125;</span>&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(tunnel_wr % (<span class="built_in">tuple</span>(tun_loc), tun_name))</span><br><span class="line">        file.write(tunnel_wr % (<span class="built_in">tuple</span>(tun_loc), tun_name))</span><br><span class="line">    <span class="comment"># 这里本来有一个写WD的write的for循环，图方便注释掉了</span></span><br><span class="line">    <span class="comment"># 只需要把tun_name自行调整即可，记得是DMX哦</span></span><br></pre></td></tr></table></figure>
<img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/image-9.png" alt="alt text" /></li>
</ul>
</li>
<li>
<p>这个题目好，P4写单周期的时候还能用</p>
</li>
<li>
<p><code>GRF</code>，巨能用，一节更比六节强，玩具车用完收音机还能用</p>
</li>
<li>
<p>最后的最后，记得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>p</mi><mi>p</mi><mi>e</mi><mi>a</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Appearance</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal">p</span><span class="mord mathnormal">p</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal">n</span><span class="mord mathnormal">c</span><span class="mord mathnormal">e</span></span></span></span>，记得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>p</mi><mi>p</mi><mi>e</mi><mi>a</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Appearance</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal">p</span><span class="mord mathnormal">p</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal">n</span><span class="mord mathnormal">c</span><span class="mord mathnormal">e</span></span></span></span>，记得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>p</mi><mi>p</mi><mi>e</mi><mi>a</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Appearance</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal">p</span><span class="mord mathnormal">p</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal">n</span><span class="mord mathnormal">c</span><span class="mord mathnormal">e</span></span></span></span>，重要的事情说三遍(你怎么知道我<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mi>r</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Pre</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span></span></span></span> 被<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>p</mi><mi>p</mi><mi>e</mi><mi>a</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Appearance</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal">p</span><span class="mord mathnormal">p</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal">n</span><span class="mord mathnormal">c</span><span class="mord mathnormal">e</span></span></span></span>卡到④了)</p>
</li>
</ul>
<hr />
<h2 id="p0q3-导航"><a class="markdownIt-Anchor" href="#p0q3-导航"></a> P0.Q3 导航</h2>
<ul>
<li>
<p><s>爵士好题</s></p>
</li>
<li>
<p>刚开始看到这道题本来打算用<code>Mealy</code>机，使用<code>Mealy</code>机真的很方便，因为<code>hit</code>和<code>arrive</code>都与<code>status</code>、<code>dir</code>有关，但是因为题目指定了<code>Moore</code>机所有很快就丢弃了这个思路</p>
</li>
<li>
<p>然后想到了创建多个状态包括撞墙的状态，然后写出复杂的状态转移方程，最后一共有13个状态吧，构建状态转移方程过于复杂，所以也丢弃了</p>
</li>
<li>
<p>最后我还是决定使用<code>Mealy</code>状态机和<code>Register</code>构建一个<code>Moore</code>状态机（假装输出只和状态相关）</p>
<ul>
<li><code>Register</code>保存<code>hit</code>的值，使得<code>hit</code>只在时钟上升沿变化，看起来就像是只随着<code>status</code>变化了（因为<code>status</code>是随着时钟上升沿变化的），而<code>arrive</code>本身就可以只与<code>status</code>有关，那么我们关于<code>status</code>的<code>Moore</code>机就构建好了</li>
</ul>
</li>
<li>
<p>状态转移的真值表如下</p>
<table>
<thead>
<tr>
<th style="text-align:center">status</th>
<th style="text-align:center">dir</th>
<th style="text-align:center">next_status</th>
<th style="text-align:center">arrive</th>
<th style="text-align:center">hit</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">000</td>
<td style="text-align:center">00</td>
<td style="text-align:center">001</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">000</td>
<td style="text-align:center">01</td>
<td style="text-align:center">000</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">000</td>
<td style="text-align:center">10</td>
<td style="text-align:center">000</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">000</td>
<td style="text-align:center">11</td>
<td style="text-align:center">000</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">001</td>
<td style="text-align:center">00</td>
<td style="text-align:center">011</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">001</td>
<td style="text-align:center">01</td>
<td style="text-align:center">010</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">001</td>
<td style="text-align:center">10</td>
<td style="text-align:center">000</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">001</td>
<td style="text-align:center">11</td>
<td style="text-align:center">001</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">010</td>
<td style="text-align:center">00</td>
<td style="text-align:center">100</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">010</td>
<td style="text-align:center">01</td>
<td style="text-align:center">010</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">010</td>
<td style="text-align:center">10</td>
<td style="text-align:center">010</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">010</td>
<td style="text-align:center">11</td>
<td style="text-align:center">001</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">011</td>
<td style="text-align:center">00</td>
<td style="text-align:center">011</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">011</td>
<td style="text-align:center">01</td>
<td style="text-align:center">100</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">011</td>
<td style="text-align:center">10</td>
<td style="text-align:center">001</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">011</td>
<td style="text-align:center">11</td>
<td style="text-align:center">011</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">100</td>
<td style="text-align:center">??</td>
<td style="text-align:center">000</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>主电路图大致如下<br />
<img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/image-5.png" alt="alt text" /></p>
</li>
<li>
<p>在群里看到向巨只用了两位的<code>type</code>，我也想了一下，下面是我的思路</p>
<ul>
<li>相较于原本的电路，将状态<code>100</code>即在B机房这个状态去除，改为在<code>S2</code>状态下 <code>dir</code>为<code>01</code>、<code>S3</code>状态下<code>dir</code>为<code>00</code>时，<code>arrive</code>置1，且返回A机房（<code>Mealy</code>状态机 + 寄存器）</li>
<li><code>arrive</code>模块也使用<code>Register</code>保存，在时钟上升沿更新</li>
<li>在A机房状态下，如果<code>arrive</code>为1，则总状态不更新，类似于同步复位信号，不过<code>status</code>这个时候已经是<code>00</code></li>
</ul>
</li>
<li>
<p>向巨，yyds</p>
</li>
</ul>
<hr />
<h2 id="p0q4-正则表达式"><a class="markdownIt-Anchor" href="#p0q4-正则表达式"></a> P0.Q4 正则表达式</h2>
<ul>
<li>
<p><s>欸，这道题没有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">Q3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">Q</span><span class="mord">3</span></span></span></span>难欸，怎么放在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mn>4</mn></mrow><annotation encoding="application/x-tex">Q4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">Q</span><span class="mord">4</span></span></span></span></s><br />
好了回归题目，这次的题目是一个<code>Mealy</code>类型的有限状态机，所以千万不要写错成了<code>Moore</code>类型的状态机啊</p>
</li>
<li>
<p>主要就是<code>Moore</code>状态机会比<code>Mealy</code>状态机多一个状态，因为<code>Moore</code>状态机保存了最后匹配成功的一个状态，<code>Mealy</code>状态机不需要保存匹配成功的状态，只需要在输入最后匹配条件时输出<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，并且回到非法状态即可</p>
</li>
<li>
<p><code>Mealy</code>状态机状态转移图<br />
<img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/image-12.png" alt="alt text" /></p>
</li>
<li>
<p><code>Moore</code>状态机状态转移图<br />
<img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/image-10.png" alt="alt text" /></p>
</li>
<li>
<p><code>Mealy</code>状态机状态转移方程</p>
<table>
<thead>
<tr>
<th style="text-align:center">status</th>
<th style="text-align:center">input</th>
<th style="text-align:center">next_status</th>
<th style="text-align:center">output</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">00</td>
<td style="text-align:center">00</td>
<td style="text-align:center">00</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">00</td>
<td style="text-align:center">01</td>
<td style="text-align:center">01</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">00</td>
<td style="text-align:center">10</td>
<td style="text-align:center">00</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">00</td>
<td style="text-align:center">11</td>
<td style="text-align:center">00</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">01</td>
<td style="text-align:center">00</td>
<td style="text-align:center">10</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">01</td>
<td style="text-align:center">01</td>
<td style="text-align:center">01</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">01</td>
<td style="text-align:center">10</td>
<td style="text-align:center">10</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">01</td>
<td style="text-align:center">11</td>
<td style="text-align:center">00</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">00</td>
<td style="text-align:center">00</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">01</td>
<td style="text-align:center">01</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">10</td>
<td style="text-align:center">00</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">11</td>
<td style="text-align:center">00</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
</li>
</ul>
<hr />
<h2 id="p0附加题-ftoi"><a class="markdownIt-Anchor" href="#p0附加题-ftoi"></a> P0.附加题 ftoi</h2>
<ul>
<li>
<p><s>半精度浮点数，所以不能用C语言编测试数据了，助教很坏</s></p>
</li>
<li>
<p>根据题目改编的IEEE浮点数，我们大致可以分为四类</p>
<ol>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>规格化小数</mtext></mrow><annotation encoding="application/x-tex">规格化小数</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">规</span><span class="mord cjk_fallback">格</span><span class="mord cjk_fallback">化</span><span class="mord cjk_fallback">小</span><span class="mord cjk_fallback">数</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>非规格化小数</mtext></mrow><annotation encoding="application/x-tex">非规格化小数</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">非</span><span class="mord cjk_fallback">规</span><span class="mord cjk_fallback">格</span><span class="mord cjk_fallback">化</span><span class="mord cjk_fallback">小</span><span class="mord cjk_fallback">数</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord">∞</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>A</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">NAN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></li>
</ol>
</li>
<li>
<p>浮点数的类型又可以由下面三个bool型变量决定</p>
<ol>
<li><code>exp_iszero</code></li>
<li><code>exp_isfull</code></li>
<li><code>frac_iszero</code></li>
</ol>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>A</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">NAN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord">∞</span></span></span></span>只有<code>frac_iszero</code>不一致，又因为刚好有5个类型，所以干脆将这两个类型合并为一个，然后使用真值表技术生成两位<code>type</code>关于三个变量的子电路</p>
<table>
<thead>
<tr>
<th style="text-align:center">定义接口</th>
<th style="text-align:center">方向</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">exp_iszero</td>
<td style="text-align:center">I</td>
<td style="text-align:center">所得浮点数exponent位置是否全为0</td>
</tr>
<tr>
<td style="text-align:center">exp_isfull</td>
<td style="text-align:center">I</td>
<td style="text-align:center">所得浮点数exponent位置是否全为1</td>
</tr>
<tr>
<td style="text-align:center">frac_iszero</td>
<td style="text-align:center">I</td>
<td style="text-align:center">所得浮点数fraction位置是否全为0</td>
</tr>
<tr>
<td style="text-align:center">type[1:0]</td>
<td style="text-align:center">O</td>
<td style="text-align:center">浮点数属于的类型</td>
</tr>
</tbody>
</table>
<ul>
<li>状态转移真值表如下
<table>
<thead>
<tr>
<th style="text-align:center">exp_iszero</th>
<th style="text-align:center">exp_isfull</th>
<th style="text-align:center">frac_iszero</th>
<th style="text-align:center">type</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">00</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">01</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">10</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">?</td>
<td style="text-align:center">11</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li>
<p>后两个类型的输出都是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>,前两个类型的唯一区别是<code>frac</code>定点数的小数点前是否有默认的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，所以先讲述而这在实现上的共性</p>
<ul>
<li>通过<code>exponent</code>的值和<code>bias</code>的值算出真正需要的位移值<code>shift</code>(补码编码)，这里使用加法电路实现减法电路不用考虑溢出，这得益于移码中<code>bias</code>选择(一般是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><mi>e</mi><mi>x</mi><msub><mi>p</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor exp_{max} /2 \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord">2</span><span class="mclose">⌋</span></span></span></span>)</li>
<li>如果<code>shift</code>是负数，则直接输出<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>即可，因为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>&lt;</mo><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mo>&lt;</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">0 \lt frac \lt 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>，所以至多右移<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>位就直接为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></li>
<li>我通过<code>shift</code>与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>比较直接决定左移还是右移，好处是不需要考虑先左移<code>shift</code>再右移<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>可能导致的高位<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>损失，坏处是又要写两个减法电路（，然后再<code>MUX</code>选择结果</li>
<li>根据<code>sign</code>符号位决定是否<code>取反加1</code>，同样不需要考虑溢出</li>
</ul>
</li>
<li>
<p>接下来分别说明两次可以忽略溢出的原因（<s>有点废话的证明</s>）</p>
<ul>
<li>对于第一个算的<code>shift</code>(补码编码)，主要原因是非符号数的减法电路和符号数的减法电路实际是一套电路，而且<code>bias</code>设置的好，如果<code>exponent</code>的首位是0，我们理解为补码的减法电路，正数减去正数不会溢出，得到的答案（补码是正确的），如果<code>exponent</code>的首位是1，因为<code>bias</code>设置的合理，只有<code>11111</code>的情况会无法得到正数，但是这种情况已经被排除了（因为其他的<code>type</code>使用了），所以得到的补码也是正确的（正数的编码是自己）</li>
<li>第二个负数取补码的情况时，为什么不需要考虑可能已经溢出到32位外的值，取完补码再取后32位，而是直接不考虑开始时的溢出，这和一个小结论有关，对于一个正数取其相反数的补码可以这样做：从这个正数最低位的1开始，到最高位为止中间的所有数字取反，假设1全部溢出在32位外，则后32位始终保持0，假设后32位中有1，根据结论无论考不考虑溢出部分后32位的值都应该一致的<br />
<img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/image-6.png" alt="alt text" /></li>
</ul>
</li>
</ul>
<hr />
<h2 id="p0推荐题目"><a class="markdownIt-Anchor" href="#p0推荐题目"></a> P0.推荐题目</h2>
<p>好，但是现在还没出</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
        <category>课下复习</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>北航计算机组成P1推荐题汇总</title>
    <url>/2024/09/30/CO_P1_extra/</url>
    <content><![CDATA[<h1 id="北航计算机组成p1推荐题目汇总"><a class="markdownIt-Anchor" href="#北航计算机组成p1推荐题目汇总"></a> 北航计算机组成P1推荐题目汇总</h1>
<h2 id="题目怎么来的"><a class="markdownIt-Anchor" href="#题目怎么来的"></a> 题目怎么来的</h2>
<ul>
<li><s>偷来的(搓手手</s></li>
<li>如果你看了一下推荐题目的<code>URL</code>的话，你会发现<code>cscore</code>简直是天生为<s>爬虫而生的</s>，甚至参数都已经写在<code>URL</code>里面了，这不是勾引是什么？<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://cscore.buaa.edu.cn/#/problem?ProblemId=334&amp;PieId=1202</span><br></pre></td></tr></table></figure>
</li>
<li><code>PieId</code>
<ul>
<li>似乎是每个P的编号，每年的都不一样，2306的<code>1202</code>代表推荐题目，其他的大都爬不到(悲</li>
</ul>
</li>
<li><code>ProblemId</code>
<ul>
<li>下辖的题目编号，额，毫无规律可言，建议遍历爬取</li>
<li>但是似乎每年相同模块（例如推荐题目）的相同题目编号都有题目（未经</li>
</ul>
</li>
<li>以及题目按照难度依次上升（笔者认为的，毫无参考价值（bushi ）<br />
<a href="https://github.com/Kie-Chi/cscore_crawl.git">源码获取</a></li>
</ul>
<hr />
<h2 id="组合电路"><a class="markdownIt-Anchor" href="#组合电路"></a> 组合电路</h2>
<ul>
<li>过于简单，仅有提示</li>
</ul>
<h3 id="1202-405-floattype"><a class="markdownIt-Anchor" href="#1202-405-floattype"></a> 1202-405 FloatType</h3>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> FloatType(</span><br><span class="line">    <span class="keyword">input</span>[<span class="number">31</span>: <span class="number">0</span>] num,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span>[<span class="number">4</span>: <span class="number">0</span>] float_type</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义状态</span></span><br><span class="line">    <span class="keyword">parameter</span> zero = <span class="number">5&#x27;b1</span>;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">7</span>: <span class="number">0</span>] exponent;</span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">22</span>: <span class="number">0</span>] fraction;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        exponent = num[<span class="number">30</span>: <span class="number">23</span>];</span><br><span class="line">        fraction = num[<span class="number">22</span>: <span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算次态</span></span><br><span class="line">        <span class="keyword">if</span> (exponent == <span class="number">8&#x27;b0</span> &amp;&amp; fraction == <span class="number">23&#x27;b0</span>) <span class="keyword">begin</span></span><br><span class="line">            float_type = zero;</span><br><span class="line">        ....</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="1202-202-comparator"><a class="markdownIt-Anchor" href="#1202-202-comparator"></a> 1202-202 Comparator</h3>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">cin = <span class="number">1&#x27;b1</span>;</span><br><span class="line"></span><br><span class="line">cout = (A[<span class="number">0</span>] &amp; ~B[<span class="number">0</span>]) | (cin &amp; (A[<span class="number">0</span>] ^ ~B[<span class="number">0</span>]));</span><br><span class="line">cin = cout;                </span><br><span class="line"></span><br><span class="line">cout = (A[<span class="number">1</span>] &amp; ~B[<span class="number">1</span>]) | (cin &amp; (A[<span class="number">1</span>] ^ ~B[<span class="number">1</span>]));</span><br><span class="line">cin = cout;    </span><br><span class="line"></span><br><span class="line">cout = (A[<span class="number">2</span>] &amp; ~B[<span class="number">2</span>]) | (cin &amp; (A[<span class="number">2</span>] ^ ~B[<span class="number">2</span>]));</span><br><span class="line">cin = cout;    </span><br><span class="line"></span><br><span class="line">S = A[<span class="number">3</span>] ^ ~B[<span class="number">3</span>] ^ cin;</span><br><span class="line">cout = (A[<span class="number">3</span>] &amp; ~B[<span class="number">3</span>]) | (cin &amp; (A[<span class="number">3</span>] ^ ~B[<span class="number">3</span>]));</span><br><span class="line">cin = cout;    </span><br><span class="line"></span><br><span class="line">Out = S;</span><br></pre></td></tr></table></figure>
<ul>
<li>核心就是一个四位的行波全加器，为了实现减法电路</li>
</ul>
<h3 id="1202-424-voter"><a class="markdownIt-Anchor" href="#1202-424-voter"></a> 1202-424 Voter</h3>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> VoterPlus(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> reset,</span><br><span class="line">    <span class="keyword">input</span>[<span class="number">31</span>: <span class="number">0</span>] np,</span><br><span class="line">    <span class="keyword">input</span>[<span class="number">7</span>: <span class="number">0</span>] vip,</span><br><span class="line">    <span class="keyword">input</span> vvip,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span>[<span class="number">7</span>: <span class="number">0</span>] result</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">31</span>: <span class="number">0</span>] np_vote, next_np_vote;</span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">7</span>: <span class="number">0</span>] vip_vote, next_vip_vote;</span><br><span class="line">    <span class="keyword">reg</span> vvip_vote, next_vvip_vote;</span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">7</span>: <span class="number">0</span>] next_result;</span><br><span class="line">    <span class="keyword">integer</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> reset) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (reset) <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">//复位</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">//状态转移</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">//默认复位，注意题意要求</span></span><br><span class="line">        next_np_vote = np_vote | np;</span><br><span class="line">        next_vip_vote = vip_vote | vip;</span><br><span class="line">        next_vvip_vote = vvip_vote | vvip;</span><br><span class="line"></span><br><span class="line">        next_result = <span class="number">8&#x27;b0</span>;</span><br><span class="line">        <span class="comment">//计算次态，使用for循环</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="1202-102-alu"><a class="markdownIt-Anchor" href="#1202-102-alu"></a> 1202-102 ALU</h3>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> alu(</span><br><span class="line">    <span class="keyword">input</span>[<span class="number">31</span>: <span class="number">0</span>] A,</span><br><span class="line">    <span class="keyword">input</span>[<span class="number">31</span>: <span class="number">0</span>] B,</span><br><span class="line">    <span class="keyword">input</span>[<span class="number">2</span>: <span class="number">0</span>] ALUOp,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span>[<span class="number">31</span>: <span class="number">0</span>] C</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义状态</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">32</span>: <span class="number">0</span>] ext_a, ext_b;</span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">32</span>: <span class="number">0</span>] sum;</span><br><span class="line">    <span class="keyword">reg</span> cout;</span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span> (ALUOp)</span><br><span class="line">            sgtu: <span class="keyword">begin</span></span><br><span class="line">                ext_a = &#123;<span class="number">0</span>, A&#125;;</span><br><span class="line">                ext_b = &#123;<span class="number">0</span>, B&#125;;</span><br><span class="line">                ext_a = ~ext_a;</span><br><span class="line">                </span><br><span class="line">                sum = ext_a + ext_b + <span class="number">1</span>;</span><br><span class="line">                C = sum[<span class="number">32</span>];</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            sgt: <span class="keyword">begin</span></span><br><span class="line">                ext_a = &#123;A[<span class="number">31</span>], A&#125;;</span><br><span class="line">                ext_b = &#123;B[<span class="number">31</span>], B&#125;;</span><br><span class="line">                ext_a = ~ext_a;</span><br><span class="line">                sum = ext_a + ext_b + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                C = sum[<span class="number">32</span>];</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">                C = <span class="number">32&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li>注意使用拓展位的减法电路实现比较即可</li>
</ul>
<hr />
<h2 id="有限状态机"><a class="markdownIt-Anchor" href="#有限状态机"></a> 有限状态机</h2>
<h3 id="1202-334-drink"><a class="markdownIt-Anchor" href="#1202-334-drink"></a> 1202-334 Drink</h3>
<ul>
<li><s>为什么我航的售卖机没有一键退币功能，大一被坑了多少饮料</s></li>
<li>本题似乎是一个<code>Moore</code>型优先状态机的问题，但是我决定使用我的新结构，所以我们使用<code>Mealy</code>机＋<code>Register</code>的方式解决输出不与状态同步的问题</li>
<li>四个状态还是很好想的，<code>售货机没吞钱</code> <code>售货机吞0.5元</code> <code>售货机吞1元</code> <code>售货机吞1.5元</code>，然后就是状态转移方程了<br />
<img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/p1_drink.png" alt="alt-text" /></li>
<li>提供一个我使用的新结构框架（<s>应该没有泄露源码之嫌</s>）<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> drink(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> reset,</span><br><span class="line">    <span class="keyword">input</span>[<span class="number">1</span>: <span class="number">0</span>] coin,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> drink,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span>[<span class="number">1</span>: <span class="number">0</span>] back</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义状态</span></span><br><span class="line">    <span class="keyword">parameter</span> s0 = <span class="number">2&#x27;b0</span>;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义寄存器变量</span></span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">1</span>: <span class="number">0</span>] state, next_state; </span><br><span class="line">    <span class="keyword">reg</span> next_drink;</span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">1</span>: <span class="number">0</span>] next_back;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> reset) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (reset) <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">//复位</span></span><br><span class="line">            ......</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">//状态转移</span></span><br><span class="line">            state &lt;= next_state;</span><br><span class="line">            back &lt;= next_back;</span><br><span class="line">            drink &lt;= next_drink;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">//默认赋值</span></span><br><span class="line">        next_back = <span class="number">2&#x27;b0</span>;</span><br><span class="line">        next_drink = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        next_state = state;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> (state)</span><br><span class="line">            s0: <span class="keyword">begin</span></span><br><span class="line">                <span class="comment">//状态转移</span></span><br><span class="line">                ......</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">                <span class="comment">//......</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1202-145-string"><a class="markdownIt-Anchor" href="#1202-145-string"></a> 1202-145 String</h3>
<ul>
<li>其实本质是课下题的升级版，对于左括号进行记录即可</li>
<li>多重括号的辨别使用一个变量寄存左括号数量即可
<ul>
<li>string状态没有分开，看起来有一点乱<br />
<img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/P1_string2.png" alt="状态转移图" /></li>
<li>将带有左括号未匹配时单独分出状态，这样大概不会显得乱吧<br />
<img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/P1_string.png" alt="wty赞助" /></li>
</ul>
</li>
</ul>
<h3 id="1202-336-intcheck"><a class="markdownIt-Anchor" href="#1202-336-intcheck"></a> 1202-336 IntCheck</h3>
<ul>
<li>第一，读到<code>;</code>语句才截止，所以要考虑每个状态遇到<code>;</code>的情况</li>
<li>第二，多个标识符可以复用状态，详情请看下面状态转移图</li>
<li>第三，不要在小情侣后面码代码<br />
<img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/P1_int.svg" alt="复杂图" /></li>
</ul>
<a class="btn-beautify " href="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/P1_int.svg" 
  title="查看原图"><span>查看原图</span></a>]]></content>
      <categories>
        <category>计算机组成原理</category>
        <category>推荐题目</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>北航计算机组成P2推荐题汇总</title>
    <url>/2024/10/09/CO_P2_extra/</url>
    <content><![CDATA[<h1 id="北航计算机组成p2推荐题目汇总"><a class="markdownIt-Anchor" href="#北航计算机组成p2推荐题目汇总"></a> 北航计算机组成P2推荐题目汇总</h1>
<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<ul>
<li>题目怎么来的就不再赘述，有感兴趣的同学可以走这里 <a href="/2024/09/30/CO_P1_extra/" title="北航计算机组成P1推荐题汇总">北航计算机组成P1推荐题汇总</a></li>
</ul>
<h2 id="p2推荐题目汇总"><a class="markdownIt-Anchor" href="#p2推荐题目汇总"></a> P2推荐题目汇总</h2>
<h3 id="1202-35-calculate"><a class="markdownIt-Anchor" href="#1202-35-calculate"></a> 1202-35 calculate</h3>
<ul>
<li>注意题目要求的是按照<strong>输入的顺序</strong>输出计数的字符，不是按照<code>ascii</code>码表的位置</li>
<li>我开了两个数组一个记录26个字母的数量，一个记录出现的顺序(<strong>重复出现的字母不会进行第二遍</strong>)，最后遍历记录出现顺序的数组即可</li>
<li>还有一个小小的点：因为样例看起来是一行读入一个字符，实际测评机是一个接一个的字符读入，所以不需要处理<code>\n</code>(我刚开始就处理了，导致报了一个非法读入的错误)  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.macro read_chr(%chr)</span><br><span class="line">    li $v0, 12</span><br><span class="line">    syscall</span><br><span class="line">    move %chr, $v0</span><br><span class="line"></span><br><span class="line">    # 不需要处理字母后面的\n</span><br><span class="line">    # li $v0, 12</span><br><span class="line">    # syscall</span><br><span class="line">.end_macro</span><br></pre></td></tr></table></figure>
</li>
<li>提供一个有处理是否有重复输入的代码块<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> .text</span><br><span class="line">	for_z_begin: # 用于判断是否出现过这个字符</span><br><span class="line">		beq $t2, $s1, for_z_end # 对目前出现的所有字符遍历 </span><br><span class="line">		sll $t3, $t2, 2 </span><br><span class="line">		lw $t4, buffer($t3) # 读出第$t2个已有字符</span><br><span class="line">		sub $t4, $t4, $t1 # 判断是否为同一个字符</span><br><span class="line">		if_begin_1:</span><br><span class="line">			bne $t4, $zero, if_end_1 # 如果不是则跳转</span><br><span class="line">			j not_for_z_end # 如果是则直接结束这段内容</span><br><span class="line">		if_end_1:</span><br><span class="line">		addi $t2, $t2, 1</span><br><span class="line">		j for_z_begin</span><br><span class="line">	for_z_end:</span><br><span class="line">		sll $t3, $t2, 2 # 存入新读入的字符</span><br><span class="line">		sw $t1, buffer($t3)</span><br><span class="line">		addi $s1, $s1, 1</span><br><span class="line">	not_for_z_end:</span><br><span class="line">	</span><br><span class="line">	sll $t1, $t1, 2 # 找到指定字母的偏移字节</span><br><span class="line">	</span><br><span class="line">	lw $t2, num($t1)</span><br><span class="line">	addi $t2, $t2, 1 # 找到的字母加1</span><br><span class="line">	sw $t2, num($t1)</span><br><span class="line">	</span><br><span class="line">	addi $t0, $t0, 1 # 循环继续条件</span><br><span class="line">	j for_i_begin</span><br><span class="line">for_i_end:</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1202-52-add"><a class="markdownIt-Anchor" href="#1202-52-add"></a> 1202-52 add</h3>
<ul>
<li>看上去有点麻烦而已，其实完全可以使用一个矩阵接收两次数字完成两次加法(因为所有内存起始值赋值为0)</li>
<li>最后的转置也只是需要将原来的嵌套<code>for</code>循环中的<strong>先<code>row</code>后<code>col</code></strong> 改为 **先<code>col</code>后<code>row</code>**就可以了</li>
<li>同样提供一个有大致思路的<code>main</code>模块<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> .text</span><br><span class="line">read_in($s0) # 读入n</span><br><span class="line">read_in($s1) # 读入m</span><br><span class="line"></span><br><span class="line">li $s2, 2 # 直接设置读入两次</span><br><span class="line">li $t0, 0 # 设置循环变量i</span><br><span class="line"># 双重for循环读入</span><br><span class="line"></span><br><span class="line">print_str(hint) # 打印题目要求的hint信息</span><br><span class="line"># 双重for循环打印</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1202-53-full_reserved"><a class="markdownIt-Anchor" href="#1202-53-full_reserved"></a> 1202-53 full_reserved</h3>
<ul>
<li>对于全排列问题(顺序)，可以考虑下面的思路(只想看汇编内容可以跳过，这里主要讲的是全排列是如何写的)
<ul>
<li>我们以<code>1234</code>四个数字举例，开头为<code>1</code>和<code>2</code>的情况</li>
<li><code>1</code>:<code>1234 1243 1324 1342 1423 1432</code></li>
<li><code>2</code>:<code>2134 2143 2314 2341 2413 2431</code></li>
<li>可以发现，以某个数字开头的全排列其实是 以<strong>这个数字开头</strong>加上<strong>剩下所有数字按相对大小重新构成的数字队列</strong>的全排列</li>
<li>例如<code>1</code>与<code>234</code>的全排列构成<code>1234</code>以<code>1</code>开头的全排列;<code>2</code>与<code>134</code>的全排列构成了<code>1234</code>以<code>2</code>开头的全排列，所以就可以写递归程序了(雾)</li>
<li>所以所给递归程序的<code>symbol</code>全局数组是用来记录这个<strong>开头的数字</strong></li>
</ul>
</li>
<li>题目要求你改写<strong>逆序</strong>的全排列汇编程序
<ul>
<li>最方便的思路就是打印的时候不打印<code>array[i]</code>而打印<code>n+1-array[i]</code>这样相当于用<code>n....1</code>来全排列</li>
<li>当然，如果你理解了这个C语言程序如何运作的，可以将<code>for</code>循环的顺序反过来，从最高位<code>n</code>来开始，思路同上面的讲解思路</li>
</ul>
</li>
<li>仔细考虑入栈出栈情况，如果使用栈传递参数记得开始时就要先出栈，<code>$ra</code>的保留值在任何一个程序的返回点都要弹出，总之<strong>入栈则一定要出栈</strong>(虽然有点像废话，但某些地方真的必须考虑清楚)，切记</li>
<li>给出一个可以参考的<code>FullArray</code>函数的模板<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">full_array:</span><br><span class="line">    addi $sp, $sp, -8 # 给出一定的栈空间</span><br><span class="line">    sw $a0, 4($sp) # 压栈</span><br><span class="line">    sw $ra 0($sp) </span><br><span class="line">    move $t0, $a0 # t0代表index</span><br><span class="line">    if_begin:</span><br><span class="line">        sltu $t2, $t0, $s0 # 判断index与n的大小</span><br><span class="line">        bne $t2, $zero, if_end</span><br><span class="line">        </span><br><span class="line">        li $t1, 0 # 设置循环变量i</span><br><span class="line">        for_i_begin:</span><br><span class="line">            beq $t1, $s0, for_i_end </span><br><span class="line">            sll $t2, $t1, 2 </span><br><span class="line">            lw $t3, array($t2) # 得到array[i]</span><br><span class="line">            sub $t3, $zero, $t3</span><br><span class="line">            addi $t4, $s0, 1</span><br><span class="line">            add $t3, $t3, $t4 # 得到n+1-array[i]</span><br><span class="line">            print_int($t3) # 打印这个值</span><br><span class="line">            print_str(space) # 打印空格</span><br><span class="line">            addi $t1, $t1, 1 # 循环i继续条件</span><br><span class="line">            j for_i_begin</span><br><span class="line">        for_i_end:</span><br><span class="line">        print_str(enter) # 打印换行</span><br><span class="line">        add $sp, $sp ,8 # 注意出栈，这里可以不用弹出值，但是一定要栈空间减少</span><br><span class="line">        jr $ra # 返回</span><br><span class="line">    if_end:</span><br><span class="line">        </span><br><span class="line">    # else执行的for循环递归</span><br><span class="line">    addi $sp, $sp, 8 # 将刚开始保留的参数弹出</span><br><span class="line">    lw $a0, -4($sp)</span><br><span class="line">    lw $ra -8($sp)	</span><br><span class="line">    </span><br><span class="line">    jr $ra # 返回</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1202-329-sum"><a class="markdownIt-Anchor" href="#1202-329-sum"></a> 1202-329 sum</h3>
<ul>
<li>大概就是一个变量保留 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">n</span><span class="mclose">!</span></span></span></span> 的值，一个变量保留 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mi>i</mi><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">\sum\limits_{i=1}^n i!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.329066em;vertical-align:-0.9776689999999999em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3513970000000004em;"><span style="top:-2.122331em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0000050000000003em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∑</span></span></span><span style="top:-3.950005em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9776689999999999em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">i</span><span class="mclose">!</span></span></span></span>，然后进行递推就可以了，千万不要递归啊(雾，大概率会爆吧</li>
<li>提供一个可参考的<code>main</code>模板<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main:</span><br><span class="line">    read($s0)</span><br><span class="line">    li $s1, 0</span><br><span class="line">    li $s2, 1</span><br><span class="line">    li $t0, 1</span><br><span class="line">    li $s3, 1</span><br><span class="line">    for_start:</span><br><span class="line">        sltu $s3, $s0, $t0</span><br><span class="line">        bne $s3, $zero, for_end</span><br><span class="line">        multu $t0, $s2</span><br><span class="line">        mflo $s2</span><br><span class="line">        addu $s1, $s1, $s2</span><br><span class="line">        addi $t0, $t0, 1</span><br><span class="line">        j for_start</span><br><span class="line">    for_end:</span><br><span class="line">        printU($s1)</span><br><span class="line">        done</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1202-330-hanoi"><a class="markdownIt-Anchor" href="#1202-330-hanoi"></a> 1202-330 hanoi</h3>
<ul>
<li>诶呀，<s>是大一写的递归程序呢</s></li>
<li>不论是C语言代码的理解和整体程序都没有难点，所以注意的只有压栈弹栈时候小心即可！</li>
<li>因为函数参数过多，所以我采用了用栈传输参数的思路，所以要更加小心，哪些部分是保存参数、弹出参数，哪些部分是传递参数、接收参数</li>
<li>本题给出了关于模板字符串的提示，虽然没法用占位符<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">format_str: .asciiz &quot;move disk D from C to C\n&quot;</span><br><span class="line">.macro print(%disk, %from, %to)</span><br><span class="line">    li $t7, 10</span><br><span class="line">    addi $t6, %disk, 48</span><br><span class="line">    sb $t6, format_str($t7)</span><br><span class="line">    </span><br><span class="line">    li $t7, 17</span><br><span class="line">    sb %from, format_str($t7)</span><br><span class="line">    </span><br><span class="line">    li $t7, 22</span><br><span class="line">    sb %to, format_str($t7)</span><br><span class="line">    </span><br><span class="line">    la $a0, format_str</span><br><span class="line">    li $v0, 4</span><br><span class="line">    syscall</span><br><span class="line">.end_macro</span><br></pre></td></tr></table></figure>
</li>
<li>同样，给出参考的模板<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main:</span><br><span class="line">    read_in($t0) # 读入n</span><br><span class="line">    li $t1, 65</span><br><span class="line">    li $t2, 66</span><br><span class="line">    li $t3, 67</span><br><span class="line">    la $sp, stack</span><br><span class="line">    addi $sp, $sp, 800 # 初始化参数与stack</span><br><span class="line">    </span><br><span class="line">    push($t0) # 传参数</span><br><span class="line">    ...</span><br><span class="line">    jal hanoi</span><br><span class="line">    </span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">hanoi:</span><br><span class="line">    pop($t3) # 接收参数</span><br><span class="line">    ...</span><br><span class="line">    push($ra) # 保存返回值</span><br><span class="line">    if_begin:</span><br><span class="line">        bne $t0, $zero, if_end</span><br><span class="line">        print($t0, $t1, $t2)</span><br><span class="line">        print($t0, $t2, $t3)</span><br><span class="line">        pop($ra) # 弹返回地址</span><br><span class="line">        jr $ra</span><br><span class="line">    if_end:</span><br><span class="line">    </span><br><span class="line">    push($t0) # 保存参数</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    addi $t0, $t0, -1</span><br><span class="line">    push($t0) # 传递参数</span><br><span class="line">    ...</span><br><span class="line">    jal hanoi</span><br><span class="line">    </span><br><span class="line">    pop($t3) # 取出保留的参数</span><br><span class="line">    ...</span><br><span class="line">    print($t0, $t1, $t2)</span><br><span class="line">    </span><br><span class="line">    ...若干递归</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1202-415-bsearch"><a class="markdownIt-Anchor" href="#1202-415-bsearch"></a> 1202-415 bsearch</h3>
<ul>
<li>二分查找！！！</li>
<li>因为已经给出了C语言参考模板了，没有的话或许有同学会因为不清楚<code>[low,high]</code>还是<code>[low,high)</code>两种查找方式的区别，而写出一些小bug</li>
<li>注意<code>slt</code>与<code>sltu</code>因为如果查找的<code>key</code>比数组中最小的值还要小的话，那么最后得到的值是-1，但是-1在无符号数中是最大的，会出现死循环哦</li>
<li>直接给出可参考的模板了<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">binary_search:</span><br><span class="line">    push($s1)</span><br><span class="line">    move $s1, $a0 # key</span><br><span class="line">    li $t0, 0 # low</span><br><span class="line">    addi $t1, $s0, -1 # high</span><br><span class="line">    li $t2, 0 # mid</span><br><span class="line">    </span><br><span class="line">    while_begin:</span><br><span class="line">        slt $t5, $t1, $t0</span><br><span class="line">        bne $t5, $zero, while_end</span><br><span class="line">        </span><br><span class="line">        add $t2, $t0, $t1</span><br><span class="line">        srl $t2, $t2, 1</span><br><span class="line">        </span><br><span class="line">        //判断arr[mid]与key的大小</span><br><span class="line">        j while_begin</span><br><span class="line">    while_end:</span><br><span class="line"></span><br><span class="line">    li $t5, 0</span><br><span class="line">    print($t5)</span><br><span class="line">    pop($s1)</span><br><span class="line">    jr $ra</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1202-416-flower"><a class="markdownIt-Anchor" href="#1202-416-flower"></a> 1202-416 flower</h3>
<ul>
<li>简单汇编，直接给出可参考的模板<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main:</span><br><span class="line">    read_in($t0) # 读入m</span><br><span class="line">    read_in($s0) # 读入n</span><br><span class="line">    </span><br><span class="line">    for_i_begin:</span><br><span class="line">        beq $t0, $s0, for_i_end</span><br><span class="line">        divu $t1, $t0, 100</span><br><span class="line">        </span><br><span class="line">        mul $t2, $t1, 100</span><br><span class="line">        sub $t4, $t0, $t2</span><br><span class="line">        divu $t2, $t4, 10</span><br><span class="line">        </span><br><span class="line">        mul $t3, $t2, 10</span><br><span class="line">        sub $t3, $t4, $t3</span><br><span class="line">        </span><br><span class="line">        mul $t4, $t1, $t1</span><br><span class="line">        mul $t4, $t4, $t1</span><br><span class="line">        </span><br><span class="line">        mul $t5, $t2, $t2</span><br><span class="line">        mul $t5, $t5, $t2</span><br><span class="line">        add $t4, $t4, $t5</span><br><span class="line">        </span><br><span class="line">        mul $t5, $t3, $t3</span><br><span class="line">        mul $t5, $t5, $t3</span><br><span class="line">        add $t4, $t4, $t5</span><br><span class="line">        </span><br><span class="line">        if_begin:</span><br><span class="line">            bne $t4, $t0, if_end</span><br><span class="line">            print($t0)</span><br><span class="line">        if_end:</span><br><span class="line">        add $t0, $t0, 1</span><br><span class="line">        j for_i_begin</span><br><span class="line">    for_i_end:</span><br><span class="line">    end</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1202-419-josef"><a class="markdownIt-Anchor" href="#1202-419-josef"></a> 1202-419 josef</h3>
<ul>
<li>也是一道大一写的题目呢，<s>小海豚</s></li>
<li>其实刚开始我想如果暴力数组没过的话就用循环链表了(没想都暴力可以直接过)</li>
<li>这里主要通过一个数组记录某个编号是否已经被删除了</li>
<li>计数就是数组下标加一，遇到等于数组长度时自动返回0</li>
<li>给出一个可以参考的模板<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read($s0) # 读入人数n</span><br><span class="line">read($s1) # 读入报数m</span><br><span class="line"></span><br><span class="line">li $t0, 0 # 报数的人的编号</span><br><span class="line">li $t1, 0 # 外层循环变量i,将所有人都出局为止</span><br><span class="line">li $t2, 1 # 设置第一次数数</span><br><span class="line">for_start_i:</span><br><span class="line">    beq $t1, $s0, for_end_i # 达到最大人数结束循环</span><br><span class="line">    for_start_j:</span><br><span class="line">        beq $t2, $s1, for_end_j # 达到报数最大值</span><br><span class="line">        </span><br><span class="line">        //使用while循环处理报数，去除已经out的人</span><br><span class="line">    for_end_j:</span><br><span class="line">        sll $t4, $t0, 2</span><br><span class="line">        li $t5, 1</span><br><span class="line">        sw $t5, people($t4) # 记录出局的人，置1</span><br><span class="line">        addi $t5, $t0, 1 # 打印出局的人的编号</span><br><span class="line">        print($t5)</span><br><span class="line">        li $t2, 0 # 设置每次j的</span><br><span class="line">        addi $t1, $t1, 1 # 循环继续条件</span><br><span class="line">        j for_start_i</span><br><span class="line">for_end_i:</span><br><span class="line">    done</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>计算机组成原理</category>
        <category>推荐题目</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>北航计算机组成P1课下</title>
    <url>/2024/09/28/CO_P1/</url>
    <content><![CDATA[<h1 id="北航计算机组成原理p1课下"><a class="markdownIt-Anchor" href="#北航计算机组成原理p1课下"></a> 北航计算机组成原理P1课下</h1>
<div class="note info simple"><p>通过阅读本文，你可以大致了解北京航空航天大学2023级计算机组成原理P1课下的相关内容，希望能对你有所帮助</p>
</div>
<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<ul>
<li><s>发现教程有了，不愧是STAR</s></li>
<li>在阅读本次P1题解分享之前，我想单独分享一些关于<code>Verilog</code>编写有限状态机的内容(佬跳过，好吗？好的)</li>
<li>从学习完<code>Verilog</code>到<code>Pre</code>上机之间的很长一段时间，我写<code>Verilog</code>有限状态机都只有一个过程块（<s>可能大概应该有和我一样的同学吧</s>），就像下面这样<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">define</span> S0 2&#x27;b00</span></span><br><span class="line">......</span><br><span class="line"><span class="keyword">module</span> xxx (</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    ......</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        `S0: <span class="keyword">begin</span>:</span><br><span class="line">            <span class="comment">//状态转移代码</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">//消除锁存器</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在写一些简单的<code>Verilog</code>有限状态机的时候觉得结构简单清晰易懂，怎么写这么舒服，感觉脑子都闲置了下来（bushi，但是遇到像<code>cpu_checker_challenge</code>那样状态多且转移方程复杂的题目，就会显得单一过程块冗长且十分不易<code>debug</code>，几百行代码挤在一个<code>always</code>块中，总感觉像写C语言只写一个<code>main</code>函数</li>
</ul>
</li>
</ul>
<hr />
<h3 id="重构verilog结构"><a class="markdownIt-Anchor" href="#重构verilog结构"></a> 重构<code>Verilog</code>结构</h3>
<ul>
<li>直到我遇见了<code>HDLbits</code>，它向我提供了一种使用<code>Verilog</code>搭建和<code>logisim</code>结构很相似的有限状态机的代码机构，感觉会比一个<code>always</code>块清晰一些？</li>
<li>首先，解决最大的问题，把<code>always</code>块拆分出来，像<code>logisim</code>一样，我们将代码分出计算次态的状态转移逻辑使用纯组合电路代替  <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span>[<span class="number">1</span>: <span class="number">0</span>] state, next_state;</span><br><span class="line"></span><br><span class="line"><span class="comment">//时钟沿上升，状态转移</span></span><br><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (reset) <span class="keyword">begin</span></span><br><span class="line">        state &lt;= <span class="number">2&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        state &lt;= next_state;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//计算次态next_state</span></span><br><span class="line"><span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span>(state)</span><br><span class="line">        `S0: <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">//状态转移</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//输出逻辑方案1</span></span><br><span class="line"><span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">    out = ......</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//输出逻辑方案2</span></span><br><span class="line"><span class="keyword">assign</span> out = ......</span><br></pre></td></tr></table></figure>
<ul>
<li>诶呀，瞬间感觉代码变得清爽了，结构更加清晰了有没有（<s>没有也不许说</s>）</li>
</ul>
</li>
<li>也许此时你觉得这样不过只是拆了几个<code>always</code>出来，没什么技术含量，那么接下来我们还可以利用新的结构做出一些原本结构做不出来的优化–<strong>简化代码逻辑</strong>与<strong>消除锁存器plus</strong>
<ul>
<li>你是否常常遇到这种情况，某个变量多个状态下的变化是一致的，只有极少部分的值改变的不一致<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span>(status)</span><br><span class="line">        `S0: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span> (in == a) <span class="keyword">begin</span></span><br><span class="line">                count &lt;= <span class="number">1</span>;</span><br><span class="line">                .......</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (in == b) <span class="keyword">begin</span></span><br><span class="line">                count &lt;= <span class="number">0</span>;</span><br><span class="line">                .......</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (in == c) <span class="keyword">begin</span></span><br><span class="line">                count &lt;= <span class="number">0</span>;</span><br><span class="line">                .......</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (in == d) <span class="keyword">begin</span></span><br><span class="line">                count &lt;= <span class="number">0</span>;</span><br><span class="line">                .......</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                count &lt;= <span class="number">0</span>;</span><br><span class="line">                .......</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        ......</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
上面只展示一个状态下<code>count</code>变量的转移，如果你有10个状态呢（<s>你真的敢像<code>logisim</code>一样CV吗</s>），但是如果我们使用新结构就可以在<code>always</code>块开始时默认赋值了，节省代码<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    count &lt;= next_count;</span><br><span class="line">    status &lt;= next_status;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">//默认赋值区域</span></span><br><span class="line">    next_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span>(status)</span><br><span class="line">        `S0: <span class="keyword">begin</span>:</span><br><span class="line">            <span class="keyword">if</span> (in == a) <span class="keyword">begin</span></span><br><span class="line">                next_count = <span class="number">1</span>;   </span><br><span class="line">            .......</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (in == b) <span class="keyword">begin</span></span><br><span class="line">                .......</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (in == c) <span class="keyword">begin</span></span><br><span class="line">                .......</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (in == d) <span class="keyword">begin</span></span><br><span class="line">                .......</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                .......</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
这得益于我们使用组合逻辑的always块不是非阻塞赋值，可以多次赋值，所以不用像之前一样每个情况都要重复</li>
<li>同样，通过预先赋初值的办法我们就可以彻底消除锁存器这个bug了，因为锁存器产生原因就是我们没有明确赋值导致<code>Verilog</code>推导出锁存器记录之前的状态（<code>Verilog</code>帮我们默认赋值）<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (in == a) <span class="keyword">begin</span></span><br><span class="line">        count &lt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span> <span class="comment">//缺少else分支</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (in == a) <span class="keyword">begin</span></span><br><span class="line">        count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
新结构的代码没有锁存器问题，但是<font color = red>不要故意不写else，重申，我们只是抑制锁存器plus</font></li>
</ul>
</li>
</ul>
<hr />
<h3 id="testbench输入编写"><a class="markdownIt-Anchor" href="#testbench输入编写"></a> TestBench输入编写</h3>
<ul>
<li>我在看学长的博客之前，例如暑假学co_pre的时候我一直是使用CV编写<code>tb</code>文件的。。。效率还是稍微太低了点，后来需要的测试数据加多了之后我也使用过<code>python</code>脚本帮我自动化生成<code>tb</code>文件，但是我还是不喜欢，效率还是太低了</li>
<li>于是乎，我开始寻找直接在verilog中简单编写<code>tb</code>的方案，<a href="https://flyinglandlord.github.io/2021/10/24/BUAA-CO-2021/P1/P1%E8%AF%BE%E4%B8%8B%E5%AD%A6%E4%B9%A0/">这位20级的学长</a>提供了一个使用<code>while</code>循环的简单思路</li>
<li>首先我们知道<code>Verilog</code>是允许给整个寄存器赋值一个字符串的<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span>[<span class="number">1023</span>: <span class="number">0</span>] data;</span><br><span class="line"><span class="keyword">reg</span>[<span class="number">0</span>: <span class="number">1023</span>] test_data;</span><br><span class="line">data = <span class="string">&quot;begin endBeGin this is a great End Begin end&quot;</span>;</span><br><span class="line">test_data = <span class="string">&quot;begin endBgein&quot;</span>;</span><br><span class="line"><span class="comment">// data[1023: 0](radix: ascii) ______________begin endBeGin this is a great End Begin end</span></span><br><span class="line"><span class="comment">// test_data[0: 1023](radix: ascii) _____________________begin endBegin</span></span><br></pre></td></tr></table></figure>
</li>
<li>这样字符串会按照一个字符8个bit填入data数组中，将字符串从尾部开始依次填入data尾部索引，所以我们可以通过循环取值的方式获得每一个字符</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="keyword">reg</span>[<span class="number">0</span>: <span class="number">1023</span>] data;</span><br><span class="line"><span class="keyword">reg</span>[<span class="number">1023</span>: <span class="number">0</span>] test_data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">	<span class="comment">// Initialize Inputs</span></span><br><span class="line">	in = <span class="number">0</span>;</span><br><span class="line">	data = <span class="string">&quot;begin yes or no this is a question&quot;</span>;</span><br><span class="line">	test_data = <span class="string">&quot;begin yes or no this is a question&quot;</span>;</span><br><span class="line">	<span class="comment">// Wait 100 ns for global reset to finish</span></span><br><span class="line">	#<span class="number">100</span>;</span><br><span class="line">       <span class="keyword">while</span>(!data[<span class="number">0</span>: <span class="number">7</span>]) data = data &lt;&lt; <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(data[<span class="number">0</span>: <span class="number">7</span>]) <span class="keyword">begin</span></span><br><span class="line">		in[<span class="number">7</span>: <span class="number">0</span>] = data[<span class="number">0</span>: <span class="number">7</span>];</span><br><span class="line">		data = data &lt;&lt; <span class="number">8</span>;</span><br><span class="line">		#<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line">	in = <span class="number">0</span>;</span><br><span class="line">	#<span class="number">100</span>;</span><br><span class="line">	<span class="keyword">while</span>(test_data[<span class="number">7</span>: <span class="number">0</span>]) <span class="keyword">begin</span></span><br><span class="line">		in = test_data[<span class="number">7</span>: <span class="number">0</span>];</span><br><span class="line">		test_data = test_data &gt;&gt; <span class="number">8</span>;</span><br><span class="line">		#<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">end</span> </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<hr />
<h2 id="p1q5-表达式状态机"><a class="markdownIt-Anchor" href="#p1q5-表达式状态机"></a> P1.Q5 表达式状态机</h2>
<ul>
<li>大抵是一道很显然的<code>Moore</code>状态机，只需要判断<code>需要运算符</code>和<code>需要数字</code>两种状态即可，大致的思路如下<br />
<img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/P1_Q5.png" alt="状态转移图" /></li>
<li>等等，这里的<code>*</code>和正则里面的不是一个啊，这里的是<code>\*</code>，笔者忘改了</li>
<li>写起来也是顺手啊</li>
<li>提供一个进阶题(<a href="/2024/09/30/CO_P1_extra/" title="北航计算机组成P1推荐题汇总">北航计算机组成P1推荐题汇总</a>)，移步1202-145，加入匹配括号，甚至是多重嵌套括号，思路其实是一致的</li>
</ul>
<hr />
<h2 id="p1extra-blockchecker"><a class="markdownIt-Anchor" href="#p1extra-blockchecker"></a> P1.extra BlockChecker</h2>
<ul>
<li>一道好题，<s>但不至于卡我一天吧</s>(<code>&amp;&amp;</code>别再写成<code>||</code>了</li>
<li>因为我第一个思路因为某些莫名的原因一直没过(手真贱，所以我就换了一个思路，那么我提供两个思路思考</li>
</ul>
<h3 id="思路一-多个寄存器"><a class="markdownIt-Anchor" href="#思路一-多个寄存器"></a> 思路一 多个寄存器</h3>
<ul>
<li>
<p><s>好处是状态少，坏处是容易手误</s></p>
</li>
<li>
<p>状态设置思路</p>
<ul>
<li>首先设置了四个状态<code>start</code>、<code>word</code>、<code>illegal</code>分别表示空闲状态、匹配单词状态、匹配已经非法状态</li>
</ul>
</li>
<li>
<p>寄存器变量设置思路</p>
<table>
<thead>
<tr>
<th style="text-align:center">寄存器变量</th>
<th style="text-align:center">位宽</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">num</td>
<td style="text-align:center">32</td>
<td style="text-align:center">保存读入的单词长度(unsigned)</td>
</tr>
<tr>
<td style="text-align:center">flag</td>
<td style="text-align:center">33</td>
<td style="text-align:center">保存目前未匹配的begin数量(signed)</td>
</tr>
<tr>
<td style="text-align:center">has_begin</td>
<td style="text-align:center">1</td>
<td style="text-align:center">前一个周期是否已经匹配begin成功</td>
</tr>
<tr>
<td style="text-align:center">has_end</td>
<td style="text-align:center">1</td>
<td style="text-align:center">前一个周期是否已经匹配end成功</td>
</tr>
<tr>
<td style="text-align:center">first</td>
<td style="text-align:center">8</td>
<td style="text-align:center">最近五个周期内第1个周期的字符</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">8</td>
<td style="text-align:center">最近五个周期内第i个周期的字符</td>
</tr>
<tr>
<td style="text-align:center">fifth</td>
<td style="text-align:center">8</td>
<td style="text-align:center">这个周期读入的in，即最近五个周期内第5个周期的字符</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>状态转移思路</p>
<ul>
<li><code>start</code>状态
<ul>
<li><code>reset</code>生效后回到<code>start</code>状态</li>
<li>匹配到字母则<code>num</code>自增，且进入状态<code>word</code></li>
<li>匹配到空格保持原状态</li>
<li>若匹配到其他的进入<code>illegal</code>状态</li>
</ul>
</li>
<li><code>word</code>状态
<ul>
<li>读入字母，<code>num</code>自增，如果在包括此次<code>in</code>输入共有五个字符时，且<code>first</code> ~ <code>fifth(in)</code>是<code>begin</code>(不区分大小写)，<code>flag</code>加1，设置<code>has_begin</code></li>
<li>同上，在包含此次<code>in</code>共三个字符时，且<code>third</code> ~ <code>fifth(in)</code>是<code>end</code>(不区分大小写)，<code>flag</code>减1，设置<code>has_end</code></li>
<li>读入字母，<code>has_begin</code>已经置高，说明前面五个字符已经是<code>begin</code>了，但是又读入一个字母，说明这个单词不是<code>begin</code>了，<code>flag</code>减1</li>
<li>同上，<code>has_end</code>已经置高了，说明这个单词不是<code>end</code>，<code>flag</code>需要加1</li>
<li>读入空格，说明单词已经读入完毕，<code>num</code>置0，如果<code>flag</code>此时是-1(<code>0x1ffffffff</code>)，说明先出现了未匹配的<code>end</code>，此时进入<code>illegal</code>状态，等待复位信号否则回到<code>start</code>空闲状态</li>
<li>读入其他字符进入<code>illegal</code>状态</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="思路二-多个状态"><a class="markdownIt-Anchor" href="#思路二-多个状态"></a> 思路二 多个状态</h3>
<ul>
<li><s>好处是清晰，没有坏处</s></li>
<li>状态设置思路
<table>
<thead>
<tr>
<th style="text-align:center">状态</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">_start</td>
<td style="text-align:center">空闲状态等待空格或者字母</td>
</tr>
<tr>
<td style="text-align:center">_b</td>
<td style="text-align:center">匹配到单词b</td>
</tr>
<tr>
<td style="text-align:center">_be</td>
<td style="text-align:center">匹配到单词be</td>
</tr>
<tr>
<td style="text-align:center">_beg</td>
<td style="text-align:center">匹配到单词beg</td>
</tr>
<tr>
<td style="text-align:center">_begi</td>
<td style="text-align:center">匹配到单词begi</td>
</tr>
<tr>
<td style="text-align:center">_begin</td>
<td style="text-align:center">匹配到单词begin</td>
</tr>
<tr>
<td style="text-align:center">_e</td>
<td style="text-align:center">匹配到单词e</td>
</tr>
<tr>
<td style="text-align:center">_en</td>
<td style="text-align:center">匹配到单词en</td>
</tr>
<tr>
<td style="text-align:center">_end</td>
<td style="text-align:center">匹配到单词end</td>
</tr>
<tr>
<td style="text-align:center">_other</td>
<td style="text-align:center">匹配到其他单词</td>
</tr>
</tbody>
</table>
</li>
<li>寄存器设置思路
<ul>
<li>只需要<code>state</code>寄存器保存状态和<code>flag</code>寄存器保存左括号数</li>
</ul>
</li>
<li>状态转移思路
<ul>
<li><code>_start</code>状态
<ul>
<li>复位后回到<code>_start</code>状态等待输入</li>
<li>如果是字母<code>b</code>进入<code>_b</code>状态</li>
<li>如果是字母<code>e</code>进入<code>_e</code>状态</li>
<li>如果是其他字母进入<code>_other</code>状态</li>
<li>空格保持状态</li>
</ul>
</li>
<li><code>_b</code> ~ <code>_en</code>状态
<ul>
<li>每个都是匹配到某个字母转为下一个状态：<code>_b</code>匹配到字母<code>e</code>转到<code>_be</code></li>
<li>匹配到其他字母直接转为<code>_other</code></li>
<li>匹配到空格回到空闲状态</li>
</ul>
</li>
<li><code>_begin</code>与<code>_end</code>
<ul>
<li>两个状态特殊在于判断其后是否还有字母，也即到底是完整单词还是其他单词的前缀例如<code>endx</code></li>
<li>因为前一个状态转移时时默认匹配到了完整单词，例如<code>_begi</code>到<code>_begin</code>是匹配到了<code>begin</code>一个周期的，所以如果后面有其他字母需要调整<code>flag</code>的值</li>
</ul>
</li>
<li><code>_other</code>
<ul>
<li>接收到字母保持原态</li>
<li>接收到空格回到空闲状态</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<h2 id="p1推荐题汇总"><a class="markdownIt-Anchor" href="#p1推荐题汇总"></a> P1推荐题汇总</h2>
<a class="btn-beautify " href="https://kie-chi.github.io/2024/09/30/CO_P1_extra/" 
  title="P1推荐题汇总"><span>P1推荐题汇总</span></a>
<p><a href="https://kie-chi.github.io/2024/09/30/CO_P1_extra/">P1推荐题汇总</a></p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
        <category>课下复习</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>北航计算机组成P3课下</title>
    <url>/2024/10/22/CO_P3/</url>
    <content><![CDATA[<h1 id="北航计算机组成原理p3课下"><a class="markdownIt-Anchor" href="#北航计算机组成原理p3课下"></a> 北航计算机组成原理P3课下</h1>
<div class="note info simple"><p>通过阅读本文，你可以大致了解北京航空航天大学2023级计算机组成原理P3课下的相关内容，希望能对你有所帮助</p>
</div>
<h1 id="logisim-搭建8指令简单单周期cpu"><a class="markdownIt-Anchor" href="#logisim-搭建8指令简单单周期cpu"></a> logisim 搭建8指令简单单周期CPU</h1>
<p>[toc]</p>
<h2 id="设计文档"><a class="markdownIt-Anchor" href="#设计文档"></a> 设计文档</h2>
<h3 id="总要求"><a class="markdownIt-Anchor" href="#总要求"></a> 总要求</h3>
<ul>
<li>实现指令集<code>&#123;addu、subu、ori、lui、lw、sw、beq、nop&#125;</code></li>
<li>指令集所有指令的<code>RTL</code>
<ul>
<li><code>add</code>(<code>addu</code>)<br />
<img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CO_P3_image0.png" alt="alt text" /></li>
<li><code>sub</code>(<code>subu</code>)<br />
<img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CO_P3_image1.png" alt="alt text" /></li>
<li><code>ori</code><br />
<img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CO_P3_image2.png" alt="alt text" /></li>
<li><code>lui</code><br />
<img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CO_P3_image3.png" alt="alt text" /></li>
<li><code>lw</code><br />
<img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CO_P3_image4.png" alt="alt text" /><br />
<img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CO_P3_image5.png" alt="alt text" /></li>
<li><code>sw</code><br />
<img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CO_P3_image6.png" alt="alt text" /></li>
<li><code>beq</code><br />
<img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CO_P3_image7.png" alt="alt text" /></li>
<li><code>nop</code>
<ul>
<li>特殊，一般可以用<code>sll</code>一起代替，这里因为指令集没有<code>sll</code>所以我们直接使用<code>sll</code>的部分代替<code>nop</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<h3 id="数据通路设计草图"><a class="markdownIt-Anchor" href="#数据通路设计草图"></a> 数据通路设计草图</h3>
<p><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CO_P3_06e1d48e25b28e0dd5a05c1c5069791.jpg" alt="alt text" /><br />
注：上述的<code>j</code>、<code>jal</code>、<code>jr</code>指令不在指令集中</p>
<hr />
<h3 id="数据通路详细设计"><a class="markdownIt-Anchor" href="#数据通路详细设计"></a> 数据通路详细设计</h3>
<h4 id="if"><a class="markdownIt-Anchor" href="#if"></a> <code>IF</code></h4>
<ul>
<li>首先我们观察需要设计的CPU，必不可少的一部分就是<code>PC</code>、<code>IM</code>，没有指令谈何执行指令呢，所以我们将这个阶段称为<strong>取指</strong>(<code>IF</code>)</li>
<li>基于低耦合的原则，我们希望<code>PC</code>永远只是指向当前需要执行的指令，而不需要进行其他的操作，因此，我们在取指阶段多加入一个模块<strong>次地址计算模块(<code>NPC</code>)</strong>，专门用于计算根据<code>PC</code>的值以及执行的指令与结果更新<code>PC</code>的值</li>
<li>至此，<code>IF</code>阶段的所有模块都浮出水面了分别是<code>PC</code>、<code>NPC</code>、<code>IM</code></li>
</ul>
<h5 id="pc"><a class="markdownIt-Anchor" href="#pc"></a> <code>PC</code></h5>
<ul>
<li>
<p>取指阶段最最重要的一个模块无疑是<code>PC</code>程序计数器，没有地址无从取指</p>
</li>
<li>
<p>程序计数器<code>PC</code>始终指向当前执行的指令地址，且会根据<code>NPC</code>提供的值更新值</p>
<table>
<thead>
<tr>
<th style="text-align:center">端口</th>
<th style="text-align:center">位宽</th>
<th style="text-align:center">方向</th>
<th style="text-align:center">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">init[31:0]</td>
<td style="text-align:center">32</td>
<td style="text-align:center">input</td>
<td style="text-align:center">对于PC端口的初始化，默认为<code>0x00003000</code></td>
</tr>
<tr>
<td style="text-align:center">NPC[31:0]</td>
<td style="text-align:center">32</td>
<td style="text-align:center">input</td>
<td style="text-align:center">NPC传入的值，时钟沿更新PC值</td>
</tr>
<tr>
<td style="text-align:center">clk</td>
<td style="text-align:center">1</td>
<td style="text-align:center">input</td>
<td style="text-align:center">时钟信号</td>
</tr>
<tr>
<td style="text-align:center">rst</td>
<td style="text-align:center">1</td>
<td style="text-align:center">input</td>
<td style="text-align:center"><strong>异步</strong>复位信号</td>
</tr>
<tr>
<td style="text-align:center">PC[31:0]</td>
<td style="text-align:center">32</td>
<td style="text-align:center">output</td>
<td style="text-align:center">当前执行的指令地址</td>
</tr>
</tbody>
</table>
<p><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CO_P3_image8.png" alt="alt text" /></p>
</li>
</ul>
<h5 id="npc"><a class="markdownIt-Anchor" href="#npc"></a> <code>NPC</code></h5>
<ul>
<li>
<p>既然介绍了<code>PC</code>模块，接下来就需要设计<code>NPC</code>模块与<code>PC</code>模块一起配合不断地获得需要执行的指令的地址</p>
</li>
<li>
<p><code>NPC</code>将根据当前<code>PC</code>的值与当前指令(例如<code>branch</code>类、<code>jump</code>类指令)综合判断更新<code>PC</code>的值</p>
<table>
<thead>
<tr>
<th style="text-align:center">端口</th>
<th style="text-align:center">位宽</th>
<th style="text-align:center">方向</th>
<th style="text-align:center">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PC[31:0]</td>
<td style="text-align:center">32</td>
<td style="text-align:center">input</td>
<td style="text-align:center">接受当前PC的值</td>
</tr>
<tr>
<td style="text-align:center">imm[15:0]</td>
<td style="text-align:center">16(目前)</td>
<td style="text-align:center">input</td>
<td style="text-align:center">branch类指令跳转的立即数</td>
</tr>
<tr>
<td style="text-align:center">IM_slt</td>
<td style="text-align:center">1(目前)</td>
<td style="text-align:center">input</td>
<td style="text-align:center">当前执行的指令类型</td>
</tr>
<tr>
<td style="text-align:center">equal(目前)</td>
<td style="text-align:center">1(目前)</td>
<td style="text-align:center">input</td>
<td style="text-align:center">beq指令是否满足相等</td>
</tr>
<tr>
<td style="text-align:center">NPC[31:0]</td>
<td style="text-align:center">32</td>
<td style="text-align:center">output</td>
<td style="text-align:center">输出计算得到的此地址</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>解释为何是<strong>目前</strong></p>
<p><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CO_P3_image9.png" alt="alt text" /><br />
<img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CO_P3_449ed5029e932b2f65a9f080a0dc318.jpg" alt="alt text" /></p>
</li>
</ul>
<h5 id="im"><a class="markdownIt-Anchor" href="#im"></a> <code>IM</code></h5>
<ul>
<li>通过<code>PC</code>传入的地址寻找需要执行的地址，使用<code>ROM</code>存储器即可
<table>
<thead>
<tr>
<th style="text-align:center">端口</th>
<th style="text-align:center">位宽</th>
<th style="text-align:center">方向</th>
<th style="text-align:center">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PC[31:0]</td>
<td style="text-align:center">32</td>
<td style="text-align:center">input</td>
<td style="text-align:center">传入PC的值</td>
</tr>
<tr>
<td style="text-align:center">IM[31:0]</td>
<td style="text-align:center">32</td>
<td style="text-align:center">output</td>
<td style="text-align:center">得到的指令</td>
</tr>
<tr>
<td style="text-align:center"><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CO_P3_image10.png" alt="alt text" /></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</li>
</ul>
<hr />
<h4 id="id"><a class="markdownIt-Anchor" href="#id"></a> <code>ID</code></h4>
<ul>
<li>现在我们已经可以正常地从指令存储器中取出指令了，那么为了执行指令我们首先需要明白这句指令在说什么(通过指令机器码确定指令)，所以我们需要一个指令译码器<code>IM_SPL</code>，其次确定了指令的类型(<code>R</code> <code>I</code> <code>J</code>)、指令的含义，我们就需要取出这个指令需要的操作数因为指令的类型不同，可能来源于寄存器堆<code>GRF</code>，也可能来自于指令给出的立即数，所以我们需要对立即数处理的模块<code>EXT</code>，这个阶段称为<strong>译码(<code>ID</code>)</strong></li>
<li>至此，<code>ID</code>阶段包含<code>IM_SPL</code>、<code>GRF</code>、<code>EXT</code>三个模块</li>
</ul>
<h5 id="im_spl"><a class="markdownIt-Anchor" href="#im_spl"></a> <code>IM_SPL</code></h5>
<ul>
<li>
<p><code>IM_SPL</code>对于从<code>IM</code>中取出的指令进行分线器分出，通过<code>IM_SPL</code>的输出内容，我们能更加清晰地了解指令的类型与用途</p>
<table>
<thead>
<tr>
<th style="text-align:center">端口</th>
<th style="text-align:center">位宽</th>
<th style="text-align:center">方向</th>
<th style="text-align:center">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">IM[31:0]</td>
<td style="text-align:center">32</td>
<td style="text-align:center">input</td>
<td style="text-align:center">传入解析的指令</td>
</tr>
<tr>
<td style="text-align:center">opcode[5:0]</td>
<td style="text-align:center">6</td>
<td style="text-align:center">output</td>
<td style="text-align:center">指令操作码</td>
</tr>
<tr>
<td style="text-align:center">rs[4:0]</td>
<td style="text-align:center">5</td>
<td style="text-align:center">output</td>
<td style="text-align:center">源寄存器</td>
</tr>
<tr>
<td style="text-align:center">rt[4:0]</td>
<td style="text-align:center">5</td>
<td style="text-align:center">output</td>
<td style="text-align:center">目标寄存器(J、I)</td>
</tr>
<tr>
<td style="text-align:center">rd[4:0]</td>
<td style="text-align:center">5</td>
<td style="text-align:center">output</td>
<td style="text-align:center">目的地寄存器®</td>
</tr>
<tr>
<td style="text-align:center">shamt[4:0] (目前不使用)</td>
<td style="text-align:center">5</td>
<td style="text-align:center">output</td>
<td style="text-align:center">移位</td>
</tr>
<tr>
<td style="text-align:center">funct[5:0]</td>
<td style="text-align:center">6</td>
<td style="text-align:center">output</td>
<td style="text-align:center">配合opcode确认R型指令</td>
</tr>
<tr>
<td style="text-align:center">imm_i[15:0]</td>
<td style="text-align:center">16</td>
<td style="text-align:center">output</td>
<td style="text-align:center">I型指令的立即数操作数</td>
</tr>
<tr>
<td style="text-align:center">imm_j[25:0] (目前不使用)</td>
<td style="text-align:center">26</td>
<td style="text-align:center">output</td>
<td style="text-align:center">J型指令的立即数操作数</td>
</tr>
</tbody>
</table>
<p><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CO_P3_image11.png" alt="alt text" /></p>
</li>
</ul>
<h5 id="grf"><a class="markdownIt-Anchor" href="#grf"></a> <code>GRF</code></h5>
<ul>
<li>
<p>假设当前的是R型指令，我们需要的操作数来自于寄存器，所以我们需要使用<code>IM_SPL</code>解析出来的寄存器编号去获得操作数的值</p>
<table>
<thead>
<tr>
<th style="text-align:center">端口</th>
<th style="text-align:center">位宽</th>
<th style="text-align:center">方向</th>
<th style="text-align:center">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">clk</td>
<td style="text-align:center">1</td>
<td style="text-align:center">input</td>
<td style="text-align:center">时钟信号</td>
</tr>
<tr>
<td style="text-align:center">rst</td>
<td style="text-align:center">1</td>
<td style="text-align:center">input</td>
<td style="text-align:center"><strong>异步</strong>复位信号</td>
</tr>
<tr>
<td style="text-align:center">A1[4:0]</td>
<td style="text-align:center">5</td>
<td style="text-align:center">input</td>
<td style="text-align:center">第一个读寄存器编号</td>
</tr>
<tr>
<td style="text-align:center">A2[4:0]</td>
<td style="text-align:center">5</td>
<td style="text-align:center">input</td>
<td style="text-align:center">第二个读寄存器编号</td>
</tr>
<tr>
<td style="text-align:center">A3[4:0] (<code>WB</code>阶段使用)</td>
<td style="text-align:center">5</td>
<td style="text-align:center">input</td>
<td style="text-align:center">写入寄存器编号</td>
</tr>
<tr>
<td style="text-align:center">WD[31:0] (<code>WB</code>阶段使用)</td>
<td style="text-align:center">32</td>
<td style="text-align:center">input</td>
<td style="text-align:center">写入寄存器的值</td>
</tr>
<tr>
<td style="text-align:center">WE(<code>WB</code>阶段使用)</td>
<td style="text-align:center">1</td>
<td style="text-align:center">input</td>
<td style="text-align:center">写使能信号</td>
</tr>
<tr>
<td style="text-align:center">RD1[31:0]</td>
<td style="text-align:center">32</td>
<td style="text-align:center">output</td>
<td style="text-align:center">第一个读寄存器的值</td>
</tr>
<tr>
<td style="text-align:center">RD2[31:0]</td>
<td style="text-align:center">32</td>
<td style="text-align:center">output</td>
<td style="text-align:center">第二个读寄存器的值</td>
</tr>
</tbody>
</table>
<p><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CO_P3_image12.png" alt="alt text" /><br />
<img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CO_P3_30ef94c2f26f95db316fb797fd8d7c8.jpg" alt="alt text" /></p>
</li>
</ul>
<h5 id="ext"><a class="markdownIt-Anchor" href="#ext"></a> <code>EXT</code></h5>
<ul>
<li>
<p>对于I型指令与J型指令(目前不涉及)，我们虽然可以直接从指令中获得操作数，但是为了方便后续执行，我们需要将立即数位拓展至与寄存器的值的位数相同(32位)，故<code>EXT</code>就是根据指令来拓展立即数的模块</p>
<table>
<thead>
<tr>
<th style="text-align:center">端口</th>
<th style="text-align:center">位宽</th>
<th style="text-align:center">方向</th>
<th style="text-align:center">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">imm[15:0]</td>
<td style="text-align:center">16(目前)</td>
<td style="text-align:center">input</td>
<td style="text-align:center">指令传入的立即数</td>
</tr>
<tr>
<td style="text-align:center">ext_slt[1:0]</td>
<td style="text-align:center">2(目前)</td>
<td style="text-align:center">input</td>
<td style="text-align:center">控制位拓展的类型</td>
</tr>
<tr>
<td style="text-align:center">ext[31:0]</td>
<td style="text-align:center">32</td>
<td style="text-align:center">output</td>
<td style="text-align:center">拓展后的立即数</td>
</tr>
</tbody>
</table>
<p><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CO_P3_image13.png" alt="alt text" /><br />
<img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CO_P3_02a7d5e47dc0b941cbed86f3854f146.jpg" alt="alt text" /></p>
</li>
</ul>
<hr />
<h4 id="ex"><a class="markdownIt-Anchor" href="#ex"></a> <code>EX</code></h4>
<ul>
<li>现在我们已经做好了执行指令的前的所有准备，接下来我们对这些操作数进行某些操作得到我们指令需要内容，这个阶段称为<strong>执行(<code>EX</code>)</strong></li>
<li><code>EX</code>阶段只有一个模块<code>ALU</code></li>
</ul>
<h5 id="alu"><a class="markdownIt-Anchor" href="#alu"></a> <code>ALU</code></h5>
<ul>
<li>
<p><code>ALU</code>算术单元来对操作数进行操作得到结果(算术类指令、逻辑类指令、存取类指令)，同时通过<code>ALU</code>输出符号位(<code>OF</code>co实验不需要、<code>ZF</code>目前仅实现、<code>SF</code>比较大小需要、 <code>CF</code>co实验不需要)</p>
<table>
<thead>
<tr>
<th style="text-align:center">端口</th>
<th style="text-align:center">位宽</th>
<th style="text-align:center">方向</th>
<th style="text-align:center">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A[31:0]</td>
<td style="text-align:center">32</td>
<td style="text-align:center">input</td>
<td style="text-align:center">第一个操作数</td>
</tr>
<tr>
<td style="text-align:center">B[31:0]</td>
<td style="text-align:center">32</td>
<td style="text-align:center">input</td>
<td style="text-align:center">第二个操作数</td>
</tr>
<tr>
<td style="text-align:center">cal_slt</td>
<td style="text-align:center">1</td>
<td style="text-align:center">input</td>
<td style="text-align:center">加法电路还是减法电路</td>
</tr>
<tr>
<td style="text-align:center">out_slt[1:0]</td>
<td style="text-align:center">2</td>
<td style="text-align:center">input</td>
<td style="text-align:center">选择输出了什么</td>
</tr>
<tr>
<td style="text-align:center">out[31:0]</td>
<td style="text-align:center">32</td>
<td style="text-align:center">output</td>
<td style="text-align:center">输出数据</td>
</tr>
<tr>
<td style="text-align:center">is_eq(目前)</td>
<td style="text-align:center">1</td>
<td style="text-align:center">output</td>
<td style="text-align:center">符号位(目前只有零信号)</td>
</tr>
<tr>
<td style="text-align:center">flag_slt(未实现)</td>
<td style="text-align:center">？</td>
<td style="text-align:center">input</td>
<td style="text-align:center">控制输出的符号位</td>
</tr>
</tbody>
</table>
<p><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CO_P3_image14.png" alt="alt text" /><br />
<img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CO_P3_0aebdf2625a924021aaf26ac66ddfb8.jpg" alt="alt text" /></p>
</li>
</ul>
<hr />
<h4 id="mem"><a class="markdownIt-Anchor" href="#mem"></a> <code>MEM</code></h4>
<ul>
<li>对于存取类指令，我们通过<code>EX</code>阶段获得的是接下来需要操作数在内存中的地址，我们需要对数据存储器<code>DM</code>再进行相应的更改，这个阶段称为<strong>访存(<code>MEM</code>)</strong></li>
<li><code>MEM</code>阶段只有一个模块<code>DM</code></li>
</ul>
<h5 id="dm"><a class="markdownIt-Anchor" href="#dm"></a> <code>DM</code></h5>
<ul>
<li>
<p>存放数据的存储器，对于存取类指令，我们可以从数据存储器中取得数据</p>
<table>
<thead>
<tr>
<th style="text-align:center">端口</th>
<th style="text-align:center">位宽</th>
<th style="text-align:center">方向</th>
<th style="text-align:center">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">clk</td>
<td style="text-align:center">1</td>
<td style="text-align:center">input</td>
<td style="text-align:center">时钟信号</td>
</tr>
<tr>
<td style="text-align:center">rst</td>
<td style="text-align:center">1</td>
<td style="text-align:center">input</td>
<td style="text-align:center"><strong>异步</strong>复位信号</td>
</tr>
<tr>
<td style="text-align:center">A[31:0]</td>
<td style="text-align:center">32</td>
<td style="text-align:center">input</td>
<td style="text-align:center">存取数据地址</td>
</tr>
<tr>
<td style="text-align:center">WD[31:0]</td>
<td style="text-align:center">32</td>
<td style="text-align:center">input</td>
<td style="text-align:center">存入数据值</td>
</tr>
<tr>
<td style="text-align:center">WE</td>
<td style="text-align:center">1</td>
<td style="text-align:center">input</td>
<td style="text-align:center">写使能信号</td>
</tr>
<tr>
<td style="text-align:center">RD[31:0]</td>
<td style="text-align:center">32</td>
<td style="text-align:center">output</td>
<td style="text-align:center">读出数据值</td>
</tr>
</tbody>
</table>
<p><img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CO_P3_image15.png" alt="alt text" /></p>
</li>
</ul>
<hr />
<h4 id="wb"><a class="markdownIt-Anchor" href="#wb"></a> <code>WB</code></h4>
<ul>
<li>对于<code>ALU</code>计算得到的内容以及从内存中读出的值，我们经常需要写回寄存器堆，所以最后一个阶段虽然仍然是针对寄存器堆，所以这个阶段我们称其为<strong>回写(<code>WB</code>)</strong></li>
<li><code>WB</code>阶段显然也只有唯一的模块<code>GRF</code></li>
</ul>
<h5 id="grf-2"><a class="markdownIt-Anchor" href="#grf-2"></a> <code>GRF</code></h5>
<ul>
<li>
<p>在<code>ID</code>阶段我们已经使用了<code>GRF</code>作为数据的提供方，但是还有一些端口没有使用，在这里我们将使用余下的一些端口</p>
<table>
<thead>
<tr>
<th style="text-align:center">端口</th>
<th style="text-align:center">位宽</th>
<th style="text-align:center">方向</th>
<th style="text-align:center">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">clk</td>
<td style="text-align:center">1</td>
<td style="text-align:center">input</td>
<td style="text-align:center">时钟信号</td>
</tr>
<tr>
<td style="text-align:center">rst</td>
<td style="text-align:center">1</td>
<td style="text-align:center">input</td>
<td style="text-align:center"><strong>异步</strong>复位信号</td>
</tr>
<tr>
<td style="text-align:center">A1[4:0] (<code>ID</code>阶段使用)</td>
<td style="text-align:center">5</td>
<td style="text-align:center">input</td>
<td style="text-align:center">第一个读寄存器编号</td>
</tr>
<tr>
<td style="text-align:center">A2[4:0] (<code>ID</code>阶段使用)</td>
<td style="text-align:center">5</td>
<td style="text-align:center">input</td>
<td style="text-align:center">第二个读寄存器编号</td>
</tr>
<tr>
<td style="text-align:center">A3[4:0]</td>
<td style="text-align:center">5</td>
<td style="text-align:center">input</td>
<td style="text-align:center">写入寄存器编号</td>
</tr>
<tr>
<td style="text-align:center">WD[31:0]</td>
<td style="text-align:center">32</td>
<td style="text-align:center">input</td>
<td style="text-align:center">写入寄存器的值</td>
</tr>
<tr>
<td style="text-align:center">WE</td>
<td style="text-align:center">1</td>
<td style="text-align:center">input</td>
<td style="text-align:center">写使能信号</td>
</tr>
<tr>
<td style="text-align:center">RD1[31:0] (<code>ID</code>阶段使用)</td>
<td style="text-align:center">32</td>
<td style="text-align:center">output</td>
<td style="text-align:center">第一个读寄存器的值</td>
</tr>
<tr>
<td style="text-align:center">RD2[31:0] (<code>ID</code>阶段使用)</td>
<td style="text-align:center">32</td>
<td style="text-align:center">output</td>
<td style="text-align:center">第二个读寄存器的值</td>
</tr>
</tbody>
</table>
<p><strong>设计草图等看<a href="#grf">上面</a></strong></p>
</li>
</ul>
<hr />
<h4 id="总数据通路草图"><a class="markdownIt-Anchor" href="#总数据通路草图"></a> 总数据通路草图</h4>
<ul>
<li>对于单周期CPU所有基础部件我们已经搭建完毕，接下来练成数据通路只需要将相应的端口进行连接(<strong>出现多对一端口使用MUX，控制信号后面给出</strong>)<br />
<img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CO_P3_e4b367f3a721a3dbc9b295929b1039b.jpg" alt="alt text" /></li>
</ul>
<hr />
<h3 id="控制信号生成"><a class="markdownIt-Anchor" href="#控制信号生成"></a> 控制信号生成</h3>
<ul>
<li>
<p>在上述阶段，我们已经基本完成了各个基本指令的数据通路的实现，接下来我们将通过<code>Controller</code>根据指令生成各异的控制信号来指导我们数据通路的流通</p>
</li>
<li>
<p>接下来的所有控制信号出现顺序采用(<code>IF -&gt; ID -&gt; EX -&gt; MEM -&gt; WB</code>)</p>
<table>
<thead>
<tr>
<th style="text-align:center">控制信号</th>
<th style="text-align:center">位宽</th>
<th style="text-align:center">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">IM_slt</td>
<td style="text-align:center">1</td>
<td style="text-align:center">控制NPC中im_slt，说明此次执行的指令类型</td>
</tr>
<tr>
<td style="text-align:center">A3_slt</td>
<td style="text-align:center">1</td>
<td style="text-align:center">控制输入GRF的A3端口，根据R型指令与I型指令不同</td>
</tr>
<tr>
<td style="text-align:center">GRF_we</td>
<td style="text-align:center">1</td>
<td style="text-align:center">控制GRF的WE信号，是否写入寄存器堆</td>
</tr>
<tr>
<td style="text-align:center">EXT_slt[1:0]</td>
<td style="text-align:center">2</td>
<td style="text-align:center">控制EXT的ext_slt，调整拓展指令的类型</td>
</tr>
<tr>
<td style="text-align:center">B_slt</td>
<td style="text-align:center">1</td>
<td style="text-align:center">控制ALU的B端口输入，根据R型指令与I型指令不同</td>
</tr>
<tr>
<td style="text-align:center">CAL_slt</td>
<td style="text-align:center">1</td>
<td style="text-align:center">控制ALU的cal_slt信号，选择加法或者减法电路</td>
</tr>
<tr>
<td style="text-align:center">OUT_slt</td>
<td style="text-align:center">2</td>
<td style="text-align:center">控制ALU的out_slt信号，选择输出的类型</td>
</tr>
<tr>
<td style="text-align:center">DM_we</td>
<td style="text-align:center">1</td>
<td style="text-align:center">控制DM的we信号，是否写入内存</td>
</tr>
<tr>
<td style="text-align:center">WD_slt</td>
<td style="text-align:center">1</td>
<td style="text-align:center">控制GRF的WD端口输入，选择不同的写入数据</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>采用与或门阵列的形式生成信号，例如，先通过<code>opcode</code>、<code>funct</code>两个信号确定执行的指令类型，再通过指令类型去生成控制信号</p>
<ul>
<li>与门阵列生成指令类型<br />
<img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CO_P3_image16.png" alt="alt text" /><br />
<img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CO_P3_image17.png" alt="alt text" /></li>
<li>或门阵列生成控制信号<br />
<img src="https://tsxb-top-pic.oss-cn-hangzhou.aliyuncs.com/chis/images/CO_P3_image18.png" alt="alt text" /></li>
</ul>
</li>
</ul>
<hr />
<h2 id="思考题"><a class="markdownIt-Anchor" href="#思考题"></a> 思考题</h2>
<p>小熊正在赶制</p>
<h2 id="生成测试数据"><a class="markdownIt-Anchor" href="#生成测试数据"></a> 生成测试数据</h2>
<p>小熊正在赶制</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
        <category>课下复习</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>北航计算机组成P2课下</title>
    <url>/2024/10/15/CO_p2/</url>
    <content><![CDATA[<h1 id="北航计算机组成原理p2课下"><a class="markdownIt-Anchor" href="#北航计算机组成原理p2课下"></a> 北航计算机组成原理P2课下</h1>
<div class="note info simple"><p>通过阅读本文，你可以大致了解北京航空航天大学2023级计算机组成原理P2课下的相关内容，希望能对你有所帮助</p>
</div>
<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<ul>
<li>在分享此次P2附加题做题思路前，我想对于在做题过程中错误和技巧进行总结与反思</li>
</ul>
<h3 id="对于栈的使用"><a class="markdownIt-Anchor" href="#对于栈的使用"></a> 对于栈的使用</h3>
<ul>
<li>为了使用栈，<s>首先我们要有一个栈</s>，而且对于某些递归程序或者传递参数较多的程序，频繁地对栈指针进行加减操作可能会出现某些难以察觉的问题，所以常常对于入栈和出栈操作封装函数<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">  stack: .space 400</span><br><span class="line"></span><br><span class="line">.macro push(%int)</span><br><span class="line">  addi $sp, $sp, -4</span><br><span class="line">  sw %int, $sp</span><br><span class="line">.end_macro</span><br><span class="line"></span><br><span class="line">.macro pop(%int)</span><br><span class="line">  lw %int $sp</span><br><span class="line">  addi $sp, $sp, 4</span><br><span class="line">.end_macro</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">  la $sp, stack</span><br><span class="line">  addi $sp, $sp, 400</span><br></pre></td></tr></table></figure>
</li>
<li>对于含有多个参数的递归程序，比如汉罗塔问题（四个参数用寄存器其实也还可以），将会使用栈传递和接收参数，同时还需要使用栈保护寄存器，所以可以规定自己的一套规则（在函数的开始接收参数再保存寄存器，调用函数前先保护寄存器再传递参数），总之一定要明白每次出入栈的真正含义，例如对于下面的c语言代码翻译<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">hanoi</span><span class="params">(<span class="type">int</span> base, <span class="type">char</span> from, <span class="type">char</span> via, <span class="type">char</span> to)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (base == <span class="number">0</span>) &#123;</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line">  hanoi(base - <span class="number">1</span>, from, via, to);</span><br><span class="line">  move(base, from, via);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main:</span><br><span class="line">    push($t0) # 传参数</span><br><span class="line">    ...</span><br><span class="line">    jal hanoi</span><br><span class="line">    </span><br><span class="line">hanoi:</span><br><span class="line">    pop($t3) # 接收参数</span><br><span class="line">    ...</span><br><span class="line">    push($ra) # 保存返回地址</span><br><span class="line">    </span><br><span class="line">    # if模块</span><br><span class="line">    </span><br><span class="line">    push($t0) # 保存参数</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    addi $t0, $t0, -1</span><br><span class="line">    push($t0) # 传递参数</span><br><span class="line">    ...</span><br><span class="line">    jal hanoi</span><br><span class="line">    </span><br><span class="line">    pop($t3) # 取出保留的参数</span><br><span class="line">    ...</span><br><span class="line">    print($t0, $t1, $t2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    pop($ra) # 取出返回地址</span><br><span class="line">    jr $ra</span><br></pre></td></tr></table></figure>
</li>
<li>如果你喜欢，可以永远只在调用函数前保留所有的参数，但是我个人比较喜欢在函数的开头保留<code>$ra</code>和<code>$s</code>（不过似乎从来没这样用过），然后在每一个返回的地方<code>pop($ra); jr $ra</code>，这样可以避免出现<code>$ra</code>混乱（可能是叶子函数但是弹了一个不是<code>$ra</code>的值，可能是中间函数使用了上层函数的<code>$ra</code>，莫名其妙出现一些很奇怪的bug）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push($ra) # 保存返回地址</span><br><span class="line"></span><br><span class="line">if_begin:</span><br><span class="line">    ...</span><br><span class="line">    pop($ra) # 取出返回地址</span><br><span class="line">    jr $ra</span><br><span class="line"></span><br><span class="line">jal others</span><br><span class="line">...</span><br><span class="line">pop($ra) # 取出返回地址</span><br><span class="line">jr $ra</span><br></pre></td></tr></table></figure>
</li>
<li>如果出现了调用栈时的bug可以从顶层模块开始将各个部分拆分出来，例有如下调用关系<code>main -&gt; hanoi -&gt; move/hanoi</code>，我们编写<code>main</code>函数的栈使用时，将假设<code>hanoi</code>等下层的函数正确地使用了栈，所以在调用前后除了传递进去的参数其他部分应该保持完全一致，不必纠结下层函数中间如何使用栈，然后依次向下编写<code>hanoi</code>、<code>move</code>函数，方能条理清晰、面面俱到<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hanoi:</span><br><span class="line"></span><br><span class="line">    push($t0) # 保护寄存器</span><br><span class="line">    push($t1)</span><br><span class="line"></span><br><span class="line">    push($t0) # 传递参数</span><br><span class="line">    push($t1)</span><br><span class="line"></span><br><span class="line">    jal hanoi # 可以理解除了传递的参数，调用函数前后栈结构不变</span><br><span class="line"></span><br><span class="line">    pop($t1) # 取出保护的寄存器</span><br><span class="line">    pop($t0)</span><br></pre></td></tr></table></figure>
<ul>
<li>调用函数前栈内容</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">                                     </span><br><span class="line">                          </span><br><span class="line">                         +-------------+ &lt;-$sp               </span><br><span class="line">                  --&gt;    |  传递参数    |     --&gt;           </span><br><span class="line">+--------+ &lt;-$sp  准备   +-------------+     调用       </span><br><span class="line">| ...    |               |  ...        |               </span><br></pre></td></tr></table></figure>
<ul>
<li>调用函数后栈内容</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+----------------+ &lt;-$sp</span><br><span class="line">|被调用者保存寄存器| </span><br><span class="line">+----------------+      </span><br><span class="line">|  返回地址       |    --&gt;  </span><br><span class="line">+----------------+    返回  +----------+ &lt;-$sp</span><br><span class="line">|  ...           |          | ...      |</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="http://cscore.buaa.edu.cn/#/problem?ProblemId=330&amp;PieId=1202">MIPS汉罗塔</a><br />
<a href="http://cscore.buaa.edu.cn/#/problem?ProblemId=53&amp;PieId=1202">MIPS全排列反转</a>(其实是P1课下一摸一样)</p>
<hr />
<h2 id="p2_extra_1-1206-33-puzzle"><a class="markdownIt-Anchor" href="#p2_extra_1-1206-33-puzzle"></a> P2_extra_1 1206-33 puzzle</h2>
<ul>
<li>本题看起来就像DP算法，但是想了好半天也没有找到一个可靠的状态转移方程（我不会算法，我是fw），所以我就正常使用递归来写了
<ul>
<li>首先我们确认探索的起点</li>
<li>有四个可选择方向，上下左右</li>
<li>判断向某个方向走是否会出边界</li>
<li>判断某个方向是否有路，以及是否是此次寻找的完整路径已经走过的结点</li>
<li>最后以走到的结点为下一次探索的起点</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> matrix[<span class="number">8</span>][<span class="number">8</span>] = &#123;<span class="number">0</span>&#125;;  <span class="comment">// 定义矩阵</span></span><br><span class="line"><span class="type">int</span> visited[<span class="number">8</span>][<span class="number">8</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 记录访问状态</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> row, col;</span><br><span class="line"><span class="type">int</span> end_r, end_c;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> s_row, <span class="type">int</span> s_col)</span> &#123;</span><br><span class="line">    <span class="comment">// 找到终点</span></span><br><span class="line">    <span class="keyword">if</span> (s_row == end_r - <span class="number">1</span> &amp;&amp; s_col == end_c - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 四个方向：上、下、左、右</span></span><br><span class="line">    <span class="type">int</span> dir_r[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> dir_c[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    visited[s_row][s_col] = <span class="number">1</span>; <span class="comment">// 标记当前节点为已访问</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历四个方向</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> new_r = s_row + dir_r[i];</span><br><span class="line">        <span class="type">int</span> new_c = s_col + dir_c[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 边界检查</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> &lt;= new_r &amp;&amp; new_r &lt; row &amp;&amp; <span class="number">0</span> &lt;= new_c &amp;&amp; new_c &lt; col) &#123;</span><br><span class="line">            <span class="comment">// 如果该位置没有障碍物且未被访问</span></span><br><span class="line">            <span class="keyword">if</span> (!matrix[new_r][new_c] &amp;&amp; !visited[new_r][new_c] ) &#123;</span><br><span class="line">                total += dfs(new_r, new_c); <span class="comment">// 递归搜索</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    visited[s_row][s_col] = <span class="number">0</span>; <span class="comment">// 回溯，解除当前节点的访问标记</span></span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> start_r, start_c;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入矩阵的行数和列数</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;row, &amp;col);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读入矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;matrix[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入起点和终点坐标</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;start_r, &amp;start_c, &amp;end_r, &amp;end_c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用DFS并输出结果</span></span><br><span class="line">    <span class="type">int</span> total_paths = dfs(start_r - <span class="number">1</span>, start_c - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, total_paths);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>这道题翻译大概率不会有<code>$ra</code>的问题，因为虽然我全程使用的是栈传递，但是因为这个递归函数有返回值，所以每次返回前我都需要将返回值压栈，自然会想到返回地址的问题</li>
<li>但是因为是多个条件的if判断，触发任何一个不满足条件直接跳出即可<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># read in new_r</span><br><span class="line">lw $t4, dir_r($t3)</span><br><span class="line">add $t4, $t4, $t0</span><br><span class="line"></span><br><span class="line"># 0 &lt;= new_r</span><br><span class="line">slt $t5 ,$t4, $zero </span><br><span class="line">bne $t5, $zero, if_end_2</span><br><span class="line"></span><br><span class="line"># new_r &lt; row</span><br><span class="line">slt $t5, $t4, $s0 </span><br><span class="line">beq $t5, $zero, if_end_2</span><br><span class="line"></span><br><span class="line"># read in new_c</span><br><span class="line">lw $t3, dir_c($t3) </span><br><span class="line">add $t3, $t3, $t1</span><br><span class="line"></span><br><span class="line"># 0 &lt;= new_c</span><br><span class="line">slt $t5, $t3, $zero </span><br><span class="line">bne $t5, $zero, if_end_2</span><br><span class="line"></span><br><span class="line"># new_c &lt; col</span><br><span class="line">slt $t5, $t3, $s1 # new</span><br><span class="line">beq $t5, $zero, if_end_2</span><br><span class="line"></span><br><span class="line"># !matrix[i][j]</span><br><span class="line">read_matrix($t4, $t3, $s1, $t5)</span><br><span class="line">bne $t5, $zero, if_end_2</span><br><span class="line"></span><br><span class="line"># !visited[i][j]</span><br><span class="line">read_visited($t4, $t3, $s1, $t5)</span><br><span class="line">bne $t5, $zero, if_end_2</span><br></pre></td></tr></table></figure>
</li>
<li>虽然我没找到DP的写法，但是可以开一个数组<code>path[i][j]</code>表示<code>(i,j)</code>位置到<code>(end_r,end_c)</code>的路径数，这样如果这个值不是0就可以不用继续递归了，效率应该还是略低于DP（如果有的话），<strong>请教我DP！！！</strong></li>
</ul>
<hr />
<h2 id="p2_extra_1-1206-418-factorial"><a class="markdownIt-Anchor" href="#p2_extra_1-1206-418-factorial"></a> p2_extra_1 1206-418 factorial</h2>
<ul>
<li>高精度！！！</li>
<li>本题应该纯粹是考察高精度的，目测数据不强，<s>毕竟我只能算不到600位也过了</s>，测试数据应该是远远没有1000位的</li>
<li>如果你选了6系人都爱的oop，你一定很喜欢java；如果你喜欢java，你就会知道里面有一个很有趣的类<code>BigInteger</code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> signum; <span class="comment">//存储数字符号</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span>[] mag; <span class="comment">//存储二进制块</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>BigInteger</code>将大数字分为若干二进制块(unsigned)，动态调整存储这些二进制块的数组，<code>BigInteger</code>理论上可以表示任意大的数字（受限于java数组只能开<code>Integer.MAX_VALUE</code>大小，所以最大大概可以表示 $ (2 \times 2147483648) ^ {2147483648} $</li>
<li>显然，<code>BigInteger</code>挑选了一个很大的值作为基准，所以我们可以参考它的思想，也像它这样存储大数，不过因为我们<s>没有java那么nb</s>，我们算乘法的值不能超过32位，所以<code>base</code>可以适当地取得小一点例如我取了<code>10000</code>也就是每一个进制块只能表示<code>0 ~ 9999</code></li>
</ul>
</li>
<li>最后，似乎大数乘法也有若干很神奇的优化，像什么<code>FFT</code>、<code>Karatsuba</code>什么什么算法，太高大上了看不懂怎么实现的（<s>找了一段<code>FFT + Karatsuba</code>的诡异代码</s>，明明每个操作都认识，放一起这么出来了这么奇怪的代码）</li>
<li>所以我使用了最最朴素的乘法<code>*</code><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BASE 1000</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">multiply</span><span class="params">(<span class="type">int</span> mag[], <span class="type">int</span> *mag_size, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; *mag_size; i++) &#123;</span><br><span class="line">        <span class="type">int</span> prod = mag[i] * num + carry;</span><br><span class="line">        mag[i] = prod % BASE;</span><br><span class="line">        carry = prod / BASE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (carry) &#123;</span><br><span class="line">        mag[(*mag_size)++] = carry % BASE;</span><br><span class="line">        carry /= BASE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>一个提醒
<ul>
<li>最开始我一直有一个点没过，我以为有一个超级超级强的数据，而且还放在第一个，<s>差点就回去看<code>FFT + Karatsuba</code></s>，后来发现我使用的<code>beq</code>指令，如果碰见计算<code>0!</code>下面这样的情况循环21亿多次才会结束（</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read_in($s0) # 读入n</span><br><span class="line">li $t0, 2 # 从2的阶乘开始算</span><br><span class="line">addi $s0, $s0, 1 # n = n + 1</span><br><span class="line"></span><br><span class="line">for_i_begin:</span><br><span class="line">    beq $t0, $s0, for_i_end</span><br><span class="line">for_i_end:</span><br></pre></td></tr></table></figure>
<ul>
<li>数据还是很弱的，没有真的到1000位，主要还是考查高精度吧，助教们真好</li>
</ul>
</li>
</ul>
<hr />
<h3 id="鬼点子"><a class="markdownIt-Anchor" href="#鬼点子"></a> 鬼点子</h3>
<ul>
<li>接下来的一切内容全部不保真，<s>仅供学习和交流使用</s></li>
<li>例如上面两道附加题，大概都是需要自己写出C语言代码再进行翻译，当然不乏有巨佬完全不需要这样orz，所以是否可以使用gcc编译器汇编并用objdump进行反汇编得到汇编代码<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -O3 -funroll-loops -finline-functions -fomit-frame-pointer -march=native factorial.c -o factorial</span><br><span class="line">objdump -d factorial</span><br></pre></td></tr></table></figure>
</li>
<li>然后观察生成的<code>x86-64</code>代码的思路，或者<s>直接将其修改为mips汇编</s>，感觉有可行性，但是不多，不过可以使用gcc编译器学一学汇编是真的，可以看编译器会这么使用寄存器和栈来实现一个结构、函数之类的</li>
<li>不过也许或者大概可能课上不会出现强优化的题目？（味精）</li>
</ul>
<hr />
<h2 id="p2推荐题目"><a class="markdownIt-Anchor" href="#p2推荐题目"></a> P2推荐题目</h2>
<p><a href="https://kie-chi.github.io/2024/10/09/CO_P2_extra/">偷摸地夹带私货</a></p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
        <category>课下复习</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础--字符串(一)</title>
    <url>/2024/09/21/Python_%E5%AD%97%E7%AC%A6%E4%B8%B2_1/</url>
    <content><![CDATA[<h1 id="python基础之字符串一"><a class="markdownIt-Anchor" href="#python基础之字符串一"></a> Python基础之字符串(一)</h1>
<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<font face="宋体">
&nbsp;&nbsp;随着计算机发展日益加快，就算对于非计算机专业人士也通过键盘、鼠标等IO组件与计算机进行沟通。我们手指的每一次敲击，都传送给计算机输入某个“字符”的信号，字符与字符串不仅是编程语言的基本组成元素，更是我们与计算机交流的桥梁
<br>
&nbsp;&nbsp;对于<mark class="hl-label blue">Python</mark> 这门现代编程语言，字符串的操作也是重中之重，接下来让我们一起学习有关字符串的内容吧
</font>
<h2 id="什么是字符串"><a class="markdownIt-Anchor" href="#什么是字符串"></a> 什么是字符串</h2>
<h3 id="字符串的创建"><a class="markdownIt-Anchor" href="#字符串的创建"></a> 字符串的创建</h3>
<ul>
<li>对于较早的C语言等，字符一般而言指<code>acsii</code>规定的128个字符，包括英文字母、数字、一些控制字符，而由这些字符组成的一串字符被形象地称作字符串<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">char</span> str[<span class="number">10</span>] = <span class="string">&quot;abcde&quot;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>而<code>Python3</code>采用了号称万国码的<code>Unicode</code>字符集，可以表示包括中文、阿拉伯文等多国文字在内的若干字符，当然通过<code>Python</code>内置的编码、解码函数可以实现<code>utf-8</code>、<code>ascii</code>等其他编码方式之间的互相转换，当然这是后话了<br />
<strong>这里放一个编码的链接</strong></li>
<li>在<code>Python</code>中没有字符和字符串的明显区别，字符串可以使用<code>'</code>或者<code>&quot;</code>定义，甚至对于多行字符串，可以使用<code>&quot;&quot;&quot;</code>或者<code>'''</code>来包含多行文本而不用在字符串间换行位置使用换行符<code>\n</code>，甚至允许使用<code>\</code>来拼接多行字符串为一行<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python中没有字符和字符串的区分</span></span><br><span class="line">char_one = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">char_two = <span class="string">&quot;a&quot;</span></span><br><span class="line">chars = <span class="string">&#x27;abcde&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(char_one)</span><br><span class="line"><span class="built_in">print</span>(char_two)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多行字符串</span></span><br><span class="line">lines = <span class="string">&quot;&quot;&quot;this is a long string</span></span><br><span class="line"><span class="string">that spans multiple lines&quot;&quot;&quot;</span></span><br><span class="line">lines_single = <span class="string">&#x27;&#x27;&#x27;this is also a long </span></span><br><span class="line"><span class="string">string</span></span><br><span class="line"><span class="string">that spans mutiple lines too&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(lines)</span><br><span class="line"><span class="built_in">print</span>(lines_single)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拼接多行字符</span></span><br><span class="line">new_lines = <span class="string">&quot;this is a long string&quot;</span>\</span><br><span class="line">            <span class="string">&quot;that over&quot;</span>\</span><br><span class="line">            <span class="string">&quot;multiple lines&quot;</span></span><br><span class="line"><span class="built_in">print</span>(new_lines)</span><br></pre></td></tr></table></figure>
<details class="toggle" ><summary class="toggle-button" style="">输出内容</summary><div class="toggle-content"><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line">a</span><br><span class="line">this is a long string</span><br><span class="line">that spans multiple lines</span><br><span class="line">this is also a long string</span><br><span class="line">that spans multiple lines</span><br><span class="line">this is a long string that over multiple lines</span><br></pre></td></tr></table></figure>
</div></details>
</li>
</ul>
<hr />
<h3 id="字符串不可变性"><a class="markdownIt-Anchor" href="#字符串不可变性"></a> 字符串不可变性</h3>
<ul>
<li>在<code>Python</code>中所有数据都是通过引用传递与使用的，这意味着我们一般只管理指向数据的引用（<s>大概是Python不用写数据类型的原因之一</s>），传递数据一般也只是传递数据的引用而非数据本身(除深浅拷贝外)</li>
</ul>
 <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 简单数据类型</span></span><br><span class="line">a = <span class="number">12</span></span><br><span class="line">b = a <span class="comment"># b接收的是a的引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复杂数据类型</span></span><br><span class="line">str_a = <span class="string">&quot;1234&quot;</span></span><br><span class="line">str_b = str_a <span class="comment"># 同理接收的是引用 </span></span><br></pre></td></tr></table></figure>
<ul>
<li>这时，小熊饼干突然想修改<code>str_b</code>的值便加入了一系列指令<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;展示修改前地址:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(str_a))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(str_b))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;展示修改前值:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(str_a)</span><br><span class="line"><span class="built_in">print</span>(str_b)</span><br><span class="line"></span><br><span class="line">str_b += <span class="string">&quot;5&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;展示修改后地址:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(str_a))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(str_b))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;展示修改后值:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(str_a)</span><br><span class="line"><span class="built_in">print</span>(str_b)</span><br></pre></td></tr></table></figure>
<details class="toggle" ><summary class="toggle-button" style="">运行结果</summary><div class="toggle-content"><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">展示修改前地址:</span><br><span class="line">140123456789056</span><br><span class="line">140123456789056</span><br><span class="line">展示修改前值:</span><br><span class="line">1234</span><br><span class="line">1234</span><br><span class="line">展示修改后地址:</span><br><span class="line">140123456789056</span><br><span class="line">342453543545131</span><br><span class="line">1234</span><br><span class="line">12345</span><br></pre></td></tr></table></figure></div></details>
我们惊奇地发现<code>str_b</code>指向的地址在修改前后发生了变化，这是因为字符串是一种<mark class="hl-label red">不可变类型</mark> ，任何针对字符串<strong>内容</strong>的改变都是不被允许的，所以我们进行修改<code>str_b</code>的操作<code>str_b += &quot;5&quot;</code>时，<code>Python</code>直接创建了一个新的变量<code>&quot;12345&quot;</code>然后将这个变量的地址赋给<code>str_b</code><details class="toggle" ><summary class="toggle-button" style="">什么是可变类型呢</summary><div class="toggle-content"><p>对于<code>str</code>、<code>tuple</code>、<code>byte</code>等<strong>不可变类型</strong>数据，一旦创立就无法修改其内容，而对于<code>list</code>、<code>dict</code>等<strong>可变类型</strong>我们允许在创立后继续修改其内容，如下</p>
<ul>
<li>甲方要求小熊饼干写一个复制一份<code>list</code>的Python文件，于是他写下如下代码</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">list_a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">list_b = list_a</span><br></pre></td></tr></table></figure>
<p>就在他写完时，甲方要求他在复制的副本中加入其他几个元素，睡眼朦胧的小熊饼干草草地写完了代码，没想到第二天代码出了问题，原始数据<code>list</code>遭到篡改，小熊饼干因此下岗了，呜呜呜</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;打印修改前地址:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(list_a))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(list_b))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;打印修改前值:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(list_a)</span><br><span class="line"><span class="built_in">print</span>(list_b)</span><br><span class="line"></span><br><span class="line">list_b.append(<span class="number">5</span>)</span><br><span class="line">list_b.append(<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;打印修改后地址:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(list_a))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(list_b))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;打印修改后值:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(list_a)</span><br><span class="line"><span class="built_in">print</span>(list_b)</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">打印修改前地址:</span><br><span class="line">140123456789056</span><br><span class="line">140123456789056</span><br><span class="line">打印修改前值:</span><br><span class="line">[1, 2, 3, 4]</span><br><span class="line">[1, 2, 3, 4]</span><br><span class="line">打印修改后地址:</span><br><span class="line">140123456789056</span><br><span class="line">140123456789056</span><br><span class="line">打印修改后值:</span><br><span class="line">[1, 2, 3, 4, 5, 6]</span><br><span class="line">[1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure>
<p><font color = red><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>t</mi><mi>t</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo>:</mo></mrow><annotation encoding="application/x-tex">Attention:</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal">t</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span></span></span></font>小熊饼干通过赋值手段使<code>list_a</code>和<code>list_b</code>指向同一对象，又因为<code>list</code>类型是<strong>可变类型</strong>，所以对于其内容的修改是被允许的，这时我们可以通过<code>list_a</code>或者<code>list_b</code>中的某一个引用修改原对象内容，也就导致指向该对象的所有引用的“值”同时变化</p>
</div></details>
</li>
</ul>
<hr />
<h3 id="字符串的简单操作"><a class="markdownIt-Anchor" href="#字符串的简单操作"></a> 字符串的简单操作</h3>
<h4 id="索引"><a class="markdownIt-Anchor" href="#索引"></a> 索引</h4>
<p>如果你曾经学习过C语言，一定记得字符串(字符数组)使用下标索引的场景（<s>熟悉而美好</s>，那么当然，<code>Python</code>提供了更为强大的索引功能</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">chars = <span class="string">&quot;abcdefg&quot;</span></span><br><span class="line">char = chars[<span class="number">0</span>] <span class="comment"># a</span></span><br><span class="line">char = chars[<span class="number">4</span>] <span class="comment"># d</span></span><br><span class="line">char = chars[-<span class="number">1</span>] <span class="comment"># g</span></span><br><span class="line">char = chars[-<span class="number">2</span>] <span class="comment"># f</span></span><br></pre></td></tr></table></figure>
<p>不仅提供了正向索引还有反向的，以后获得尾部的某些字符就轻松多了</p>
<h4 id="切片"><a class="markdownIt-Anchor" href="#切片"></a> 切片</h4>
<p>Python中提供的一种相较于一般索引更加高级的索引方式，可以灵活地处理字符串一般格式为<code>str[start:end:step]</code></p>
<ul>
<li><code>start</code>：切片的起始索引值，缺省为字符串开头</li>
<li><code>end</code>：切片的结束索引值（不包括），缺省为字符串结束后（即包括字符串最后一个字符）</li>
<li><code>step</code>：切片的步长，默认为1</li>
</ul>
  <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 正向索引</span></span><br><span class="line">test_str = <span class="string">&quot;人生苦短,我用Python&quot;</span></span><br><span class="line">chars = test_str[<span class="number">1</span>:<span class="number">3</span>] <span class="comment"># &quot;生苦&quot;</span></span><br><span class="line">chars = test_str[:<span class="number">6</span>] <span class="comment"># &quot;人生苦短,我&quot;</span></span><br><span class="line">chars = test_str[<span class="number">6</span>:] <span class="comment"># &quot;用Python&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 整段切片</span></span><br><span class="line">chars = test_str[:] <span class="comment"># &quot;人生苦短,我用Python&quot;</span></span><br><span class="line">chars = test_str[::<span class="number">2</span>] <span class="comment"># &quot;人苦，用yhn&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 倒排索引(雾</span></span><br><span class="line">chars = test_str[::-<span class="number">1</span>] <span class="comment"># &quot;nohtyP用我,短苦生人&quot;</span></span><br><span class="line">chars = test_str[<span class="number">5</span>:<span class="number">1</span>:-<span class="number">1</span>] <span class="comment"># &quot;我,短苦&quot;</span></span><br><span class="line">chars = test_str[:-<span class="number">7</span>:-<span class="number">1</span>] <span class="comment"># ”nohtyP“</span></span><br></pre></td></tr></table></figure>
<hr />
<h2 id="str类"><a class="markdownIt-Anchor" href="#str类"></a> str类</h2>
<p>相信学习过任何一门具有面向对象特性的编程语言的同学对这个词都不会陌生，简而言之，在面向对象设计中，万物都为“对象”；具有相同属性和行为的一群对象分为一个“类”，这个类抽象出对象群体共同的特性（属性）和行为（方法）</p>
<ul>
<li>在这里，各种不同的字符串都是对象，他们共同构成了类<code>str</code>，因为他们有某些共同的特性，如编码方式，有可以对所有字符串对象使用的方法，如查找子串，请你跟随小熊饼干，一起学习blog中讲解的第一个类<code>str</code></li>
<li>因为某些原因，我们将构造方法和一些魔术方法放在后续内容中介绍，敬请关注</li>
</ul>
<h3 id="内置方法普通"><a class="markdownIt-Anchor" href="#内置方法普通"></a> 内置方法（普通）</h3>
<h4 id="去除字符熟练掌握"><a class="markdownIt-Anchor" href="#去除字符熟练掌握"></a> 去除字符(熟练掌握)</h4>
<ul>
<li><code>str.strip(sub_string)</code>
<ul>
<li>从字符串左右去除所给字符串中的所有字符，缺省为空去除空白字符</li>
</ul>
</li>
<li><code>str.rstrip(sub_string)</code>
<ul>
<li>从字符串右去除所给字符串中的所有字符，缺省为空去除空白字符</li>
</ul>
</li>
<li><code>str.lstrip(sub_string)</code>
<ul>
<li>从字符串左去除所给字符串中的所有字符，缺省为空去除空白字符</li>
</ul>
</li>
<li>都只会去除连续匹配的字符，若有不匹配，则立即停止<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;  hello  &quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.strip())  </span><br><span class="line"><span class="built_in">print</span>(s.strip(<span class="string">&quot; h&quot;</span>))  </span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;  hello  &quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.lstrip()) </span><br><span class="line"><span class="built_in">print</span>(s.lstrip(<span class="string">&quot; h&quot;</span>)) </span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;  hello  &quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.rstrip()) </span><br><span class="line"><span class="built_in">print</span>(s.rstrip(<span class="string">&quot; o&quot;</span>))  </span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;abc123cba&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.strip(<span class="string">&quot;abc&quot;</span>))</span><br></pre></td></tr></table></figure>
<div class="hide-block"><button type="button" class="hide-button" style="">查看输出内容
    </button><div class="hide-content"><p>空格使用下滑线表示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hello</span><br><span class="line">ello</span><br><span class="line">hello____</span><br><span class="line">ello___</span><br><span class="line">___hello</span><br><span class="line">___hell</span><br><span class="line">123   </span><br></pre></td></tr></table></figure>
</div></div>
</li>
</ul>
<hr />
<h4 id="查找与计数熟练掌握"><a class="markdownIt-Anchor" href="#查找与计数熟练掌握"></a> 查找与计数(熟练掌握)</h4>
<ul>
<li><code>str.find(sub_string)</code>
<ul>
<li>从字符串<strong>左端</strong>开始查找，返回第一个匹配子串的索引值，没有<strong>返回-1</strong></li>
</ul>
</li>
<li><code>str.rfind(sub_string)</code>
<ul>
<li>从字符串<strong>右端</strong>开始查找，返回第一个匹配子串的索引值，没有<strong>返回-1</strong></li>
</ul>
</li>
<li><code>str.index(sub_string)</code>
<ul>
<li>从字符串<strong>左端</strong>开始查找，返回第一个匹配子串的索引值，没有<strong>抛出异常</strong></li>
</ul>
</li>
<li><code>str.rindex(sub_string)</code>
<ul>
<li>从字符串<strong>右端</strong>开始查找，返回第一个匹配子串的索引值，没有<strong>抛出异常</strong></li>
</ul>
</li>
<li><code>str.count(sub_string, [start, end])</code>
<ul>
<li><code>[]</code>在函数注解中代表可有可无的参数</li>
<li>计算子串在这个字符串中出现的次数，可指定计数区间</li>
</ul>
</li>
<li><code>in &amp;&amp; not in</code>
<ul>
<li>对于字符串这种可迭代对象可以使用<code>Python</code>内置的操作符判断一个元素是否在这个对象中</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">chars = <span class="string">&quot;hello, Python! I love Python ! We all use Python&quot;</span></span><br><span class="line"><span class="built_in">print</span>(chars.find(<span class="string">&quot;Python&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(chars.rfind(<span class="string">&quot;Python&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(chars.index(<span class="string">&quot;Python&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(chars.index(<span class="string">&quot;Python&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(chars.count(<span class="string">&quot;Python&quot;</span>, <span class="number">0</span>, <span class="built_in">len</span>(chars)))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Python&quot;</span> <span class="keyword">in</span> chars)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Chi&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> chars)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(chars.index(<span class="string">&quot;Chi&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(chars.find(<span class="string">&quot;Chi&quot;</span>))</span><br></pre></td></tr></table></figure>
<div class="hide-block"><button type="button" class="hide-button" style="">查看输出内容
    </button><div class="hide-content"><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">42</span><br><span class="line">7</span><br><span class="line">7</span><br><span class="line">3</span><br><span class="line">True</span><br><span class="line">True</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;D:\Pycharm_code\math_and_\test.py&quot;</span>, line 8, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="built_in">print</span>(chars.index(<span class="string">&quot;Chi&quot;</span>))</span><br><span class="line">ValueError: substring not found</span><br></pre></td></tr></table></figure>
</div></div>
</li>
</ul>
<hr />
<h4 id="实用熟练掌握"><a class="markdownIt-Anchor" href="#实用熟练掌握"></a> 实用(熟练掌握)</h4>
<ul>
<li><code>str.replace(string1, string2)</code>
<ul>
<li>将字符串中的全部<code>string1</code>都替换为<code>string2</code></li>
</ul>
</li>
<li><code>str.split(base, [count])</code>
<ul>
<li>将字符串按照<code>base</code>为基准分为不同的字符串，分割的次数可以显式地给出，优先从左到右，返回一个字符串列表</li>
</ul>
</li>
<li><code>str.join(itereable)</code>
<ul>
<li>将可迭代对象(可以先理解为数组、元组这些有基本元素的类型，字符串也是了)，将其中的元素直接使用<code>str</code>连接拼接为一个更长的字符串</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">chars = <span class="string">&quot;Python and language C&quot;</span></span><br><span class="line"><span class="built_in">print</span>(chars.replace(<span class="string">&quot;language C&quot;</span>, <span class="string">&quot;Python&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(chars.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(chars.split(<span class="string">&quot; &quot;</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>.join(chars))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&amp;&quot;</span>.join(chars.split(<span class="string">&quot; &quot;</span>)))</span><br></pre></td></tr></table></figure>
<div class="hide-block"><button type="button" class="hide-button" style="">查看输出内容
    </button><div class="hide-content"><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Python and Python</span><br><span class="line">[<span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;and&#x27;</span>, <span class="string">&#x27;language&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;and&#x27;</span>, <span class="string">&#x27;language C&#x27;</span>]</span><br><span class="line">P*y*t*h*o*n* *a*n*d* *l*a*n*g*u*a*g*e* *C</span><br><span class="line">Python&amp;and&amp;language&amp;C</span><br></pre></td></tr></table></figure>
</div></div>
</li>
</ul>
<div class="note info simple"><p>字符串不可修改，所以如果需要对字符串进行操作记得用变量接收哦</p>
</div>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">chars = chars.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">new_chars = chars.split(<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="大小写转换了解即可"><a class="markdownIt-Anchor" href="#大小写转换了解即可"></a> 大小写转换(了解即可)</h4>
<ul>
<li><code>str.upper()</code>
<ul>
<li>将字符串内所有字符转为大写</li>
</ul>
</li>
<li><code>str.lower()</code>
<ul>
<li>将字符串内所有字符转为小写</li>
</ul>
</li>
<li><code>str.capitalize()</code>
<ul>
<li>将字符串首字母大写</li>
</ul>
</li>
<li><code>str.title()</code>
<ul>
<li>将字符串每个单词首字母大写</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">chars = <span class="string">&quot;hello, world&quot;</span></span><br><span class="line">chars_upper = chars.upper()</span><br><span class="line">chars_lower = chars.lower()</span><br><span class="line">chars_cap = chars.capitalize()</span><br><span class="line">chars_title = chars.title()</span><br><span class="line"><span class="built_in">print</span>(chars_upper)</span><br><span class="line"><span class="built_in">print</span>(chars_lower)</span><br><span class="line"><span class="built_in">print</span>(chars_cap)</span><br><span class="line"><span class="built_in">print</span>(chars_title)</span><br></pre></td></tr></table></figure>
<div class="hide-block"><button type="button" class="hide-button" style="">查看输出内容
    </button><div class="hide-content"><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">HELLO, WORLD</span><br><span class="line">hello, world</span><br><span class="line">Hello, world</span><br><span class="line">Hello, World</span><br></pre></td></tr></table></figure>
</div></div>
</li>
</ul>
<hr />
<h4 id="特判了解即可"><a class="markdownIt-Anchor" href="#特判了解即可"></a> 特判(了解即可)</h4>
<ul>
<li>不咋用，因为我都有正则了还要什么自行车？</li>
<li><code>str.isalpha()</code>
<ul>
<li>是否全是英文字母</li>
</ul>
</li>
<li><code>str.isspace()</code>
<ul>
<li>是否全为空白符</li>
</ul>
</li>
<li><code>str.isupper()</code>
<ul>
<li>是否全为大写字母</li>
</ul>
</li>
<li><code>str.islower()</code>
<ul>
<li>是否全为小写字母</li>
</ul>
</li>
<li><code>str.istitle()</code>
<ul>
<li>是否是标题格式，单词第一个大写</li>
</ul>
</li>
<li><code>str.isdecimal()</code>
<ul>
<li>是否是十进制阿拉伯数字，不包含其他任何形式的数字</li>
</ul>
</li>
<li><code>str.isdigit()</code>
<ul>
<li>比上面更广，可以包含上标数字、罗马数字、全角数字</li>
</ul>
</li>
<li><code>str.isnumeric()</code>
<ul>
<li>比上面更广，甚至可以识别中文数字和分数数字</li>
</ul>
</li>
<li><code>str.isalnum()</code>
<ul>
<li>是否全为字母和数字</li>
<li>字母不限于英文字母，还有各国语言字母</li>
<li>数字不识别分数</li>
</ul>
</li>
<li><code>str.startswith()</code>
<ul>
<li>以什么指定字符串开头</li>
</ul>
</li>
<li><code>str.endswith()</code>
<ul>
<li>以什么指定字符串结尾</li>
</ul>
</li>
</ul>
<hr />
<h4 id="tips"><a class="markdownIt-Anchor" href="#tips"></a> tips</h4>
<ul>
<li>如果你希望想C语言一样通过码点的位置定位一个字符的话，就继续看吧
<ul>
<li>例如<code>A</code>字符在ascii表中对于着65，所以<code>A</code>也可以写为<code>'\x65'</code></li>
</ul>
<div class="hide-block"><button type="button" class="hide-button" style="">查看示例
    </button><div class="hide-content"><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">chars = <span class="string">&#x27;\x65&#x27;</span></span><br><span class="line">byte_string = char.encode(<span class="string">&#x27;latin1&#x27;</span>) <span class="comment"># 将chars理解为Byte串</span></span><br><span class="line">char = byte_string.decode() <span class="comment"># 进行utf-8解码</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(chars)</span><br><span class="line"><span class="built_in">print</span>(byte_string)</span><br><span class="line"><span class="built_in">print</span>(char)</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">A</span><br><span class="line">b<span class="string">&#x27;A&#x27;</span></span><br><span class="line">A</span><br></pre></td></tr></table></figure>
</div></div>
</li>
<li>同理，对于unicode字符集（涵盖ascii）中的字符也可以进行转义，不过不能直接使用类似于上面的格式
<ul>
<li>例如<code>中</code>字符在<code>utf-8</code>编码方式中的三个字节标识是<code>'\xe4\xb8\xad'</code>，就不可以直接打印转义字符串，Python会理解为三个在ascii码表中的字符</li>
</ul>
<div class="hide-block"><button type="button" class="hide-button" style="">查看示例
    </button><div class="hide-content"><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">chars = <span class="string">&#x27;\xe4\xb8\xad&#x27;</span></span><br><span class="line">byte_string = chars.encode(<span class="string">&#x27;latin1&#x27;</span>) <span class="comment"># 将chars编码理解为Byte串</span></span><br><span class="line">char = byte_string.decode() <span class="comment"># 默认以utf-8来解码</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(chars)</span><br><span class="line"><span class="built_in">print</span>(byte_string)</span><br><span class="line"><span class="built_in">print</span>(char)</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ä¸­-</span><br><span class="line">b<span class="string">&#x27;\xe4\xb8\xad&#x27;</span></span><br><span class="line">中</span><br></pre></td></tr></table></figure>
</div></div>
</li>
<li>最后，Python内置了提供字符码点的函数（<strong>非ascii码字符的码点</strong>与<strong>utf-8编码的标识</strong>是两个概念）</li>
<li><code>ord()</code>
<ul>
<li>由字符得到码点</li>
</ul>
</li>
<li><code>chr()</code>
<ul>
<li>由码点生成字符</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2024/09/10/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2>
<h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>the information is here</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GA</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, gender, age</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.gender = gender</span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;name:<span class="subst">&#123;name&#125;</span>,gender:<span class="subst">&#123;gender&#125;</span>,age:<span class="subst">&#123;age&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> deap <span class="keyword">import</span> base,tools,algorithms,creator</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># import random</span></span><br><span class="line"></span><br><span class="line">IND_NUM = <span class="number">30</span> <span class="comment"># 30位编码，[-5,5]，精度是8位</span></span><br><span class="line">POP_NUM = <span class="number">100</span> <span class="comment"># 种群总个体数量</span></span><br><span class="line">OFS_MAX = <span class="number">50</span> <span class="comment"># 后代最大值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decode</span>(<span class="params">individual</span>):</span><br><span class="line">    num = <span class="built_in">int</span>(<span class="string">&#x27;&#x27;</span>.join([<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> individual]),<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> (-<span class="number">5</span> + (<span class="number">10</span> * num)/(<span class="number">2</span>**<span class="number">30</span> - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">eval</span>(<span class="params">individual</span>):</span><br><span class="line">    x = decode(individual)</span><br><span class="line">    <span class="keyword">return</span> ((np.square(x) + x) * np.cos(<span class="number">2</span> * x) + np.square(x) + x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">creator.create(<span class="string">&quot;FitnessMin&quot;</span>,base.Fitness,weights=(-<span class="number">1.0</span>,))</span><br><span class="line">creator.create(<span class="string">&quot;Individual&quot;</span>,<span class="built_in">list</span>,fitness = creator.FitnessMin)</span><br><span class="line"></span><br><span class="line">toolbox = base.Toolbox()</span><br><span class="line">toolbox.register(<span class="string">&quot;attribute&quot;</span>,np.random.randint,<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">toolbox.register(<span class="string">&quot;individual&quot;</span>, tools.initRepeat, creator.Individual, toolbox.attribute, n=IND_NUM)</span><br><span class="line">toolbox.register(<span class="string">&quot;population&quot;</span>, tools.initRepeat, <span class="built_in">list</span>, toolbox.individual)</span><br><span class="line">pop = toolbox.population(n=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">toolbox.register(<span class="string">&quot;evaluate&quot;</span>, <span class="built_in">eval</span>)</span><br><span class="line">toolbox.register(<span class="string">&quot;select&quot;</span>, tools.selTournament, <span class="number">3</span>)</span><br><span class="line">toolbox.register(<span class="string">&quot;mate&quot;</span>, tools.cxUniform, indpb=<span class="number">0.5</span>)</span><br><span class="line">toolbox.register(<span class="string">&quot;mutate&quot;</span>, tools.mutFlipBit, indpb=<span class="number">0.5</span>)</span><br><span class="line"><span class="comment"># tools.mutFlipBit()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stats = tools.Statistics(key=<span class="keyword">lambda</span> x: x.fitness.values)</span><br><span class="line">stats.register(<span class="string">&quot;avg&quot;</span>, np.mean)</span><br><span class="line">stats.register(<span class="string">&quot;std&quot;</span>, np.std)</span><br><span class="line">stats.register(<span class="string">&quot;min&quot;</span>, np.<span class="built_in">min</span>)</span><br><span class="line">stats.register(<span class="string">&quot;max&quot;</span>, np.<span class="built_in">max</span>)</span><br><span class="line"></span><br><span class="line">resultPop, logbook = algorithms.eaSimple(pop, toolbox, cxpb=<span class="number">0.5</span>, mutpb=<span class="number">0.2</span>, ngen=POP_NUM, stats=stats, verbose=<span class="literal">False</span>)</span><br><span class="line">logbook.header = <span class="string">&#x27;gen&#x27;</span>,<span class="string">&#x27;nevals&#x27;</span>,<span class="string">&#x27;avg&#x27;</span>,<span class="string">&#x27;std&#x27;</span>,<span class="string">&#x27;min&#x27;</span>,<span class="string">&#x27;max&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(logbook)    </span><br></pre></td></tr></table></figure>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  pie
    title Key elements in Product X
    &quot;Calcium&quot; : 42.96
    &quot;Potassium&quot; : 50.05
    &quot;Magnesium&quot; : 10.01
    &quot;Iron&quot; :  5
  </pre></div>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3>
<ul>
<li>我有一个好点子</li>
</ul>
<div class="tabs" id="test4-"><ul class="nav-tabs no-default"><button type="button" class="tab " data-href="test4--1">第一个Tab</button><button type="button" class="tab " data-href="test4--2"><i class="fab fa-apple-pay" style="text-align: center;"></i></button><button type="button" class="tab " data-href="test4--3"><i class="fas fa-bomb"></i>炸弹</button></ul><div class="tab-contents"><div class="tab-item-content" id="test4--1"><p><strong>tab名字为第一个Tab</strong></p></div><div class="tab-item-content" id="test4--2"><p><strong>只有图标 没有Tab名字</strong></p></div><div class="tab-item-content" id="test4--3"><p><strong>名字+icon</strong></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<p>作者: Jerry<br />
連結: <a href="https://butterfly.js.org/posts/4aa8abbe/">https://butterfly.js.org/posts/4aa8abbe/</a><br />
來源: Butterfly<br />
著作權歸作者所有。商業轉載請聯繫作者獲得授權，非商業轉載請註明出處。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<div class="flink"><div class="flink-name">友情链接</div><div class="flink-desc">那些人，那些事</div> <div class="flink-list">
          <div class="flink-list-item">
            <a href="https://jerryc.me/" title="JerryC" target="_blank">
              <div class="flink-item-icon">
                <img class="no-lightbox" src="https://jerryc.me/img/avatar.png" onerror='this.onerror=null;this.src="/img/friend_404.gif"' alt="JerryC" />
              </div>
              <div class="flink-item-name">JerryC</div> 
              <div class="flink-item-desc" title="今日事,今日毕">今日事,今日毕</div>
            </a>
          </div>
          <div class="flink-list-item">
            <a href="https://hexo.io/zh-tw/" title="Hexo" target="_blank">
              <div class="flink-item-icon">
                <img class="no-lightbox" src="https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg" onerror='this.onerror=null;this.src="/img/friend_404.gif"' alt="Hexo" />
              </div>
              <div class="flink-item-name">Hexo</div> 
              <div class="flink-item-desc" title="快速、简单且强大的网志框架">快速、简单且强大的网志框架</div>
            </a>
          </div></div><div class="flink-name">网站</div><div class="flink-desc">值得推荐的网站</div> <div class="flink-list">
          <div class="flink-list-item">
            <a href="https://www.youtube.com/" title="Youtube" target="_blank">
              <div class="flink-item-icon">
                <img class="no-lightbox" src="https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png" onerror='this.onerror=null;this.src="/img/friend_404.gif"' alt="Youtube" />
              </div>
              <div class="flink-item-name">Youtube</div> 
              <div class="flink-item-desc" title="视频网站">视频网站</div>
            </a>
          </div>
          <div class="flink-list-item">
            <a href="https://www.weibo.com/" title="Weibo" target="_blank">
              <div class="flink-item-icon">
                <img class="no-lightbox" src="https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png" onerror='this.onerror=null;this.src="/img/friend_404.gif"' alt="Weibo" />
              </div>
              <div class="flink-item-name">Weibo</div> 
              <div class="flink-item-desc" title="中国最大社交分享平台">中国最大社交分享平台</div>
            </a>
          </div>
          <div class="flink-list-item">
            <a href="https://twitter.com/" title="Twitter" target="_blank">
              <div class="flink-item-icon">
                <img class="no-lightbox" src="https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png" onerror='this.onerror=null;this.src="/img/friend_404.gif"' alt="Twitter" />
              </div>
              <div class="flink-item-name">Twitter</div> 
              <div class="flink-item-desc" title="社交分享平台">社交分享平台</div>
            </a>
          </div></div></div>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Python基础--字符串(二)</title>
    <url>/2024/09/26/Python_%E5%AD%97%E7%AC%A6%E4%B8%B2_2/</url>
    <content><![CDATA[<h1 id="python基础字符串二"><a class="markdownIt-Anchor" href="#python基础字符串二"></a> Python基础–字符串(二)</h1>
<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<p>请确保你已经有一定的<code>Python</code>基础且对字符串有一定了解哦，今天我们依旧来探索字符串的秘密，发车了(<s>是因为笔者太懒才没有一次性写完的</s>)，完全不了解的小伙伴们也不用慌，移步<a href="/2024/09/21/Python_%E5%AD%97%E7%AC%A6%E4%B8%B2_1/" title="Python基础--字符串(一)">Python基础--字符串(一)</a></p>
<h2 id="格式化字符串"><a class="markdownIt-Anchor" href="#格式化字符串"></a> 格式化字符串</h2>
<h3 id="传统式"><a class="markdownIt-Anchor" href="#传统式"></a> <code>%</code>传统式</h3>
<ul>
<li>你是否看过这些特殊的字符串<code>%s</code>，<code>%d</code>呢，相信写过C语言的同学们一定不陌生了，如果没见过也没关系，他们都是一类特殊的字符串，我们称之为格式化字符串，常用于格式化我们的输出，那么我们就从最传统的<code>%</code>式格式化字符串讲解吧</li>
</ul>
<h4 id="常用的格式化字符串"><a class="markdownIt-Anchor" href="#常用的格式化字符串"></a> 常用的格式化字符串</h4>
<ul>
<li><code>%s</code>
<ul>
<li>适用于为字符串占位，<s>我本来就是啊</s></li>
</ul>
</li>
<li><code>%d</code>
<ul>
<li>适用于为十进制数字占位，类似的还有<code>%x</code> <code>%o</code> <code>%b</code></li>
</ul>
</li>
<li><code>%f</code>
<ul>
<li>适用于为浮点数占位</li>
</ul>
</li>
<li><code>.precision</code>
<ul>
<li>适用于对浮点数精度控制，<code>%.2f</code>保留两位小数，默认是6位小数</li>
</ul>
</li>
<li><code>width</code>
<ul>
<li>指定占位符占据的宽度，<code>%5d</code>十进制整数至少占5个单位，不够补充</li>
</ul>
</li>
<li><code>flags</code>
<ul>
<li>指定填充位与对齐，与<code>width</code>位共同控制对齐问题</li>
<li><code>0</code>，补充前导0</li>
<li><code>-</code>，左对齐，默认是右对齐，将覆盖前导0</li>
<li><code> </code>，方便正数与负数对齐</li>
<li><code>+</code>，数字补齐符号</li>
</ul>
</li>
<li>可以搭配使用，例如<code>%-5.2f</code>等等</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;% d %+d&quot;</span> % (<span class="number">1234</span>, <span class="number">1234</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;% d %+d&quot;</span> % (-<span class="number">1234</span>, -<span class="number">1234</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%4d,%4d,%6.2f&quot;</span> % (<span class="number">12</span>, <span class="number">34</span>, <span class="number">3.1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%-4d,%-4d,%-6.2f&quot;</span> % (<span class="number">12</span>, <span class="number">34</span>, <span class="number">3.1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%04d,%04d,%06.2f&quot;</span> % (<span class="number">12</span>, <span class="number">234</span>, <span class="number">3.1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%0-4d,%0-4d,%0-6.2f&quot;</span> % (<span class="number">12</span>, <span class="number">234</span>, <span class="number">3.1</span>)) <span class="comment"># 产生覆盖行为</span></span><br></pre></td></tr></table></figure>
<pre><code> 1234 +1234
-1234 -1234
  12,  34,  3.10
12  ,34  ,3.10  
0012,0234,003.10
12  ,234 ,3.10  
</code></pre>
<h3 id="format"><a class="markdownIt-Anchor" href="#format"></a> format</h3>
<h4 id="默认格式化"><a class="markdownIt-Anchor" href="#默认格式化"></a> 默认格式化</h4>
<ul>
<li>不再通过<code>%</code>的形式指定，而是默认形式填充，我们只需要负责哪些位置填充什么字符即可</li>
<li>大括号中默认格式填入我们指定的参数，默认顺序是依次填入
<ul>
<li><code>&quot;&#123;&#125; &#123;&#125;&quot;.format(12, &quot;setdown&quot;)</code></li>
</ul>
</li>
<li>有需求可以在大括号中填入参数位置，可以多次使用，每个大括号都要填入位置
<ul>
<li><code>&quot;&#123;0&#125; &#123;1&#125; &#123;1&#125; &#123;0&#125;&quot;.format(12, &quot;setdown&quot;)</code></li>
<li><code>&quot;&#123;0&#125; &#123;1&#125;&quot;.format(12, &quot;setdown&quot;)</code></li>
</ul>
</li>
<li>利用键值对传入参数，则括号中必须使用key值
<ul>
<li><code>&quot;&#123;name&#125; &#123;age&#125;&quot;.format(name=&quot;setdown&quot;, age=12)</code></li>
<li><code>&quot;&#123;name&#125; &#123;age&#125; &#123;age&#125; &#123;name&#125;&quot;.format(name=&quot;setdown&quot;, age=12)</code></li>
</ul>
</li>
<li>利用键值对和位置进行复杂传参
<ul>
<li><code>&quot;&#123;0[name]&#125; &#123;1[age]&#125; &#123;0[0]&#125; &#123;1[1]&#125;&quot;.format(&#123;&quot;name&quot;:&quot;setdown&quot;, &quot;age&quot;:12&#125;, [12, 34])</code></li>
</ul>
</li>
</ul>
<h4 id="format_spec"><a class="markdownIt-Anchor" href="#format_spec"></a> format_spec</h4>
<ul>
<li>通过类似于<code>%</code>传统式格式化字符串规范要求</li>
<li><code>:[[fill] align][sign][0][width][.precision][type]</code></li>
<li><code>fill</code>
<ul>
<li>填充内容，对于指定宽度填充什么字符，需要显式指定对齐方式</li>
</ul>
</li>
<li><code>align</code>
<ul>
<li>对齐方式，<code>&lt;</code> <code>^</code> <code>&gt;</code>分别是强制左、居中、右对齐</li>
</ul>
</li>
<li><code>sign</code>
<ul>
<li>展示符号，<code>+</code>正负数都展示符号，<code> </code>负数展示符号正数留空对齐</li>
</ul>
</li>
<li><code>width</code>
<ul>
<li>最小宽度，默认为字符串长度</li>
</ul>
</li>
<li><code>precision</code>
<ul>
<li>控制小数的精度范围，默认是小数点后六位</li>
</ul>
</li>
<li><code>type</code>
<ul>
<li>常用类型有<code>d</code> <code>f</code> <code>s</code></li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;:_&lt;4&#125; &#123;:0&gt;6&#125; &#123;:$^10&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">11</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;:04&#125; &#123;:10&#125; &#123;:^10&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">12</span>, <span class="number">3</span>, <span class="number">34</span>))</span><br></pre></td></tr></table></figure>
<pre><code>1___ 000002 $$$$11$$$$
0012          3     34    
</code></pre>
<h2 id="f-string"><a class="markdownIt-Anchor" href="#f-string"></a> f-string</h2>
<ul>
<li>可以通过变量等方式直接转义进入字符串，经常使用，但是也可以使用<code>format_spec</code>来表达更加准确的字符串形式</li>
<li>简易使用方式为<code>f&quot;&#123;name&#125; is about &#123;value&#125;&quot;</code></li>
<li>使用占位的变量可以与<code>format_spec</code>嵌套使用更加灵活</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">line = <span class="string">&quot;this is a test string&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;line= &#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以起调试的作用</span></span><br><span class="line">a = <span class="number">1</span> + <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;a=&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">width = <span class="number">14</span></span><br><span class="line">align = <span class="string">&quot;^&quot;</span></span><br><span class="line">value = <span class="number">123.34</span></span><br><span class="line">precision = <span class="number">5</span></span><br><span class="line">fill = <span class="string">&quot;_&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;value:&#123;fill&#125;</span><span class="subst">&#123;align&#125;</span><span class="subst">&#123;width&#125;</span>.<span class="subst">&#123;precision&#125;</span>f&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>line= 'this is a test string'
a=3
__123.34000___
</code></pre>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
</search>
